#(comment created during unwrap): new block = resources/test_suite_results/gnu/output/build/root_input.arb: sub_block = 0
# root_input.arb file created by the arb script
##################################################################################
# the following external fortran files were found by the arb script and are available for inclusion: /home/daltonh/fortran/arb/testsuite/arb_master/src/free_surface_functions.f90
EXTERNALS "/home/daltonh/fortran/arb/testsuite/arb_master/src/free_surface_functions.f90"
##################################################################################
# the following working directory files found by the arb script: oscillating_level_set_drop_with_reflect.arb
   #(comment created during unwrap): new block = oscillating_level_set_drop_with_reflect.arb: sub_block = 0
   #(hash inserted during unwrap)INCLUDE_WORKING "oscillating_level_set_drop_with_reflect.arb"
   # arb finite volume solver
   # Copyright 2009,2010 Dalton Harvie (daltonh@unimelb.edu.au)
   #
   # arb is released under the GNU GPL.  For full details see the license directory.
   #
   #-------------------------------------------------------------------
   # file equations.in
   VERSION 0.55 # although this file has been updated to work with v0.55, the level-set templates need updating
   
   INFO_TITLE "Osciallating droplet on a half-plane calculated using level-set"
   INFO_DESCRIPTION "Uniform properties (rho and mu)"
   INFO_DESCRIPTION+ ": setup for cylindrical (default) or cartesian"
   
   #-------------------------------------------------------------------
   # user-defined constants
   
   #KERNEL_OPTIONS polynomialorder=2
   
   # setup basic cylindrical general replacements
      #(comment created during unwrap): new block = ../../templates/general/cylindrical_reflect_r1z2.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE_TEMPLATE "general/cylindrical_reflect_r1z2"
      # sets general replacements for cylindrical 2D coordinates with the 2-axis being the centreline (z) and 1-axis being radius (r)
      # comment out any references to the third dimension in any included files
      # centreline is normal to the 1 axis
      
      # activate cylindrical specific definitions
      # try not to use these in the future
      
      
      
   # or, setup basic cartesian reflect general replacements
   #INCLUDE_TEMPLATE "general/cartesian_x1y2"
   #GENERAL_REPLACEMENTS REPLACE "<<reflect=1>>" WITH "reflect=1" # as the centreline is horizontal need to include reflect=2 when differentiating l=2 vector components
   
   # bring in default physical and numerical constants
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "navier_stokes"
      #(comment created during unwrap): new block = ../../templates/navier_stokes/nondimensional_constants.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "nondimensional_constants"
      # use this constants file if solving nondimensionally
      
         #(comment created during unwrap): new block = ../../templates/navier_stokes/constants.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "constants"
         # physical data
         CONSTANT <mu> [Pa.s] 1.d-3 # viscosity of liquid
         CONSTANT <rho> [kg/m^3] 1.d0 # density
         CONSTANT <u_av> [m/s] 1.d0 # required average inlet velocity (if used, sets flowrate through inlet)
         
         #-------------
         # set default strings using the following template file, which sets up a steady-state solution to the navier-stokes equations, with uniform viscosity and density
         # see below for appropriate statements to change these decisions
         # these strings are used throughout the navier_stokes template files
         # strings can also be set when calling the template files using per-file replacements, although this isn't the standard way of implementing these settings
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, which requires three things to be set for each option.  The comment type variables will eventually be phased out, but are still required for many of the template files.
            #(hash inserted during unwrap)END_MARKDOWN
            
            # the following strings require a flag variable and two comment variables to be set
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
         
         # use the following to setup a transient simulation
         #GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "" R "<<steadystatenavierstokescomment>>" W "#" R "<<transientnavierstokes>>" W "1"
         
         # could set the transient status based on what type of arb simulation it is, but inadvisable really as there are many instances when only a partial-transient simulation is desired
         #<<transientcomment>>GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "" R "<<steadystatenavierstokescomment>>" W "#" R "<<transientnavierstokes>>" W "1"
         #<<steadystatecomment>>GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "#" R "<<steadystatenavierstokescomment>>" W "" R "<<transientnavierstokes>>" W "0"
         
         # use the following to specify the stokes equations
         #GENERAL_REPLACEMENTS R "<<stokescomment>>" W "" R "<<navierstokescomment>>" W "#" R "<<stokes>>" W "1"
         
         # use the following to specify nonuniform viscosity
         #GENERAL_REPLACEMENTS R "<<uniformviscositycomment>>" W "#" R "<<nonuniformviscositycomment>>" W "" R "<<uniformviscosity>>" W "0"
         
         # use the following to specify nonuniform density
         #GENERAL_REPLACEMENTS R "<<uniformdensitycomment>>" W "#" R "<<nonuniformdensitycomment>>" W "" R "<<uniformdensity>>" W "0"
         
         #-------------
         
         # numerical data
         CONSTANT <C_{Rhie-Chow}> [] 1.0d+0 # multiplier for Rhie-Chow-type velocity interpolation
         CONSTANT <adv_limiter> [] 1.d0 # multiplier used to limit gradients when calculating advection fluxes
         
         # find an estimate of the domain size using general template
         #(hash inserted during unwrap)INCLUDE_TEMPLATE "general"
            #(comment created during unwrap): new block = ../../templates/general/domain_lengthscale.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "domain_lengthscale" # this will find the none constant <a_lengthscale>
            # find an estimate of the domain size
            # here we use the maximum domain length in each dimension
            # previously used a more accurate but expensive formulation (see minimum_face_boundary_distance)
               #(comment created during unwrap): new block = ../../templates/general/domain_lengths.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "domain_lengths" # this will find a constant vector domain length in each dimension
               # based on node locations, here we calculate the maximum length of the domain in each dimension
               # these loops could be conducted over <boundarynodes>, but although cheaper, this will break if the domain has no boundaries (ie, fully periodic)
               # as this is only a single loop through each node this isn't an expensive calculation anyway (unlike the levelset-based minimum boundary distance)
               NONE_CONSTANT <nodexmax[l=1]> "nodemax(<nodex[l=1]>,region=<allnodes>)"
               NONE_CONSTANT <nodexmax[l=2]> "nodemax(<nodex[l=2]>,region=<allnodes>)"
               #NONE_CONSTANT <nodexmax[l=3]> "nodemax(<nodex[l=3]>,region=<allnodes>)"
               NONE_CONSTANT <nodexmin[l=1]> "nodemin(<nodex[l=1]>,region=<allnodes>)"
               NONE_CONSTANT <nodexmin[l=2]> "nodemin(<nodex[l=2]>,region=<allnodes>)"
               #NONE_CONSTANT <nodexmin[l=3]> "nodemin(<nodex[l=3]>,region=<allnodes>)"
               NONE_CONSTANT <domain_length[l=1]> "<nodexmax[l=1]>-<nodexmin[l=1]>"
               NONE_CONSTANT <domain_length[l=2]> "<nodexmax[l=2]>-<nodexmin[l=2]>"
               #NONE_CONSTANT <domain_length[l=3]> "<nodexmax[l=3]>-<nodexmin[l=3]>"
            # this is based on a vector from the minimum to the maximum coordinates
            #NONE_CONSTANT <a_lengthscale> "sqrt(nonemax(dot(<domain_length[l=:]>,<domain_length[l=:]>),0.d0))"
            # this is based on the maximum domain length over the three dimensions
            NONE_CONSTANT <a_lengthscale> "nonemax(<domain_length[l=1]>,nonemax(<domain_length[l=2]>,<domain_length[l=3]>))"
         
         # for reference calculate some nondimensional quantities
         # these should be overwritten by real nondimensional quantities if this is a nondimensional problem
         CONSTANT <Re> "<u_av>*<rho>*<a_lengthscale>/<mu>" # Reynolds number
      
      # set Reynolds number here to a value so that it isn't left as a function of <mu> from constants
      CONSTANT <Re> [1] 1.d-2 # Reynolds number, overwrite this after this file is included
      
      # convert dimensional parameters to nondimensional
      # by default an inertial scaling of pressure is used, however this can be changed by presetting this variable
         #(comment created during unwrap): new block = ../../templates/navier_stokes/nondimensional_constants.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1
         # the following produces a pressure which is inertially scalled (ie, p_nondim = p_dim/(density*velocity^2)
         CONSTANT <mu> "1.d0/<Re>"
         CONSTANT <rho> 1.d0
         #(comment created during unwrap): new block = ../../templates/navier_stokes/nondimensional_constants.arb: sub_block = 1
         #(hash inserted during unwrap)ELSE
         #(hash inserted during unwrap)# the following should produce a pressure which is viscous scalled (ie, p_nondim = p_dim*length/(viscosity*velocity))
         #(hash inserted during unwrap)CONSTANT <mu> 1.d0
         #(hash inserted during unwrap)CONSTANT <rho> "<Re>"
         #(hash inserted during unwrap)END_IF
      CONSTANT <u_av> 1.d0
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "free_surface/level_set"
      #(comment created during unwrap): new block = ../../templates/free_surface/level_set/nondimensional_constants.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "nondimensional_constants"
      # use this constants file if solving nondimensionally
      
         #(comment created during unwrap): new block = ../../templates/free_surface/level_set/constants.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "constants"
         # physical data
         CONSTANT <sigma> [N/m] 0.072d0 # surface tension coefficient
         
         # now define some nondimensional reference data
         CONSTANT <Ca> "<u_av>*<mu>/<sigma>"
         CONSTANT <We> "<Ca>*<Re>"
         CONSTANT <S> "1.d0/(<We>+<Ca>)"
      
      CONSTANT <S> 1.d+3 # surface tension strength nondimensional number, see harvie 2004
      
      # calc these from the above and <Re> (should be set explicitly from navier_stokes/nondimensional_constants)
      CONSTANT <We> "1.d0/(<S>*(1.d0+1.d0/<Re>))"
      CONSTANT <Ca> "<We>/<Re>"
      
      # convert dimensional parameters to nondimensional, using inertial scaling for pressure and surface tension
      CONSTANT <sigma> [1] "1.d0/<We>"
      CONSTANT <mu> "1.d0/<Re>"
      CONSTANT <rho> 1.d0
      CONSTANT <u_av> 1.d0
   
   # physical data, now for nondimensional uniform properties
   # set these
   CONSTANT <Re> 1.d+0
   CONSTANT <S> 1.d+3 # surface tension strength nondimensional number, see harvie 2004
   
   #CONSTANT <t_end> [] 1.d+2 # time for simulation to stop
   CONSTANT <t_end> [] 1.d0 # time for simulation to stop
   #CONSTANT <t_end> [] 1.d-2 # time for simulation to stop
   CONSTANT <celldxave> "cellsum(<celldxmax>,region=<domain>)/cellsum(1.d0,region=<domain>)" # average cell dimension
   CONSTANT <dt_initial> [] "1.d-3*<celldxave>" # initial timestep based on cell dimension, expecting a velocity of magnitude around 1
   CONSTANT <dt_out> [] "<t_end>/50.d0" # time between output
   # dynamic timestep constants
   CONSTANT <dt_increase> 1.2d0
   CONSTANT <dt_max> "<dt_initial>*1.d3"
   CONSTANT <dt_min> "<dt_initial>*1.d-3"
   CONSTANT <CFL_max> 0.25d0
   
   # for test simulation just do a few timesteps
   TIMESTEPOUT 2
   TIMESTEPMAX 4
   
   # in case of error kill simulation
   NEWTSTEPMAX 20
   
   # MSH_FILE instructs arb to read or write a gmsh file (location is read location - write location will always be within the output directory)
   # output options are: output,centringoutput,meshoutput,centringmeshoutput,nooutput
   # input options are: input,centringinput,meshinput,centringmeshinput,noinput
   # data output format options for CELL centred data (which overwrite individual variable options if specified): elementdata,elementnodedata,elementnodelimiteddata
   # vtk file output options are: vtkoutput,centringvtkoutput,meshvtkoutput,centringmeshvtkoutput,novtkoutput (novtkoutput is the default)
   # dat file output options are: dat_output,centringdat_output,meshdat_output,centringmeshdat_output,nodat_output (nodat_output is the default)
   MSH_FILE "surface.msh"
   
   #-------------------------------------------------------------------
   # geometry
   
   GLUE_FACES <fluid west> reflect=1
   GLUE_FACES <level set west> reflect=1
   GLUE_FACES <level set centre west> reflect=1
   
   # CELL_REGION/FACE_REGION specified by: <name> "location string" # comments
   # where location string could be: "AT x1 x2 x3" for a single point closest to these coordinates
   # where location string could be: "WITHIN BOX x1_min x2_min x3_min x1_max x2_max x3_max" for all elements within a box defined by the minimum and maximum coordinate values
   # where location string could be: "compound(+<a region>-<another region>" for a + and - compound region list
   # where location string could be: "boundaryof(<a region>" - boundary faces/cells contained within or surrounding <a region>
   # where location string could be: "domainof(<a region>" - domain faces/cells contained within <a region>
   # where location string could be: "associatedwith(<a region>" - faces/cells both contained within and surrounding <a region>
   # where location string could be: "SURROUNDS <a region>" - faces/cells that surround <a region>, irrespective of whether they are boundary or domain elements - right now only works when <a region> is cell centred
   
   # regions specific to level set mesh
   CELL_REGION <level set domain> "compound(<level set centre>+<level set edge>)"
   CELL_REGION <level set all cells> "associatedwith(<level set domain>)"
   FACE_REGION <level set all faces> "associatedwith(<level set domain>)"
   FACE_REGION <level set boundaries> "boundaryof(<level set domain>)"
   FACE_REGION <level set centre domain faces> "domainof(<level set centre>)"
   FACE_REGION <level set centre all faces> "associatedwith(<level set centre>)"
   FACE_REGION <level set walls> "compound(<level set top>+<level set bottom>+<level set east>)"
   FACE_REGION <level set centre boundaries> "surrounds(<level set centre>)"
   
   # regions specific to fluid mesh
   CELL_REGION <fluid all cells> "associatedwith(<fluid domain>)"
   FACE_REGION <fluid boundaries> "boundaryof(<fluid domain>)"
   CELL_REGION <fluid boundary cells> "boundaryof(<fluid domain>)"
   FACE_REGION <fluid all faces> "associatedwith(<fluid domain>)"
   FACE_REGION <fluid domain faces> "domainof(<fluid domain>)"
   FACE_REGION <fluid walls> "compound(<fluid top>+<fluid bottom>+<fluid east>)"
   FACE_REGION <one face> "at(1.d+4,1.d+4,0.d0)" ON <fluid walls>
   FACE_REGION <walls sans one face> "compound(<fluid walls>-<one face>)"
   
   #-------------------------------------------------------------------
   
   # transient bits
   TRANSIENT_SIMULATION
   # v0.59 update to set <<transientnavierstokes>> string as well, but this whole timestepping routine should be replaced by template files
   
   
   # dynamic timestep, next 2 lines
   NONE_TRANSIENT <CFL[r=1]> "<CFL>" "<CFL>" stepoutput # at this stage this will be the CFL from the last timestep, as it will be evaluated before any r=0 updates
   NONE_TRANSIENT <dt[r=0]> "<dt_initial>" "nonemax(nonemin(nonemin(<dt_increase>,<CFL_max>/nonemax(<CFL[r=1]>,<tiny>))*<dt[r=1]>,<dt_max>),<dt_min>)" stepoutput
   # constant timestep, next 1 line
   #NONE_CONSTANT <dt> "<dt_initial>"
   
   NONE_TRANSIENT <dt[r=1]> "<dt>" "<dt>" stepoutput
   NONE_TRANSIENT <t[r=0]> "0.d0" "<t[r=1]>+<dt[r=0]>" # time
   NONE_TRANSIENT <t[r=1]> "<t>-<dt[r=0]>" "<t>" # time at last step
   NONE_CONDITION <output test> "<t>-<t_out>-<dt_out>+<dt>*1.d-10" outputcondition # this will be true (>0.) whenever we are <dt_out> from last output
   NONE_OUTPUT <t_out> "<t>" stepoutputnoupdate # this will record the time of the last output
   NONE_CONDITION <stop test> "<t>-<t_end>" stopcondition # when this becomes true (>0.) the simulation stops
   
   # unknown variables used for flow problems
   CELL_UNKNOWN <p> [] "(2.d0^1)*<ls_phi_fluid>/<We>" ON <fluid all cells> elementdata # pressure
   CELL_UNKNOWN <u[l=1]> [] "0.d0" ON <fluid all cells> magnitude=1.d0 # velocity component
   CELL_UNKNOWN <u[l=2]> [] "0.d0" ON <fluid all cells> magnitude=1.d0 # velocity component
   
   CELL_TRANSIENT <u[l=1,r=1]> "0.d0" "<u[l=1]>" ON <fluid all cells>
   CELL_TRANSIENT <u[l=2,r=1]> "0.d0" "<u[l=2]>" ON <fluid all cells>
   
   FACE_TRANSIENT <u_f[r=1]> "0.d0" "<u_f>" ON <fluid all faces>
   #FACE_TRANSIENT <u_f[r=1]> "0.d0" "0.d0" ON <fluid all faces>
   
   # CSF based levelset formulation with reinitialisation
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "free_surface/level_set"
      #(comment created during unwrap): new block = ../../templates/free_surface/level_set/setup.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "setup" 
      
      # first set up some constants relating to the discretisation
      # all of these constants are in terms of `non-dimensional' ls values:  that is, the actual ls value divided by the <ls_celldxmax>.  For now <ls_celldxmax> is set to the maximum cell dimension (<celldxmax> = maximum node to node distance for each cell) within the domain.  For meshes with greatly varying cell sizes <ls_celldxmax> should vary with location.
      
      # need to specify first order kernels as the level-set method doesn't currently work consistently with higher order kernels
      # Note that as of v0.50 2nd order kernels are the default, hence this statement is now essential
      KERNEL_OPTIONS polynomialorder=1,polynomialaverageorder=1
      
      # the number of cells over which <ls_phi> will vary from 0 to 1 will be approximately twice this.  Smaller values give a tighter interface region, containing correspondingly larger surface tension forces
      CONSTANT <ls_phi_max> 1.0d0
      
      # these define the size of the weight region where the reinitialisation does not occur.  For <ls> < <ls_weight_min> no reinitialisation will occur, while for <ls> > <ls_weight_max> the <ls> function will be completely determined by the reinitialisation function.  Reinitialisation tends to decrease mass conservation, so making either of these numbers higher (especially <ls_weight_min>) will increase mass conservation.  Conversely, if reinitialisation is suppressed, the <ls> field may become inaccurate due to interface shearing and stretching, which could lead to surface tension calculation errors
      # if <ls_weight_min> is too small the reinitialisation mechanism may cause the interface to stick to particular (long) cells
      CONSTANT <ls_weight_min> 0.5d0
      CONSTANT <ls_weight_max> 1.5d0
      
      # when advecting the <ls> function, order of discretisation used (0 or 1)
      #CONSTANT <ls_advection_limiter> 1.0d0
      # now we look at the quality of the local kernels and base ls_advection_limiter on that - particularly important for poor quality meshes
      # the ideas come from the advection limiter templates
      # ideally these should sum to 0.5, but we should be able to go over a bit without convergence problems and so economise on mesh cells
      #NONE_CONSTANT <ls_limiter_crosskernel_max> 0.45d0 # the maximum multiplier for any cell value that is not the central cell
      NONE_CONSTANT <ls_limiter_crosskernel_max> 0.5d0 # the maximum multiplier for any cell value that is not the central cell
      NONE_CONSTANT <ls_limiter_centralkernel_max> 0.05d0 # the maximum multiplier for the central cell value
      CELL_LOCAL <ls_limiter_crosskernel> "cellif(<crosskernel>-<ls_limiter_crosskernel_max>,<ls_limiter_crosskernel_max>/<crosskernel>,1.d0)"
      CELL_LOCAL <ls_limiter_centralkernel> "cellif(<centralkernel>-<ls_limiter_centralkernel_max>,<ls_limiter_centralkernel_max>/<centralkernel>,1.d0)"
      CELL_CONSTANT <ls_advection_limiter> "cellmin(<ls_limiter_crosskernel>,<ls_limiter_centralkernel>)" ON <level set all cells> output,elementdata
      
      # this is the maximum <ls> value which is expected to affect the interface behaviour (ie, affect the calculation of the surface force).
      CONSTANT <ls_maximum_kernel_separation> 2.3d0 # take this from what is reported about the kernels (or used in kernel_module.f90), to work out an estimate for <ls_validity_max>
      
      CONSTANT <ls_extra_validity_spacing> 0.d0 # expand or contract <ls_validity_max> by cell size multiples
      CONSTANT <ls_validity_max> "3.d0+<ls_phi_max>+2*<ls_maximum_kernel_separation>+<ls_extra_validity_spacing>" # first 1 cell accounts for the difference between the explicit and implicit values of <ls>, <ls_phi_max> takes us to the edge of the constant <phi> region where <ls_kappa_c> is required, plus 1 cell to get to <ls_kappa_f>, plus 1 separation (averaging) to get to <ls_kappa_c2>, plus 1 cell to get to <ls_n_f>, plus 1 separation (derivative) to get to <ls>
      CONSTANT <ls_validity_max_extra> "<ls_validity_max>+<ls_maximum_kernel_separation>" # this is one kernel separation beyond where values for <ls> could conceivable be used
      
      # this is the level set function, defined on all cells
      CELL_UNKNOWN <ls> [] "<ls_initial>" ON <level set all cells> magnitude=1.d0,elementnodedata
      CELL_TRANSIENT <ls[r=1]> "<ls>" "<ls>" ON <level set all cells> nooutput,elementnodedata
      
      #CELL_CONSTANT <ls_celldxmax> "cellmax(<celldxmax>,region=<adjacentcellicells>)" elementdata # this is a possible basis for making this locally varying
      CONSTANT <ls_celldxmax> "cellmax(<celldxmax>,region=<level set domain>)" elementdata # otherwise for roughly uniformly-sized meshes this will do
      
      # define a background ls function upon which other initial conditions can be built
      # this function is the ls from each of the walls, plus the default wall ls value
      # the region <walls> specifically excludes centrelines, inlet/outlet ports, and wetted areas
      CONSTANT <ls_walls> "-<ls_validity_max_extra>*<ls_celldxmax>" # <ls> is set to this on the walls
      FACE_LOCAL <ls_boundary_vector[l=1]> "<facex[l=1]>-faceave[lastcell](<cellx[l=1]>)"
      FACE_LOCAL <ls_boundary_vector[l=2]> "<facex[l=2]>-faceave[lastcell](<cellx[l=2]>)"
      #FACE_LOCAL <ls_boundary_vector[l=3]> "<facex[l=3]>-faceave[lastcell](<cellx[l=3]>)"
      CELL_LOCAL <ls_minimum_boundary_distance> "sqrt(facemin(dot(<ls_boundary_vector[l=:]>,<ls_boundary_vector[l=:]>),region=<level set walls>))"
      CELL_LOCAL <ls_background> "<ls_walls>-<ls_minimum_boundary_distance>"
      CELL_LOCAL <ls_initial> "<ls_background>" # default initial condition for ls is the background function - real ls function should be defined in main problem file as the maximum of this and any real fluid <ls> functions (assuming <ls> > 0 for the disperse phase)
      
      # for reference a phi can be calculated from ls using a sinusoidal heaviside function
      CELL_LOCAL <ls_normalised> "<ls>/<ls_celldxmax>"
      CELL_DERIVED <ls_phi> "cellif(abs(<ls_normalised>)-<ls_phi_max>,cellif(<ls>,1.d0,0.d0),(sin(<ls_normalised>*<pi>/(2.d0*<ls_phi_max>))+1.d0)/2.d0)" ON <level set all cells> output
   
   CELL_LOCAL <ls_phi_fluid> "cellif(celldelta(<fluid domain>),celltocelllink(expression=<ls_phi>,localregion=<fluid domain>,remoteregion=<level set centre>),0.d0)+cellif(celldelta(<fluid boundary cells>),celltofacelink(expression=<ls_phi>,localregion=<fluid boundary cells>,remoteregion=<level set centre boundaries>),0.d0)" ON <fluid all cells> output,elementdata
   
   # define real initial ls conditions
   # circle (cylinder/sphere)
   #CONSTANT <radius1> 1.0d0
   #CELL_LOCAL <ls_initial1> "<radius1> - sqrt((<cellx[l=1]>)^2+(<cellx[l=2]>)^2)" # drop 1 centred at (0,0)
   #CELL_LOCAL <ls_initial1> "<radius1> - sqrt((<cellx[l=1]>+2.d0)^2+(<cellx[l=2]>)^2)" # drop 1 centred at (-2,0)
   # ellipse
   CONSTANT <radius_a> 0.7d0
   CONSTANT <radius_b> 1.4d0
   CELL_LOCAL <ls_initial1> "1.d0 - sqrt((<cellx[l=1]>/<radius_a>)^2+(<cellx[l=2]>/<radius_b>)^2)"
   # compounds
   CELL_LOCAL <ls_initial> "<ls_initial1>" ON <level set all cells> output
   
      #(comment created during unwrap): new block = ../../templates/free_surface/level_set/curvature.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "curvature" 
      
      # within this file we calculate the curvature
      
      # many difference curvature calculation methods have been tried - Method 8 gives the best results
      
      # Method 1 - celldiv around cell centres, averaged to faces
      #<<dim1comment>>FACE_LOCAL <ls_n_f[l=1]> "facegrad[l=1](<ls>)" output
      #<<dim2comment>>FACE_LOCAL <ls_n_f[l=2]> "facegrad[l=2](<ls>)"
      #<<dim3comment>>FACE_LOCAL <ls_n_f[l=3]> "facegrad[l=3](<ls>)"
      #FACE_DERIVED <ls_n_f mag> "sqrt(dot(<ls_n_f[l=:]>,<ls_n_f[l=:]>))" output,elementdata
      #CELL_DERIVED <ls_kappa_c> "-celldiv(facegrad(<ls>)/<ls_n_f mag>)" ON <allcells> output,elementdata
      #FACE_DERIVED <ls_kappa_f> "<ls_kappa_c>" output
      
      # Method 2 - face centred calculation, averaged to cell centres
      #<<dim1comment>>CELL_DERIVED <ls_n_c[l=1]> "cellgrad[l=1](<ls>)" ON <allcells>
      #<<dim2comment>>CELL_DERIVED <ls_n_c[l=2]> "cellgrad[l=2](<ls>)" ON <allcells>
      #<<dim3comment>>CELL_DERIVED <ls_n_c[l=3]> "cellgrad[l=3](<ls>)" ON <allcells>
      #CELL_DERIVED <ls_n_c mag> "sqrt(dot(<ls_n_c[l=:]>,<ls_n_c[l=:]>))" ON <allcells>
      #<<dim1comment>>CELL_LOCAL <ls_n_c_unit[l=1]> "<ls_n_c[l=1]>/<ls_n_c mag>" ON <allcells> output
      #<<dim2comment>>CELL_LOCAL <ls_n_c_unit[l=2]> "<ls_n_c[l=2]>/<ls_n_c mag>" ON <allcells>
      #<<dim3comment>>CELL_LOCAL <ls_n_c_unit[l=3]> "<ls_n_c[l=3]>/<ls_n_c mag>" ON <allcells>
      #FACE_DERIVED <ls_kappa_f> "-(facegrad[l=1](<ls_n_c_unit[l=1]>)+facegrad[l=2](<ls_n_c_unit[l=2]>)+facegrad[l=3](<ls_n_c_unit[l=3]>))" ON <allfaces> output
      #CELL_DERIVED <ls_kappa_c> "<ls_kappa_f>" output
      
      # Method 3 - cell centred calculation, using cellgrad instead of celldiv, then averaged to faces
      #<<dim1comment>>CELL_DERIVED <ls_n_c[l=1]> "cellgrad[l=1](<ls>)" ON <allcells>
      #<<dim2comment>>CELL_DERIVED <ls_n_c[l=2]> "cellgrad[l=2](<ls>)" ON <allcells>
      #<<dim3comment>>CELL_DERIVED <ls_n_c[l=3]> "cellgrad[l=3](<ls>)" ON <allcells>
      #CELL_DERIVED <ls_n_c mag> "sqrt(dot(<ls_n_c[l=:]>,<ls_n_c[l=:]>))" ON <allcells>
      #<<dim1comment>>CELL_LOCAL <ls_n_c_unit[l=1]> "<ls_n_c[l=1]>/<ls_n_c mag>" ON <allcells> output
      #<<dim2comment>>CELL_LOCAL <ls_n_c_unit[l=2]> "<ls_n_c[l=2]>/<ls_n_c mag>" ON <allcells>
      #<<dim3comment>>CELL_LOCAL <ls_n_c_unit[l=3]> "<ls_n_c[l=3]>/<ls_n_c mag>" ON <allcells>
      #CELL_DERIVED <ls_kappa_c> "-(cellgrad[l=1](<ls_n_c_unit[l=1]>)+cellgrad[l=2](<ls_n_c_unit[l=2]>)+cellgrad[l=3](<ls_n_c_unit[l=3]>))" ON <allcells> output
      #FACE_DERIVED <ls_kappa_f> "<ls_kappa_c>" output
      
      # Method 4 - as per method 2, but with more smoothing
      #<<dim1comment>>CELL_DERIVED <ls_n_c[l=1]> "cellgrad[l=1](<ls>)" ON <allcells>
      #<<dim2comment>>CELL_DERIVED <ls_n_c[l=2]> "cellgrad[l=2](<ls>)" ON <allcells>
      #<<dim3comment>>CELL_DERIVED <ls_n_c[l=3]> "cellgrad[l=3](<ls>)" ON <allcells>
      #CELL_DERIVED <ls_n_c mag> "sqrt(dot(<ls_n_c[l=:]>,<ls_n_c[l=:]>))" ON <allcells>
      #<<dim1comment>>CELL_LOCAL <ls_n_c_unit[l=1]> "<ls_n_c[l=1]>/<ls_n_c mag>" ON <allcells> output
      #<<dim2comment>>CELL_LOCAL <ls_n_c_unit[l=2]> "<ls_n_c[l=2]>/<ls_n_c mag>" ON <allcells>
      #<<dim3comment>>CELL_LOCAL <ls_n_c_unit[l=3]> "<ls_n_c[l=3]>/<ls_n_c mag>" ON <allcells>
      #FACE_DERIVED <ls_kappa_f2> "-(facegrad[l=1](<ls_n_c_unit[l=1]>)+facegrad[l=2](<ls_n_c_unit[l=2]>)+facegrad[l=3](<ls_n_c_unit[l=3]>))" ON <allfaces> output
      #CELL_DERIVED <ls_kappa_c> "<ls_kappa_f2>" output
      #FACE_DERIVED <ls_kappa_f> "<ls_kappa_c>" output
      
      # Method 5 - face and cell calculated separately from same cell centred unit normals
      #<<dim1comment>>CELL_DERIVED <ls_n_c[l=1]> "cellgrad[l=1](<ls>)" ON <allcells>
      #<<dim2comment>>CELL_DERIVED <ls_n_c[l=2]> "cellgrad[l=2](<ls>)" ON <allcells>
      #<<dim3comment>>CELL_DERIVED <ls_n_c[l=3]> "cellgrad[l=3](<ls>)" ON <allcells>
      #CELL_DERIVED <ls_n_c mag> "sqrt(dot(<ls_n_c[l=:]>,<ls_n_c[l=:]>))" ON <allcells>
      #<<dim1comment>>CELL_LOCAL <ls_n_c_unit[l=1]> "<ls_n_c[l=1]>/<ls_n_c mag>" ON <allcells> output
      #<<dim2comment>>CELL_LOCAL <ls_n_c_unit[l=2]> "<ls_n_c[l=2]>/<ls_n_c mag>" ON <allcells>
      #<<dim3comment>>CELL_LOCAL <ls_n_c_unit[l=3]> "<ls_n_c[l=3]>/<ls_n_c mag>" ON <allcells>
      #FACE_DERIVED <ls_kappa_f> "-(facegrad[l=1](<ls_n_c_unit[l=1]>)+facegrad[l=2](<ls_n_c_unit[l=2]>)+facegrad[l=3](<ls_n_c_unit[l=3]>))" ON <allfaces> output
      #CELL_DERIVED <ls_kappa_c> "-(cellgrad[l=1](<ls_n_c_unit[l=1]>)+cellgrad[l=2](<ls_n_c_unit[l=2]>)+cellgrad[l=3](<ls_n_c_unit[l=3]>))" ON <allcells> output
      
      # Method 6 - as per method 1 but not normalising unit vectors
      #CELL_DERIVED <ls_kappa_c> "-celldiv(facegrad(<ls>))" ON <allcells> output,elementdata
      #FACE_DERIVED <ls_kappa_f> "<ls_kappa_c>" output
      
      # Method 7 - as per method 6 but more smoothing
      #CELL_DERIVED <ls_kappa_c2> "-celldiv(facegrad(<ls>))" ON <allcells> output,elementdata
      #FACE_DERIVED <ls_kappa_f> "<ls_kappa_c2>" output
      #CELL_DERIVED <ls_kappa_c> "<ls_kappa_f>" output,elementdata
      
      # Method 8 - as per method 1 but more smoothing
      FACE_LOCAL <ls_n_f[l=1]> "facegrad[l=1](<ls>)"
      FACE_LOCAL <ls_n_f[l=2]> "facegrad[l=2](<ls>)"
      #FACE_LOCAL <ls_n_f[l=3]> "facegrad[l=3](<ls>)"
      FACE_LOCAL <ls_n_f mag> "sqrt(dot(<ls_n_f[l=:]>,<ls_n_f[l=:]>))" elementdata
      FACE_DERIVED <ls_n_f_scalar> "facegrad(<ls>)/<ls_n_f mag>" ON <level set all faces> nooutput
      CELL_DERIVED <ls_kappa_c2> "-celldiv(<facex[l=1]>*<ls_n_f_scalar>/faceave[lastcell](<cellx[l=1]>))" ON <level set all cells> nooutput,elementdata
      #CELL_DERIVED <ls_kappa_c2> "-celldiv(<ls_n_f_scalar>)" ON <level set all cells> nooutput,elementdata
      FACE_DERIVED <ls_kappa_f> "<ls_kappa_c2>" ON <level set all faces>
      CELL_DERIVED <ls_kappa_c> "<ls_kappa_f>" ON <level set all cells> output,elementdata
      #CELL_DERIVED <ls_kappa_c> "<ls_kappa_c2>" ON <allcells> output,elementdata
      
      # Method 9 - face and cell calculated separately, cell from celldiv, face from cell centred normals
      #<<dim1comment>>CELL_DERIVED <ls_n_c[l=1]> "cellgrad[l=1](<ls>)" ON <allcells>
      #<<dim2comment>>CELL_DERIVED <ls_n_c[l=2]> "cellgrad[l=2](<ls>)" ON <allcells>
      #<<dim3comment>>CELL_DERIVED <ls_n_c[l=3]> "cellgrad[l=3](<ls>)" ON <allcells>
      #CELL_DERIVED <ls_n_c mag> "sqrt(dot(<ls_n_c[l=:]>,<ls_n_c[l=:]>))" ON <allcells>
      #<<dim1comment>>CELL_LOCAL <ls_n_c_unit[l=1]> "<ls_n_c[l=1]>/<ls_n_c mag>" ON <allcells> output
      #<<dim2comment>>CELL_LOCAL <ls_n_c_unit[l=2]> "<ls_n_c[l=2]>/<ls_n_c mag>" ON <allcells>
      #<<dim3comment>>CELL_LOCAL <ls_n_c_unit[l=3]> "<ls_n_c[l=3]>/<ls_n_c mag>" ON <allcells>
      #FACE_DERIVED <ls_kappa_f> "-(facegrad[l=1](<ls_n_c_unit[l=1]>)+facegrad[l=2](<ls_n_c_unit[l=2]>)+facegrad[l=3](<ls_n_c_unit[l=3]>))" ON <allfaces> output
      #CELL_DERIVED <ls_kappa_c> "-celldiv(facegrad(<ls>))" ON <allcells> output,elementdata
      
      # Method 10 - as per method 2, but cell centred unit normals calculated from celldivgrads
      #<<dim1comment>>CELL_DERIVED <ls_n_c[l=1]> "celldivgrad[l=1](<ls>)" ON <allcells>
      #<<dim2comment>>CELL_DERIVED <ls_n_c[l=2]> "celldivgrad[l=2](<ls>)" ON <allcells>
      #<<dim3comment>>CELL_DERIVED <ls_n_c[l=3]> "celldivgrad[l=3](<ls>)" ON <allcells>
      #CELL_DERIVED <ls_n_c mag> "sqrt(dot(<ls_n_c[l=:]>,<ls_n_c[l=:]>))" ON <allcells>
      #<<dim1comment>>CELL_LOCAL <ls_n_c_unit[l=1]> "<ls_n_c[l=1]>/<ls_n_c mag>" ON <allcells> output
      #<<dim2comment>>CELL_LOCAL <ls_n_c_unit[l=2]> "<ls_n_c[l=2]>/<ls_n_c mag>" ON <allcells>
      #<<dim3comment>>CELL_LOCAL <ls_n_c_unit[l=3]> "<ls_n_c[l=3]>/<ls_n_c mag>" ON <allcells>
      #FACE_DERIVED <ls_kappa_f> "-(facegrad[l=1](<ls_n_c_unit[l=1]>)+facegrad[l=2](<ls_n_c_unit[l=2]>)+facegrad[l=3](<ls_n_c_unit[l=3]>))" ON <allfaces> output
      #CELL_DERIVED <ls_kappa_c> "<ls_kappa_f>" output
      
      # Method 11 - face and cell calculated separately from same cell centred unit normals, now calculated with celldivgrad
      #<<dim1comment>>CELL_DERIVED <ls_n_c[l=1]> "celldivgrad[l=1](<ls>)" ON <allcells>
      #<<dim2comment>>CELL_DERIVED <ls_n_c[l=2]> "celldivgrad[l=2](<ls>)" ON <allcells>
      #<<dim3comment>>CELL_DERIVED <ls_n_c[l=3]> "celldivgrad[l=3](<ls>)" ON <allcells>
      #CELL_DERIVED <ls_n_c mag> "sqrt(dot(<ls_n_c[l=:]>,<ls_n_c[l=:]>))" ON <allcells>
      #<<dim1comment>>CELL_LOCAL <ls_n_c_unit[l=1]> "<ls_n_c[l=1]>/<ls_n_c mag>" ON <allcells> output
      #<<dim2comment>>CELL_LOCAL <ls_n_c_unit[l=2]> "<ls_n_c[l=2]>/<ls_n_c mag>" ON <allcells>
      #<<dim3comment>>CELL_LOCAL <ls_n_c_unit[l=3]> "<ls_n_c[l=3]>/<ls_n_c mag>" ON <allcells>
      #FACE_DERIVED <ls_kappa_f> "-(facegrad[l=1](<ls_n_c_unit[l=1]>)+facegrad[l=2](<ls_n_c_unit[l=2]>)+facegrad[l=3](<ls_n_c_unit[l=3]>))" ON <allfaces> output
      #CELL_DERIVED <ls_kappa_c> "-(cellgrad[l=1](<ls_n_c_unit[l=1]>)+cellgrad[l=2](<ls_n_c_unit[l=2]>)+cellgrad[l=3](<ls_n_c_unit[l=3]>))" ON <allcells> output
      
      # Method 12 - as per method 3, but cell centred normals calculated using celldivgrad
      #<<dim1comment>>CELL_DERIVED <ls_n_c[l=1]> "celldivgrad[l=1](<ls>)" ON <allcells>
      #<<dim2comment>>CELL_DERIVED <ls_n_c[l=2]> "celldivgrad[l=2](<ls>)" ON <allcells>
      #<<dim3comment>>CELL_DERIVED <ls_n_c[l=3]> "celldivgrad[l=3](<ls>)" ON <allcells>
      #CELL_DERIVED <ls_n_c mag> "sqrt(dot(<ls_n_c[l=:]>,<ls_n_c[l=:]>))" ON <allcells>
      #<<dim1comment>>CELL_LOCAL <ls_n_c_unit[l=1]> "<ls_n_c[l=1]>/<ls_n_c mag>" ON <allcells> output
      #<<dim2comment>>CELL_LOCAL <ls_n_c_unit[l=2]> "<ls_n_c[l=2]>/<ls_n_c mag>" ON <allcells>
      #<<dim3comment>>CELL_LOCAL <ls_n_c_unit[l=3]> "<ls_n_c[l=3]>/<ls_n_c mag>" ON <allcells>
      #CELL_DERIVED <ls_kappa_c> "-(cellgrad[l=1](<ls_n_c_unit[l=1]>)+cellgrad[l=2](<ls_n_c_unit[l=2]>)+cellgrad[l=3](<ls_n_c_unit[l=3]>))" ON <allcells> output
      #FACE_DERIVED <ls_kappa_f> "<ls_kappa_c>" output
      
      # # Method 13 - as per method 8 but <ls_kappa_f> is calculated from <ls_kappa_c>, rather than the other way around (ie, more smoothing on this)
      # <<dim1comment>>FACE_LOCAL <ls_n_f[l=1]> "facegrad[l=1](<ls>)"
      # <<dim2comment>>FACE_LOCAL <ls_n_f[l=2]> "facegrad[l=2](<ls>)"
      # <<dim3comment>>FACE_LOCAL <ls_n_f[l=3]> "facegrad[l=3](<ls>)"
      # FACE_LOCAL <ls_n_f mag> "sqrt(dot(<ls_n_f[l=:]>,<ls_n_f[l=:]>))" elementdata
      # FACE_DERIVED <ls_n_f_scalar> "facegrad(<ls>)/<ls_n_f mag>" ON <allfaces> nooutput
      # #CELL_DERIVED <ls_kappa_c2> "-celldiv(facegrad(<ls>)/<ls_n_f mag>)" ON <allcells> output,elementdata
      # <<cylindricalcomment>>CELL_DERIVED <ls_kappa_c2> "-celldiv(<<radius_f>>*<ls_n_f_scalar>/faceave[lastcell](<<radius_c>>))" ON <allcells> nooutput,elementdata
      # <<cartesiancomment>>CELL_DERIVED <ls_kappa_c2> "-celldiv(<ls_n_f_scalar>)" ON <allcells> nooutput,elementdata
      # FACE_LOCAL <ls_kappa_f2> "<ls_kappa_c2>"
      # CELL_DERIVED <ls_kappa_c> "<ls_kappa_f2>" ON <allcells> output,elementdata
      # FACE_DERIVED <ls_kappa_f> "<ls_kappa_c>" ON <allfaces>
      
   #INCLUDE "curvature_corrected" R "<allcells>" W "<level set all cells>" R "<allfaces>" W "<level set all faces>"
      #(comment created during unwrap): new block = ../../templates/free_surface/level_set/force.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "force" 
      
      # within this file we calculate the cell centred surface force and face centred force used in the <u_f> interpolation
      
      CELL_LOCAL <ls_F_c[l=1]> "<ls_kappa_c>*celldivgrad[l=1](<ls_phi>)" ON <level set all cells>
      CELL_LOCAL <ls_F_c[l=2]> "<ls_kappa_c>*celldivgrad[l=2](<ls_phi>)" ON <level set all cells>
      #CELL_LOCAL <ls_F_c[l=3]> "<ls_kappa_c>*celldivgrad[l=3](<ls_phi>)" ON <level set all cells>
      
      # differencing type used here must match that in the p_error calc
      FACE_LOCAL <ls_F_f> "<ls_kappa_f>*facegrad[dxunit](<ls_phi>)" ON <level set centre all faces>
   
   # create surface tension force on all fluid cells, including fluid boundary cells which grab their values from adjacent domain cells (as per celldivgrad(p))
   CELL_LOCAL <ls_F_c_fluid_domain[l=1]> "celltocelllink(expression=<ls_F_c[l=1]>,localregion=<fluid domain>,remoteregion=<level set centre>)" ON <fluid domain>
   CELL_LOCAL <ls_F_c_fluid_domain[l=2]> "celltocelllink(expression=<ls_F_c[l=2]>,localregion=<fluid domain>,remoteregion=<level set centre>)" ON <fluid domain>
   #CELL_LOCAL <ls_F_c_fluid_domain[l=3]> "celltocelllink(expression=<ls_F_c[l=3]>,localregion=<fluid domain>,remoteregion=<level set centre>)" ON <fluid domain>
   CELL_LOCAL <ls_F_c_fluid[l=1]> "cellif(celldelta(<fluid domain>),<ls_F_c_fluid_domain[l=1]>,0.d0)+cellif(celldelta(<fluid boundary cells>),cellave[reflect=1](faceave[downcell,reflect=1](<ls_F_c_fluid_domain[l=1]>)),0.d0)" ON <fluid all cells> output
   CELL_LOCAL <ls_F_c_fluid[l=2]> "cellif(celldelta(<fluid domain>),<ls_F_c_fluid_domain[l=2]>,0.d0)+cellif(celldelta(<fluid boundary cells>),cellave[](faceave[downcell,](<ls_F_c_fluid_domain[l=2]>)),0.d0)" ON <fluid all cells>
   #CELL_LOCAL <ls_F_c_fluid[l=3]> "cellif(celldelta(<fluid domain>),<ls_F_c_fluid_domain[l=3]>,0.d0)+cellif(celldelta(<fluid boundary cells>),cellave[](faceave[downcell,](<ls_F_c_fluid_domain[l=3]>)),0.d0)" ON <fluid all cells>
   
   # calculate <u_f> using rhie-chow type interpolation, including a contribution from the surface tension force term
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "navier_stokes"
      #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "total_stress" 
      
      # total stress tensor
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_gradient_tensor.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "u_gradient_tensor"
         # a tensor of face centred gradients that respects any reflections
         # used in the total stress and boundary conditions now
         # as per conventional tensor notation, the first index is the derivative direction, and the second is the velocity direction
         # performing index string loops on the following index list pairs:
         #  <<i>> 1,2
         #  <<j>> 1,2
         FACE_DERIVED <ugrad_f[l=1,1]> "facegrad[l=1,reflect=1](<u[l=1]>)" ON <fluid all faces>
         FACE_DERIVED <ugrad_f[l=2,1]> "facegrad[l=2,reflect=1](<u[l=1]>)" ON <fluid all faces>
         FACE_DERIVED <ugrad_f[l=1,2]> "facegrad[l=1,](<u[l=2]>)" ON <fluid all faces>
         FACE_DERIVED <ugrad_f[l=2,2]> "facegrad[l=2,](<u[l=2]>)" ON <fluid all faces>
      
      # if the numerical velocity divergence is to be included in the stress calculation replace this string with an empty character prior to calling this template
      
      # calculate the velocity divergence (numerical) on each face
      #FACE_DERIVED <udiv_f> "<ugrad_f[l=1,1]>+<ugrad_f[l=2,2]>+<ugrad_f[l=3,3]>" ON <fluid all faces> # any component not in <<dimensions>> will be assigned to an empty vector and simplified out using maxima
      
      # deal with uniform/nonuniform viscosity, allowing for possibility of user setting <mu_f> directly
      # if you want to overwrite <mu_f>, just define it prior to calling this file and your replacement will overwrite the following
      # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
         #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1  # this evaluates as true (1) if replacement string '<mu_f>' isn't defined, AND <<uniformviscosity>> is on (1)
         # if we are here then we apply the uniform viscosity substitution, with 'S'='SUBSTITUTE' meaning to replace the value of this string in its previous (above code block here) definition
         #(hash inserted during unwrap)END_IF
      #{{ print "IN template total_stress\n".string_debug; }}
      
      # no both cartesian and cylindrical stresses don't include pressure
      # first define without the numerical velocity divergence
      # performing index string loops on the following index list pairs:
      #  <<i>> 1,2
      #  <<j>> 1,2
      FACE_LOCAL <tau[l=1,1]> "-<mu>*(<ugrad_f[l=1,1]>+<ugrad_f[l=1,1]>)" ON <fluid all faces> 
      FACE_LOCAL <tau[l=2,1]> "-<mu>*(<ugrad_f[l=2,1]>+<ugrad_f[l=1,2]>)" ON <fluid all faces> 
      FACE_LOCAL <tau[l=1,2]> "-<mu>*(<ugrad_f[l=1,2]>+<ugrad_f[l=2,1]>)" ON <fluid all faces> 
      FACE_LOCAL <tau[l=2,2]> "-<mu>*(<ugrad_f[l=2,2]>+<ugrad_f[l=2,2]>)" ON <fluid all faces> # note, maxima will simplify diagonal components
      # overwrite the diagonal elements if the numerical velocity divergence is to be included, see <<udivfcomment>> string replacement above
      # Note: "<udiv_f>/3.d0" is specifically replaced in strain_rate_magnitude template
      # performing index string loops on the following index list pairs:
      #  <<i>> 1,2
      #FACE_LOCAL <tau[l=1,1]> "-<mu>*2.d0*(<ugrad_f[l=1,1]>-<udiv_f>/3.d0)" ON <fluid all faces> 
      #FACE_LOCAL <tau[l=2,2]> "-<mu>*2.d0*(<ugrad_f[l=2,2]>-<udiv_f>/3.d0)" ON <fluid all faces> # note, previous symmetric components were less efficient
      
         #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 1
         #(hash inserted during unwrap)IF 0#<<azimuthal>>
            #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 2
            #(hash inserted during unwrap)IF 0
            #(hash inserted during unwrap)VARIABLE <tau[l=1,0]> "<tau[l=1,0]>+<mu>*<u_f_vect[l=0]>/<facex[l=1]>"
            #(hash inserted during unwrap)VARIABLE <tau[l=0,1]> "<tau[l=1,0]>"
            #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 2
            #(hash inserted during unwrap)ELSE
            #(hash inserted during unwrap)VARIABLE <tau[l=1,0]> "-<mu>*<facex[l=1]>*facegrad[l=1,reflect=1](<u[l=0]>/<cellx[l=1]>)" OUTPUT
            #(hash inserted during unwrap)VARIABLE <tau[l=0,1]> "<tau[l=1,0]>"  OUTPUT
            #(hash inserted during unwrap)END_IF
         #(hash inserted during unwrap)VARIABLE <tau[l=0,0]> "-<mu>*2.d0*<u_f_vect[l=1]>/<facex[l=1]>"
         #(hash inserted during unwrap)END_IF
      
      
      #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "u_f" 
      
      # interpolate the cell centred velocity to the faces and find the velocity (flux) normal to the face (<u_f>), using a rhie-chow spirited interpolation technique on the domain faces
      
      # check default strings are set
         #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "default_string_replacements"
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
         #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)Some of these use both comment and flag type variables, which requires three things to be set for each option.  The comment type variables will eventually be phased out, but are still required for many of the template files.
         #(hash inserted during unwrap)END_MARKDOWN
         
         # the following strings require a flag variable and two comment variables to be set
         
         
         # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
         
         
      
      # start by calculating the difference between the local face centred (dynamic) pressure gradient and average of cell centred (dynamic) pressure gradients in the face direction
      # `dynamic' pressure here means the pressure that is able to cause fluid flow, ie, possibly accounting for hydrostatic pressure variations (for example)
         #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "p_error"
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)A Rhie-Chow-type velocity interpolation is applied to the face flux velocities, and this requires the difference between the facecentred dynamic force (<dynamic_force_f>) and the averaged component of the cell centred dynamic force (<dynamic_force_c[l=:]>), <p_error>
         #(hash inserted during unwrap)END_MARKDOWN
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "dynamic_force" # calculate the cell centred dynamic force
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)dynamic force is the pressure force that could cause fluid movement
            #(hash inserted during unwrap)it is added directly to the momentum equations, and used in calculating p_error used in the face velocity interpolation
            #(hash inserted during unwrap)dynamic force now has the physically correct sign!
            #(hash inserted during unwrap)The pressure gradient is calculated via a divergence (consistent with momentum conservation) (on boundary cells values from the adjacent domain cells will be used)
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)<dynamic_force_f> is calculated at the same time as <p_error>, within p_error.arb, which this file is called from
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Other dynamic_force templates (eg, vof, electrokinetics) increment <dynamic_force_c[l=:]> set in this file, as well as <dynamic_force_f>
            #(hash inserted during unwrap)END_MARKDOWN
            
            #FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "p_f"
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)Here we average the cell centred pressure <p> to the faces producing <p_f>.  The standard method is to use arithmetic averaging, as in
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)```arb
               #(hash inserted during unwrap)FACE_DERIVED <p_f> "faceave(<p>)" ON <fluid all faces>
               #(hash inserted during unwrap)```
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)Low order averaging adjacentcell averaging uses a distance weighted average of the adjacent cell values.  Select this by setting
               #(hash inserted during unwrap)```arb
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)```
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)High order adjacentcell averaging is as per low order adjacentcell averaging, except that the gradient within each cell is used to get a better estimate of the pressure on each side of the interface.  The amount of gradient used is set by `<p_f_grad_limiter>` which should be between 0.d0 (low order) and 1.d0 after the file is included.  To use this high order averaging set
               #(hash inserted during unwrap)```arb
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter> 1.d0 # keep this between 0.d0 and 1.d0
               #(hash inserted during unwrap)```
               #(hash inserted during unwrap)END_MARKDOWN
               
               # this is the default pressure interpolation
               FACE_DERIVED <p_f> "faceave(<p>)" ON <fluid all faces>
               
               # the following are based on averaging from the adjacentcells only, but possibly using high order averaging
               
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 0
                  #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcells](<p>)" output
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 0
                  #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter> 1.d0 # ranging from 1.d0 (highest order) to 0.d0 which will give same as <<pfadjacentcells>> above
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                     #(hash inserted during unwrap)IF 1
                     #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcells](cellave[lastface](faceave[advection](<p>,<facefromcelldirection>,<p_f_gradient_limiter>)))" output
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                     #(hash inserted during unwrap)ELSE_IF 0
                     #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcellsevenweighting](cellave[lastface](faceave[advection](<p>,<facefromcelldirection>,<p_f_gradient_limiter>)))" output
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)VARIABLE <p_f> "0.5d0*(faceave[advection](<p>,1.d0,<p_f_gradient_limiter>)+faceave[advection](<p>,-1.d0,<p_f_gradient_limiter>))" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 3
                        #(hash inserted during unwrap)IF 1
                        #(hash inserted during unwrap)VARIABLE <p_f> "faceif(facedelta(<fluid boundaries>),<p>,<p_f>)" # special case boundary face pressure value to be equal to boundary cell value.  Without this the boundary pressure will be equally weighted.
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)END_IF
            # performing index string loops on the following index list pairs:
            #  <<i>> 1,2
            CELL_DERIVED <dynamic_force_c[l=1]> "-celldivgrad[l=1](<p_f>)" ON <fluid all cells>
            CELL_DERIVED <dynamic_force_c[l=2]> "-celldivgrad[l=2](<p_f>)" ON <fluid all cells>
         
         # seems that using <dynamic_force_c_f[l=:]> usually consumes more memory and takes more time to compute, so remove it by default by including the following
         # in the far off future if nobody complains <dynamic_force_c_f[l=:]> may just disappear into the night
         # to bring back <dynamic_force_c_f[l=:]> set this string to 1 to turn this back on
         
         
         # for evaluating the face centred dynamic force there are three options: dxunit, facegrad and facegradadjacentcells
         # right now the default is dxunit, which works well, but implies that u_f_{correction} is not aligned with facenorm (noting that only the component of the correction is applied)
         # facegrad works but is not as effective in damping checkerboarding
         # facegradadjacentcells also works but the implications re directions aren't as clear as the above two options
         
         #GENERAL_REPLACEMENTS D "<<dynamicforcefmethod>>" W "facegrad"
         #GENERAL_REPLACEMENTS D "<<dynamicforcefmethod>>" W "facegradadjacentcells"
         
         # calculate <dynamic_force_c_f[l=:]> if requested
         # interpolation to face centres (for velocity correction) could be done using normal, adjacentcells or adjacentcellsevenweighting, but they're all about the same so choose the computationally simplest
            #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 1
            #(hash inserted during unwrap)IF 0
            #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
            #(hash inserted during unwrap)#  <<i>> 1,2
            #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_c_f[l=1]> "faceave[reflect=1,adjacentcells](<dynamic_force_c[l=1]>)"
            #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_c_f[l=2]> "faceave[,adjacentcells](<dynamic_force_c[l=2]>)"
            #(hash inserted during unwrap)END_IF
         
         #{{ print "IN p_error.arb\n".string_debug(); }}
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1
            # dxunit method
            FACE_LOCAL <dynamic_force_f> "-facegrad[dxunit](<p>)" ON <fluid all faces> # now defined on <allfaces> to allow use as a BC
            FACE_CONSTANT <dot_facenorm_facedxunit> "dot(<facenorm[l=:]>,<facedxunit[l=:]>)" ON <fluid all faces> # now defined on <allfaces> to allow use as a BC
            # dxunit + dynamicforcecf
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)FACE_DERIVED <p_error> "(-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facedxunit[l=:]>))*<dot_facenorm_facedxunit>" ON <fluid domain faces>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 2
               #(hash inserted during unwrap)ELSE
               # dxunit - dynamicforcecf
               # lastface is required when averaging the normal when we have periodic gluing, as we require the normal to be orientated relative to the original face, rather than its glued counterpart - this is now the default when cycling through the region adjacentfaceicells, which is used by faceave[adjacentcells]
               # for reflect gluing, <p_error> is zero anyway
               #   FACE_DERIVED <p_error> "faceif(<facereflectnorm>,(-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <domainfaces>
               # need to fix code for adjacentdomaincells for this line to work
               #   FACE_DERIVED <p_error> "faceif(<facereflectnorm>,(-<dynamic_force_f>+faceave[adjacentdomaincells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <domainfaces>
               # workaround, explicit code
               FACE_DERIVED <p_error> "faceif(<facereflectnorm>,(-<dynamic_force_f>+faceif(facedelta(region=<fluid boundaries>),faceave[downcell](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))),faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>)))))*<dot_facenorm_facedxunit>,0.d0)" ON <fluid domain faces>
               #(hash inserted during unwrap)END_IF
            
            #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 1
            #(hash inserted during unwrap)ELSE_IF 
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)# facegrad method
            #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_f> "-facegrad(<p>)" ON <fluid all faces>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)# facegrad + dynamicforcecf
               #(hash inserted during unwrap)FACE_DERIVED <p_error> "-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facenorm[l=:]>)" ON <fluid domain faces>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 2
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)# facegrad - dynamicforcecf
               #(hash inserted during unwrap)FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <fluid domain faces>
               #(hash inserted during unwrap)END_IF
            #(hash inserted during unwrap)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 1
            #(hash inserted during unwrap)ELSE_IF 
            #(hash inserted during unwrap)# adjacentcells method
            #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_f> "-facegrad[adjacentcells](<p>)" ON <fluid all faces>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)# facegradadjacentcells + dynamicforcecf
               #(hash inserted during unwrap)FACE_DERIVED <p_error> "-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facenorm[l=:]>)" ON <fluid domain faces>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 2
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)# facegradadjacentcells - dynamicforcecf
               #(hash inserted during unwrap)#   FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
               #(hash inserted during unwrap)FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentdomaincells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <fluid domain faces>
               #(hash inserted during unwrap)END_IF
            #(hash inserted during unwrap)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 1
            #(hash inserted during unwrap)ELSE
            #(hash inserted during unwrap)ERROR 'No valid dynamicforcefmethod is chosen in the navier_stokes/p_error template file: string currently set as dxunit'
            #(hash inserted during unwrap)END_IF
      
      # performing index string loops on the following index list pairs:
      #  <<i>> 1,2
      FACE_LOCAL <u_f_vect[l=1]> "faceave[reflect=1](<u[l=1]>)"
      FACE_LOCAL <u_f_vect[l=2]> "faceave[](<u[l=2]>)"
      FACE_DERIVED <u_f_{raw}> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" ON <fluid all faces> # volume (velocity) transport
      
      # this file now does both steady-state and transient using transient comments string replacements, which are set in constants.arb
      
      # save old correction velocity for transient calculations
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1
         FACE_TRANSIENT <u_f_{correction}[r=1]> "0.d0" "<u_f_{correction}>" ON <fluid domain faces>
         #(hash inserted during unwrap)END_IF
      
      # assemble <u_f_{correction}>, taking advantage of variable reuse so that only one expression is formed for <u_f_{correction}> (to maximise code efficiency and maxima expression simplifications)
      
      # first assemble demoninator of expression:
      
      # all equation variants here have viscous contribution, so add this first
      # the rf stands for reciprocal and face centred
      # same piece of code as in total_stress to deal with <mu_f> replacement
      # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1  # this evaluates as true (1) if replacement string '<mu_f>' isn't defined, AND <<uniformviscosity>> is on (1)
         # if we are here then we apply the uniform viscosity substitution
         #(hash inserted during unwrap)END_IF
      FACE_LOCAL <u_rf_{vis}> "<mu>/<facedx>^2" ON <fluid all faces> # incase pextrapolationrhiechow is on, define these locals on allfaces (makes no difference to efficiency as they are locals anyway)
      FACE_DERIVED <u_f_{correction}> "<u_rf_{vis}>" ON <fluid domain faces>
      
      # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1  # this evaluates as true (1) if replacement string '<rho_f>' isn't defined, AND <<uniformviscosity>> is on (1)
         # if we are here then we apply the uniform density substitution
         #(hash inserted during unwrap)END_IF
      
      #############################################
      # advection term
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1 # only for navier-stokes equations
         #--------------
         # use this option to base the adv component on the total velocity magnitude, rather than the component over each face
         # the old way (pre v0.59) was to use <u_f_{raw}> which is the flux across the face when calculating the advective rhie-chow term
         # the new way (v0.59 and onwards) is based on the total velocity magnitude, so overwrite the string <<ufmagnitude>> with <u_f_vect_magnitude> which is the total magnitude of <u_f_vect[l=:]>
         
         #--------------
         # initialise variable using the old way, within the applicable block
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 2
            #(hash inserted during unwrap)IF 1 # ie, the new way
            # for a transient simulation the previous velocity magnitude is used, consistent with that used in the momentum advection
            # (although this can be overwritten by setting <<ufvectmagnitudeexplicit>> = 0 directly)
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 3
               #(hash inserted during unwrap)IF 1
               # performing index string loops on the following index list pairs:
               #  <<i>> 1,2
               FACE_LOCAL <u_f_vect[l=1,r=1]> "faceave[reflect=1](<u[l=1,r=1]>)"
               FACE_LOCAL <u_f_vect[l=2,r=1]> "faceave[](<u[l=2,r=1]>)"
               #     FACE_TRANSIENT <u_f_vect_magnitude[r=1]> "" "sqrt(facemax(dot(<u_f_vect[l=:,r=1]>,<u_f_vect[l=:,r=1]>),<tinyish>))" ON <allfaces>
               FACE_TRANSIENT <u_f_vect_magnitude[r=1]> "" "mag(<u_f_vect[l=:,r=1]>)" ON <fluid all faces>
               # S or SUBSTITUTE will redefine variable but in old context, ie, outside of IF block
               #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 3
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)#     FACE_LOCAL <u_f_vect_magnitude> "sqrt(facemax(dot(<u_f_vect[l=:]>,<u_f_vect[l=:]>),<tinyish>))" ON <allfaces>
               #(hash inserted during unwrap)FACE_LOCAL <u_f_vect_magnitude> "mag(<u_f_vect[l=:]>)" ON <fluid all faces>
               #(hash inserted during unwrap)# S or SUBSTITUTE will redefine variable but in old context, ie, outside of IF block
               #(hash inserted during unwrap)END_IF
            #(hash inserted during unwrap)END_IF
         # now calculate <u_rf_{adv}>
         #-------------
         # advective contribution can be either simple or more complex (set by <<ufadvectioncomplex>>)
         # the default behaviour is to use the simple advective contribution
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 2
            #(hash inserted during unwrap)IF 0
            #(hash inserted during unwrap)# more complex variant, which does not assume generally small correction velocities (and under steady-state conditions is equivalent to what was used pre v0.55) but is more expensive to compute, for what seems like little practical gain.  There is some evidence that the more complex variant can allow steady-state sims to converge more as Re increases, but very very marginal.
            #(hash inserted during unwrap)FACE_LOCAL <eps_p> "facemax(abs(<p_error>),<tinyish>)" ON <fluid all faces>
            #(hash inserted during unwrap)FACE_LOCAL <u_rf_{adv}> "<eps_p>/(-<u_f_vect_magnitude[r=1]>+sqrt(<u_f_vect_magnitude[r=1]>^2+<eps_p>*<facedx>/<rho>))" ON <fluid all faces>
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 2
            #(hash inserted during unwrap)ELSE
            # simple advective contribution (which really assumes that locally |<u_f_{raw}>| >> |<u_f_{correction}>|
            FACE_LOCAL <u_rf_{adv}> "2.d0*<rho>*<u_f_vect_magnitude[r=1]>/<facedx>" ON <fluid all faces>
            #(hash inserted during unwrap)END_IF
         # ---------
         # finally add on advection contribution
         FACE_DERIVED <u_f_{correction}> "<u_f_{correction}>+<u_rf_{adv}>"
         #(hash inserted during unwrap)END_IF
      
      #############################################
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1
         # for transient, add transient component to demoninator, take reciprocal, and add top transient and pressure contributions
         FACE_LOCAL <u_rf_{transient}> "<rho>/<dt>" ON <fluid all faces>
         FACE_DERIVED <u_f_{correction}> "(-<C_{Rhie-Chow}>*<p_error>+<u_rf_{transient}>*<u_f_{correction}[r=1]>)/(<u_f_{correction}>+<u_rf_{transient}>)"
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 1
         #(hash inserted during unwrap)ELSE
         #(hash inserted during unwrap)# for steady-state just take reciprocal and add pressure contribution
         #(hash inserted during unwrap)FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<p_error>/(<u_f_{correction}>)"
         #(hash inserted during unwrap)END_IF
      #############################################
      
      # final face velocity
      FACE_DERIVED <u_f> "<u_f_{raw}>+faceif(facedelta(<fluid domain faces>),<u_f_{correction}>,0.d0)" ON <fluid all faces> # volume (velocity) transport
      
      # this section just re-works the implicit timestepping equation to allow a newtstepmax to be applied to <dt_target>
      # save a derived copy of <dt_target> after <u_f> has been calculated so that we can apply newtstepmax to it
      # this string will already have been set to 1 (as a general replacement) in transient_all_setup if this option is relevant
      # this is the default behaviour when using implicit dynamic timestepping
      
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 1
         #(hash inserted during unwrap)IF 0
         #(hash inserted during unwrap)NONE_DERIVED <dt_target_derived> "<dt_target>" newtstepmax=10
         #(hash inserted during unwrap)NONE_EQUATION <dt implicit equation> "<dt>-<dt_target_derived>"
         #(hash inserted during unwrap)END_IF
      #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "advection_flux" 
      
      # flux of momentum over and in the direction of each face due to advection
      # which one is chosen depends on the comment strings
      # all require navierstokes equations to be current
      
         #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1 # this will be true for non-stokes (=navier-stokes) simulations
         
         # check default strings are set
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, which requires three things to be set for each option.  The comment type variables will eventually be phased out, but are still required for many of the template files.
            #(hash inserted during unwrap)END_MARKDOWN
            
            # the following strings require a flag variable and two comment variables to be set
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
         
         
         # setting <<implicitadvection>> = 1 causes momentum advection to be calculated using implicit velocities and densities, instead of explicit variables, which is relevant for transient simulations only
         # note, if you are setting this here, you may also like to make the velocity used in the calculation of <u_rf_{adv}> within u_f.arb implicit too, although it is not theoretically necessary (and will probably increase computational expense and decrease stability)
         # to do this set REPLACEMENTS R "<<ufvectmagnitudeexplicit>>" W "0" when calling u_f, or anywhere before calling that file
         
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 2
            #(hash inserted during unwrap)IF 
            #(hash inserted during unwrap)# using implicit velocities and densities is only relevant for steady-state simulations, and transient ones with <<implicitadvection>> on
            #(hash inserted during unwrap)# having to respect the old <<uniformdensitycomment>> choice for backwards compatibility with user's vof files - just in this file
            #(hash inserted during unwrap)#   IF <<uniformdensity>>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 3
               #(hash inserted during unwrap)IF  
               #(hash inserted during unwrap)# steady-state (or implicit advection) and uniform density
               #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
               #(hash inserted during unwrap)#  <<i>> 1,2
               #(hash inserted during unwrap)FACE_LOCAL <J_advection_f[l=1]> "<rho>*faceave[advection,reflect=1](<u[l=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <fluid all faces>
               #(hash inserted during unwrap)FACE_LOCAL <J_advection_f[l=2]> "<rho>*faceave[advection,](<u[l=2]>,<u_f>,<adv_limiter>)*<u_f>" ON <fluid all faces>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 3
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)# steady-state (or implicit advection) and varying density
               #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
               #(hash inserted during unwrap)#  <<i>> 1,2
               #(hash inserted during unwrap)FACE_LOCAL <J_advection_f[l=1]> "faceave[advection,reflect=1](<rho>*<u[l=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <fluid all faces>
               #(hash inserted during unwrap)FACE_LOCAL <J_advection_f[l=2]> "faceave[advection,](<rho>*<u[l=2]>,<u_f>,<adv_limiter>)*<u_f>" ON <fluid all faces>
               #(hash inserted during unwrap)END_IF
            #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 2
            #(hash inserted during unwrap)ELSE
            # having to respect the old <<uniformdensitycomment>> choice for backwards compatibility with user's vof files - just in this file
            #   IF <<uniformdensity>>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 3
               #(hash inserted during unwrap)IF 1 
               # transient and uniform density
               # performing index string loops on the following index list pairs:
               #  <<i>> 1,2
               FACE_LOCAL <J_advection_f[l=1]> "<rho>*faceave[advection,reflect=1](<u[l=1,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <fluid all faces>
               FACE_LOCAL <J_advection_f[l=2]> "<rho>*faceave[advection,](<u[l=2,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <fluid all faces>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 3
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)# transient and varying density
               #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
               #(hash inserted during unwrap)#  <<i>> 1,2
               #(hash inserted during unwrap)FACE_LOCAL <J_advection_f[l=1]> "faceave[advection,reflect=1](<rho[r=1]>*<u[l=1,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <fluid all faces>
               #(hash inserted during unwrap)FACE_LOCAL <J_advection_f[l=2]> "faceave[advection,](<rho[r=1]>*<u[l=2,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <fluid all faces>
               #(hash inserted during unwrap)END_IF
            #(hash inserted during unwrap)END_IF
         #(hash inserted during unwrap)END_IF
      #(comment created during unwrap): new block = ../../templates/navier_stokes/momentum_flux.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "momentum_flux" 
      
      # flux of momentum over and in the direction of each face
      
      # check default strings are set
         #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "default_string_replacements"
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
         #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)Some of these use both comment and flag type variables, which requires three things to be set for each option.  The comment type variables will eventually be phased out, but are still required for many of the template files.
         #(hash inserted during unwrap)END_MARKDOWN
         
         # the following strings require a flag variable and two comment variables to be set
         
         
         # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
         
         
      
      # start by placing in viscous momentum transport, applicable to both the stokes and navier-stokes equations
      # performing index string loops on the following index list pairs:
      #  <<i>> 1,2
      FACE_DERIVED <J_f[l=1]> "dot(<facenorm[l=:]>,<tau[l=:,1]>)" ON <fluid all faces>
      FACE_DERIVED <J_f[l=2]> "dot(<facenorm[l=:]>,<tau[l=:,2]>)" ON <fluid all faces>
      
      # and now add advection momentum transport for just the navier-stokes equations using self-referencing
         #(comment created during unwrap): new block = ../../templates/navier_stokes/momentum_flux.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1 # this will be true for non-stokes (=navier-stokes) simulations
         # performing index string loops on the following index list pairs:
         #  <<i>> 1,2
         VARIABLE <J_f[l=1]> "<J_f[l=1]>+<J_advection_f[l=1]>"
         VARIABLE <J_f[l=2]> "<J_f[l=2]>+<J_advection_f[l=2]>"
         #(hash inserted during unwrap)END_IF
      #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "conservation" 
      
      # conservation equations solved over each domain cell (finite volume method)
      
      # check default strings are set
         #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "default_string_replacements"
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
         #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)Some of these use both comment and flag type variables, which requires three things to be set for each option.  The comment type variables will eventually be phased out, but are still required for many of the template files.
         #(hash inserted during unwrap)END_MARKDOWN
         
         # the following strings require a flag variable and two comment variables to be set
         
         
         # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
         
         
      
      # now create equations
      CELL_EQUATION <continuity> "celldiv(<facex[l=1]>*<u_f>)/<cellx[l=1]>" ON <fluid domain> # continuity
      # performing index string loops on the following index list pairs:
      #  <<i>> 1,2
      CELL_EQUATION <momentum[l=1]> "celldiv(<facex[l=1]>*<J_f[l=1]>)/<cellx[l=1]>-<dynamic_force_c[l=1]>" ON <fluid domain> 
      CELL_EQUATION <momentum[l=2]> "celldiv(<facex[l=1]>*<J_f[l=2]>)/<cellx[l=1]>-<dynamic_force_c[l=2]>" ON <fluid domain> # momentum component'
      
      # add on hoop stress term separately for cylindrical coordinates
         #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1
         # perform a check that <<radialdim>> has been correctly defined
            #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 2
            #(hash inserted during unwrap)IF 
            #(hash inserted during unwrap)ERROR 'This is a cylindrical coordinate simulation however the string 1 has not been correctly defined'
            #(hash inserted during unwrap)END_IF
         VARIABLE <momentum[l=1]> "<momentum[l=1]>+2.d0*<u[l=1]>*<mu>/(<cellx[l=1]>**2)"
         #(hash inserted during unwrap)END_IF
      
      #define momentum eqn for azimuthal component
         #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 1
         #(hash inserted during unwrap)IF 0
         #(hash inserted during unwrap)# perform a check that <<azimuthaldim>> has been correctly defined
            #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 2
            #(hash inserted during unwrap)IF 
            #(hash inserted during unwrap)ERROR 'This is a cylindrical coordinate simulation with azimuthal flow however the string 0 has not been correctly defined'
            #(hash inserted during unwrap)END_IF
         #(hash inserted during unwrap)VARIABLE <momentum[l=0]> "celldiv((<facex[l=1]>**2)*<J_f[l=0]>)/(<cellx[l=1]>**2)+<rho>*<u[l=1]>*<u[l=0]>/<cellx[l=1]>" ON <fluid domain> # momentum component'
         #(hash inserted during unwrap)VARIABLE <momentum[l=1]> "<momentum[l=1]>-<rho>*<u[l=0]>**2/<cellx[l=1]>"
         #(hash inserted during unwrap)END_IF
      
      # add transient term which is independent of cartesian or cylindrical coordinates
         #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1
            #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 2
            #(hash inserted during unwrap)IF 1
            # performing index string loops on the following index list pairs:
            #  <<i>> 1,2
            VARIABLE <momentum[l=1]> "<rho>*(<u[l=1]>-<u[l=1,r=1]>)/<dt>+<momentum[l=1]>"
            VARIABLE <momentum[l=2]> "<rho>*(<u[l=2]>-<u[l=2,r=1]>)/<dt>+<momentum[l=2]>"
            #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 2
            #(hash inserted during unwrap)ELSE
            #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
            #(hash inserted during unwrap)#  <<i>> 1,2
            #(hash inserted during unwrap)VARIABLE <momentum[l=1]> "(<rho>*<u[l=1]>-<rho[r=1]>*<u[l=1,r=1]>)/<dt>+<momentum[l=1]>"
            #(hash inserted during unwrap)VARIABLE <momentum[l=2]> "(<rho>*<u[l=2]>-<rho[r=1]>*<u[l=2,r=1]>)/<dt>+<momentum[l=2]>"
            #(hash inserted during unwrap)END_IF
         #(hash inserted during unwrap)END_IF
   
   # overwrite dynamic forces to include surface tension
   VARIABLE <dynamic_force_c[l=1]> "<dynamic_force_c[l=1]>+<sigma>*<ls_F_c_fluid[l=1]>" output
   VARIABLE <dynamic_force_c[l=2]> "<dynamic_force_c[l=2]>+<sigma>*<ls_F_c_fluid[l=2]>"
   #VARIABLE <dynamic_force_c[l=3]> "<dynamic_force_c[l=3]>+<sigma>*<ls_F_c_fluid[l=3]>"
   VARIABLE <dynamic_force_f> "<dynamic_force_f>+<sigma>*facetofacelink(expression=<ls_F_f>,localregion=<fluid all faces>,remoteregion=<level set centre all faces>)"
   
   VARIABLE <ls_F_c[l=1]> output # set output on
   
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "free_surface/level_set"
   # need to generalise this in the future to cope with slip walls by extrapolating <u_f> out into <level set edge region>
   FACE_LOCAL <ls_u_f> "faceif(facedelta(<level set centre all faces>),facetofacelink(expression=<u_f>,localregion=<level set centre all faces>,remoteregion=<fluid all faces>),0.d0)" ON <level set all faces>
   FACE_LOCAL <ls_u_f[r=1]> "faceif(facedelta(<level set centre all faces>),facetofacelink(expression=<u_f[r=1]>,localregion=<level set centre all faces>,remoteregion=<fluid all faces>),0.d0)" ON <level set all faces>
      #(comment created during unwrap): new block = ../../templates/free_surface/level_set/equation.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "equation" 
      
      # three types of end-of-timestep <ls> functions are referenced:
      # 1) <ls> is the fully implicit one, with reinitialisation applied away from the interface
      # 2) <ls_advected> is also implicit, but without any reinitialisation
      # 3) <ls_explicit> is explicitly calculated using <u_f[r=1]>, also without any reinitialisation.  It is used for some decision variables (<ls_weight>, <ls_sign>) as it does not change between newton loops
      
      # <ls_explicit>
      # these are transients as they are fully explicit
      FACE_TRANSIENT <ls_f_explicit[r=0]> "<ls[r=1]>" "faceave[advection](<ls[r=1]>,<ls_u_f[r=1]>,<ls_advection_limiter>)" ON <level set all faces> nooutput
      #CELL_TRANSIENT <ls_explicit[r=0]> "<ls[r=1]>" "<ls[r=1]>-<dt>*celldiv(<ls_f_explicit>*<u_f[r=1]>)" ON <allcells> nooutput
      # note: guarding against destabilising effects of non-zero divergence after first timestep
      CELL_TRANSIENT <ls_explicit[r=0]> "<ls[r=1]>" "<ls[r=1]>-<dt>*celldiv((<ls_f_explicit>-faceave[lastcell](<ls[r=1]>))*<ls_u_f[r=1]>)" ON <level set all cells> nooutput
      
      # <ls_advected> - here fully implicit
      #FACE_DERIVED <ls_f_advected> "faceave[advection](<ls>,<u_f>,<ls_advection_limiter>)" ON <allfaces> nooutput
      ##CELL_DERIVED <ls_advected> "<ls[r=1]>-<dt>*celldiv(<ls_f_advected>*<u_f>)" ON <allcells> nooutput
      ## note: guarding against destabilising effects of non-zero divergence enroute to convergence
      #CELL_DERIVED <ls_advected> "<ls[r=1]>-<dt>*celldiv((<ls_f_advected>-faceave[lastcell](<ls>))*<u_f>)" ON <allcells> nooutput
      
      # <ls_advected> - here using explicit <ls>, implicit <u_f>
      # v0.42, this changed to the default
      FACE_DERIVED <ls_f_advected> "faceave[advection](<ls[r=1]>,<ls_u_f>,<ls_advection_limiter>)" ON <level set all faces> nooutput
      #CELL_DERIVED <ls_advected> "<ls[r=1]>-<dt>*celldiv(<ls_f_advected>*<u_f>)" ON <allcells> nooutput
      # note: guarding against destabilising effects of non-zero divergence enroute to convergence
      CELL_DERIVED <ls_advected> "<ls[r=1]>-<dt>*celldiv((<ls_f_advected>-faceave[lastcell](<ls[r=1]>))*<ls_u_f>)" ON <level set all cells> nooutput
      
      # <ls_advected> - here using crank-nicholson for both <ls> and <u_f>
      #FACE_DERIVED <ls_f_advected> "faceave[advection]((<ls[r=1]>+<ls>)*0.5d0,(<u_f>+<u_f[r=1]>)*0.5d0,<ls_advection_limiter>)" ON <allfaces> nooutput
      ##CELL_DERIVED <ls_advected> "<ls[r=1]>-<dt>*celldiv(<ls_f_advected>*<u_f>)" ON <allcells> nooutput
      ## note: guarding against destabilising effects of non-zero divergence enroute to convergence
      #CELL_DERIVED <ls_advected> "<ls[r=1]>-<dt>*celldiv((<ls_f_advected>-faceave[lastcell](<ls[r=1]>+<ls>)*0.5d0)*(<u_f>+<u_f[r=1]>)*0.5d0)" ON <allcells> nooutput
      
      # <ls_advected> - completely explicit
      #CELL_LOCAL <ls_advected> "<ls_explicit[r=0]>"
      
      # the following depend only on <ls_explicit> and hence are constant for each timestep
      CELL_LOCAL <ls_sign> "cellif(<ls_explicit>,1.d0,-1.d0)"
      CELL_TRANSIENT <ls_explicit_normalised> "<ls_explicit>/<ls_celldxmax>" ON <level set all cells> nooutput
      # this weight variable determines whether the <ls> value will locally be reinitialised or not.  For <ls_weight> = 0, no reinitialisation will occur (typical of on or near the interface).  For <ls_weight> = 1, as much reinitialisation will occur as possible, but probably at the expense of mass conservation.  Overwriting this with 0 will stop the reinitialisation from occurring everywhere.
      CELL_TRANSIENT <ls_weight[r=0]> "cellif(abs(<ls_explicit_normalised>)-<ls_weight_max>,1.d0,cellif(abs(<ls_explicit_normalised>)-<ls_weight_min>,(1.d0-cos((abs(<ls_explicit_normalised>)-<ls_weight_min>)*<pi>/(<ls_weight_max>-<ls_weight_min>)))/2.d0,0.d0))" ON <level set all cells> elementdata # this will be initialised at timestep=0 as 0.d0
      
      # this section is concerned with calculating the mod of grad s, which should equal 1 for a level set function.  This is the basis for the reinitialisation proceedure
      # the mod(grad(<ls>)) is split into two cell divergences, using a pseudo advection velocity which is directed away from the interface
      # the order of discretisation for the calculation of this velocity, and the face averaged advection <ls> functions is important - high order must be used to get increasing accuracy of the surface tension force with increasing mesh refinement
      # however, near boundaries, high order discretisation can be hard to converge (often giving numerically singular matrices), depending on the boundary condition employed
      # as a solution, we use high order discretisations near the interface, and low order away from the interface and near any walls
      # this is the maximum discretisation order used (between 0 and 1, not the actual order, but a flag indicating high or low order)
      # if you're having problems with convergence, try setting this variable to 0.d0 to give the most forgiving formulation (then look at boundary conditions...)
      CONSTANT <ls_reinitialisation_order_max> 1.d0
      #CELL_CONSTANT <ls_reinitialisation_order_max> "<ls_advection_limiter>" ON <allcells>
      # this is a function which is 0 next to walls, and 1 otherwise
      CELL_CONSTANT <ls_reinitialisation_order_walls> "1.d0-facemax(facedelta(<level set walls>),region=<celljfaces>)" ON <level set all cells> elementdata
      CELL_LOCAL <ls_reinitialisation_order_small> "cellmin(cellif(abs(<ls_explicit_normalised>)-(<ls_validity_max>+1.d0),0.d0,<ls_reinitialisation_order_max>),<ls_reinitialisation_order_walls>)" elementdata
      # this determines the discretisation of the advection face centred values of <ls> will be calculated - from experience this must switch to low order before <ls_reinitialisation_order_f>, hence the wrapping of this function in a loop
      #CELL_TRANSIENT <ls_reinitialisation_order> "cellmin(cellmin(<ls_reinitialisation_order_small>,region=<cellicells>),region=<cellicells>)" ON <allcells> elementdata
      #CELL_TRANSIENT <ls_reinitialisation_order> "cellmin(<ls_reinitialisation_order_small>,region=<cellicells>)" ON <allcells> elementdata
      CELL_TRANSIENT <ls_reinitialisation_order> "cellmin(cellmin(<ls_reinitialisation_order_small>,region=<cellicells>),<ls_advection_limiter>)" ON <level set all cells> elementdata
      # this determines how the face centred pseudo advection velocity will be calculated
      FACE_TRANSIENT <ls_reinitialisation_order_f> "cellmin(<ls_reinitialisation_order_small>,region=<adjacentfaceicells>)" ON <level set all faces>
      
      # include the grad_ls dot products for both the positive and negative sides of the interface
      # the mod(grad(<ls>)) functions are calculated in these
         #(comment created during unwrap): new block = ../../templates/free_surface/level_set/ls_grad_dot_pos.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "ls_grad_dot_pos" 
         
         # this file calculates all level set quantities for the positive level-set side of the interface, for the calculation of mod(grad(<ls>)) and mod(grad(<ls_advected>))
         # all variables used here include `_pos' in their name, which is replaced by `_neg' when used on the other side of the interface
         
         # calculate mod(grad(<ls_advected>)), taking into account requested discretisation orders
         # this is the pseudo advection velocity that points away from the interface
         FACE_DERIVED <ls_u_advected_pos> "+(faceif(<ls_reinitialisation_order_f>,facegrad(<ls_advected>),facegrad[adjacentcells](<ls_advected>)))" ON <level set all faces>
         # this is the face averaged <ls> value that will be used in the cell divergences
         FACE_DERIVED <ls_f_advected_pos> "faceave[advection](<ls_advected>,<ls_u_advected_pos>,<ls_reinitialisation_order>)" ON <level set all faces>
         #CELL_LOCAL <ls_grad_dot_advected_pos> "<<sign>>(celldiv(<ls_f_advected_pos>*<ls_u_advected_pos>)-<ls_advected>*celldiv(<ls_u_advected_pos>))"
         # and this is mod(grad(<ls_advected>))
         # faster?
         CELL_LOCAL <ls_grad_dot_advected_pos> "+(celldiv((<ls_f_advected_pos>-faceave[lastcell](<ls_advected>))*<ls_u_advected_pos>))"
         
         # define an implicit <ls> function on the positive side of the interface which is anchored at the interface to the ls_advect values
         CELL_DERIVED <ls_pos> "cellif(+<ls_sign>,<ls>,<ls_advected>)" ON <level set all cells> nooutput
         
         # the exact above three steps are repeated for <ls_pos> to find mod(grad(<ls_pos>))
         FACE_DERIVED <ls_u_pos> "+(faceif(<ls_reinitialisation_order_f>,facegrad(<ls_pos>),facegrad[adjacentcells](<ls_pos>)))" ON <level set all faces>
         FACE_DERIVED <ls_f_pos> "faceave[advection](<ls_pos>,<ls_u_pos>,<ls_reinitialisation_order>)" ON <level set all faces>
         #CELL_LOCAL <ls_grad_dot_pos> "<<sign>>(celldiv(<ls_f_pos>*<ls_u_pos>)-<ls_pos>*celldiv(<ls_u_pos>))" output,elementdata
         CELL_LOCAL <ls_grad_dot_pos> "+(celldiv((<ls_f_pos>-faceave[lastcell](<ls_pos>))*<ls_u_pos>))"
         
         # also calculate the minimum pseudo velocity out of the cell (ie, -max(velocity into the cell)).  If this is positive then no ls velocity is directed into the cell and if upwinding is used then the equations will become degenerate.  Currently no decent solution to keep simulation progressing.
         CELL_OUTPUT <ls_u_min_pos> "facemin(<ls_u_pos>*<facefromcelldirection>,region=<celljfaces>)" ON <level set domain> elementdata
         #(comment created during unwrap): new block = ../../templates/free_surface/level_set/ls_grad_dot_pos.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "ls_grad_dot_pos" 
         
         # this file calculates all level set quantities for the positive level-set side of the interface, for the calculation of mod(grad(<ls>)) and mod(grad(<ls_advected>))
         # all variables used here include `_pos' in their name, which is replaced by `_neg' when used on the other side of the interface
         
         # calculate mod(grad(<ls_advected>)), taking into account requested discretisation orders
         # this is the pseudo advection velocity that points away from the interface
         FACE_DERIVED <ls_u_advected_neg> "-(faceif(<ls_reinitialisation_order_f>,facegrad(<ls_advected>),facegrad[adjacentcells](<ls_advected>)))" ON <level set all faces>
         # this is the face averaged <ls> value that will be used in the cell divergences
         FACE_DERIVED <ls_f_advected_neg> "faceave[advection](<ls_advected>,<ls_u_advected_neg>,<ls_reinitialisation_order>)" ON <level set all faces>
         #CELL_LOCAL <ls_grad_dot_advected_pos> "<<sign>>(celldiv(<ls_f_advected_pos>*<ls_u_advected_pos>)-<ls_advected>*celldiv(<ls_u_advected_pos>))"
         # and this is mod(grad(<ls_advected>))
         # faster?
         CELL_LOCAL <ls_grad_dot_advected_neg> "-(celldiv((<ls_f_advected_neg>-faceave[lastcell](<ls_advected>))*<ls_u_advected_neg>))"
         
         # define an implicit <ls> function on the positive side of the interface which is anchored at the interface to the ls_advect values
         CELL_DERIVED <ls_neg> "cellif(-<ls_sign>,<ls>,<ls_advected>)" ON <level set all cells> nooutput
         
         # the exact above three steps are repeated for <ls_pos> to find mod(grad(<ls_pos>))
         FACE_DERIVED <ls_u_neg> "-(faceif(<ls_reinitialisation_order_f>,facegrad(<ls_neg>),facegrad[adjacentcells](<ls_neg>)))" ON <level set all faces>
         FACE_DERIVED <ls_f_neg> "faceave[advection](<ls_neg>,<ls_u_neg>,<ls_reinitialisation_order>)" ON <level set all faces>
         #CELL_LOCAL <ls_grad_dot_pos> "<<sign>>(celldiv(<ls_f_pos>*<ls_u_pos>)-<ls_pos>*celldiv(<ls_u_pos>))" output,elementdata
         CELL_LOCAL <ls_grad_dot_neg> "-(celldiv((<ls_f_neg>-faceave[lastcell](<ls_neg>))*<ls_u_neg>))"
         
         # also calculate the minimum pseudo velocity out of the cell (ie, -max(velocity into the cell)).  If this is positive then no ls velocity is directed into the cell and if upwinding is used then the equations will become degenerate.  Currently no decent solution to keep simulation progressing.
         CELL_OUTPUT <ls_u_min_neg> "facemin(<ls_u_neg>*<facefromcelldirection>,region=<celljfaces>)" ON <level set domain> elementdata
      
      # domain equation
      # actual equation used to update ls - away from the interface (<ls_weight> = 1) mod(grad(<ls>)) = 1, while close to the interface (<ls_weight> = 0) mod(grad(<ls>)) = mod(grad(<ls_advected>))
      CELL_LOCAL <ls_grad_dot> "cellif(<ls_sign>,<ls_grad_dot_pos>,<ls_grad_dot_neg>)"
      CELL_LOCAL <ls_grad_dot_advected> "cellif(<ls_sign>,<ls_grad_dot_advected_pos>,<ls_grad_dot_advected_neg>)"
      CELL_EQUATION <ls_equation_domain> "<ls_grad_dot>-(<ls_weight>+(1.d0-<ls_weight>)*<ls_grad_dot_advected>)" ON <level set domain>
      
      # wall and boundary equations now done in separate template files
   
   # fluid boundary conditions on nonslip walls
      #(comment created during unwrap): new block = ../../templates/free_surface/level_set/walls_ls_grad_set.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "walls_ls_grad_set" 
      
      # boundary equations for walls
      # The most stable and forgiving equation to used on the walls is to set <ls> to a low (negative, continuous phase) value that is beyond anything that could affect the surface force calculation.
      # One advantage of this is that even if there is no fluid in the vicinity of the wall, the <ls> function is still conceptually defined
      # The disadvantage is that if the fluid gets too close to the wall, then the force will be in error - hence, the domain on which the <ls> function is calculated should be bigger than that over which the momentum equations are calculated
      # If using this boundary condition, then use <ls_background> as the starting point for <ls_initial>
      #FACE_EQUATION <ls_equation_walls> "<ls>-<ls_walls>" ON <walls>
      
      # Alternatively, a form of mod(grad(<ls>))=1 can be set on the walls, but this requires that the <ls> is well defined in the adjacent domain.
      # Again, errors will occur (although smaller than the above) if the fluid gets too close to the walls, so fluid and level set calcs should be performed on separate domains.
      # Like the last equation, this requires low order differencing near the walls, otherwise the jacobian matrix may become singular as when using higher order differencing, this equation could be almost identical to that solved within the adjacent cell
      # If using this boundary condition, do not use <ls_background> as the starting point for <ls_initial>, instead use the true <ls_initial> right up to the walls
      FACE_LOCAL <ls_dlsdx[l=1]> "facegrad[l=1](<ls>)"
      FACE_LOCAL <ls_dlsdx[l=2]> "facegrad[l=2](<ls>)"
      #FACE_LOCAL <ls_dlsdx[l=3]> "facegrad[l=3](<ls>)"
      FACE_EQUATION <ls_equation_walls> "dot(<ls_dlsdx[l=:]>,<ls_dlsdx[l=:]>)-1.d0" ON <level set walls>
      
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "navier_stokes"
      #(comment created during unwrap): new block = ../../templates/navier_stokes/walls_p_set.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "walls_p_set" 
      
         #(comment created during unwrap): new block = ../../templates/navier_stokes/walls_equations.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "walls_equations" 
         
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Sets basic names etc for a wall, and only specifies the boundary normal method
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)Use the template "walls" instead of calling this directly
         #(hash inserted during unwrap)END_MARKDOWN
         
         # use rhiechow
         # in v0.59 changed to default on 24/9/18 due to much better velocity and pressure distribution along slip walls in transient_flow_around_cylinder_with_species
         
         
         # use zerodynamic
         #REPLACEMENTS D "<<boundarynormalmethod>>" W "zerodynamic"
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "boundary_equations" 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, inlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)This has a few variables that can be set:
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)`rhiechow` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
            #(hash inserted during unwrap)`noslip` determines the shear conditions at the boundary
            #(hash inserted during unwrap)`nofluxpset` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `<<boundarymethodvariable>>`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)The defaults specify a fully developed flow through <fluid walls> with a set flowrate of <walls u> created by varying the uniform <dynamic_force_f> (ie, an inlet).
            #(hash inserted during unwrap)END_MARKDOWN
            
            # First equation is a constraint on normal velocity gradient normal to the boundary
            # by default grad{u}:nn = 0
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundarynormalmethod>>=rhiechow)
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "zerodynamic"
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "zerogradp"
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "zeroperror"
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 1
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_extrapolation_rhie_chow.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
                  
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Here we link the pressure gradient (contained within <dynamic_force_f>) to the boundary velocity using the previously calculated rhie-chow interpolation terms.  In effect, adds a link between the pressure and velocity on the boundary.
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)Note that the <u_f_{correction}> term is based on <p_error>, which for boundary cells equates to the difference between <dynamic_force_f> and <dynamic_force_c> (component) evaluated in the downcell, as celldiv applied in a boundary cell automatically takes its value from the adjacent domain cell.
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # first need to make sure that the relevant rhie-chow variables are defined on the boundaries
                  VARIABLE <p_error> ON <fluid all faces> output
                  VARIABLE <u_f_{correction}> ON <fluid all faces>
                  VARIABLE <u_f_{correction}[r=1]> ON <fluid all faces>
                  
                  # this needs to be fixed up possibly so that direction is consistent with dxunit?
                  FACE_EQUATION <walls pextrapolation> "<u_f>-faceave[downcell](dot(<u[l=:]>,cellave[lastface](<facenorm[l=:]>)))-<u_f_{correction}>" ON <fluid walls> # pressure gradient next to wall set so that dynamic pressure gradient inext to wall is zero
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)FACE_EQUATION <walls pextrapolation> "<dynamic_force_f>" ON <fluid walls>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)FACE_EQUATION <walls pextrapolation> "<p_error>" ON <fluid walls>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)FACE_EQUATION <walls pextrapolation> "facegrad(<p>)" ON <fluid walls>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: rhiechow"
               #(hash inserted during unwrap)END_IF
            
            # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
            
            #REPLACEMENTS D "<<boundarytangentmethod>>" W "slip"
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)INCLUDE "slip" 
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 1
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "noslip" 
                  
                  FACE_EQUATION <walls noslip1> "dot(<u_f_vect[l=:]>,<facetang1[l=:]>)" ON <fluid walls> # no component tangential to the face
                  #FACE_EQUATION <walls noslip2> "dot(<u_f_vect[l=:]>,<facetang2[l=:]>)" ON <fluid walls> # no component tangential to the face in the second tangential direction
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: noslip"
               #(hash inserted during unwrap)END_IF
            
            # Third equation is a constraint on the velocity or pressure value at the boundary
            # the first three all specify uniform conditions across the boundary:
            #REPLACEMENTS D "<<boundarymethod>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
            #REPLACEMENTS D "<<boundarymethod>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
            #REPLACEMENTS D "<<boundarymethod>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundarymethod>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
            # all of the remaining methods require a single face within the region to be special cased:
            #REPLACEMENTS D "<<boundarymethod>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
            # the following two methods set whatever the <<boundarymethodvariable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundarymethodvariable>>, defaulting to <dynamic_force_f>)
            # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
            #REPLACEMENTS D "<<boundarymethod>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "<p_f>-<walls p>" ON <fluid walls> # specified pressure
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "<u_f>+<walls u>" ON <fluid walls> # specified velocity
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "<u_f>" ON <fluid walls> # zero velocity
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF  1
               # all of these boundary methods require the oneface (or centreline) subdomain, so form these first
               
               # now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
               # by default create the single oneface region here
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 1
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/oneface_region.arb: sub_block = 0
                     #(hash inserted during unwrap)INCLUDE "oneface_region"
                     #(hash inserted during unwrap)MARKDOWN
                     #(hash inserted during unwrap)Here we define two subregions of <fluid walls>, one being a single face (<walls oneface>) and the remainder as <walls sand oneface>, mainly for the use in setting inidividual equations on boundaries
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)Call with a replacement to '<walls' to specify where it is applied, as in '<inlet', '<outlet' or '<wall'.  Also can call with 'oneface' replaced by 'centreline' for inlet and outlet ports.
                     #(hash inserted during unwrap)END_MARKDOWN
                     
                     FACE_REGION <walls oneface> "at(0.d0,0.d0,0.d0)" ON <fluid walls> # default single cell is chosen closest to the origin
                     FACE_REGION <walls sans oneface> "compound(<fluid walls>-<walls oneface>)" ON <fluid walls>
                  #(hash inserted during unwrap)END_IF
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 1 
                  
                  FACE_EQUATION <walls flowrate equation> "<u_f>" ON <walls sans oneface> # zero velocity on most of the region
                  FACE_EQUATION <walls oneface flowrate equation> "<p_f>" ON <walls oneface>
                  
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)# for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                     #(hash inserted during unwrap)# to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                     #(hash inserted during unwrap)#NONE_DERIVED <walls u_av_calc> "facesum(-<u_f>*<facearea>,<fluid walls>)/facesum(<facearea>,<fluid walls>)" # calculate average velocity directed into the domain
                     #(hash inserted during unwrap)NONE_DERIVED <walls u_av_calc> "facesum(-<u_f>*<facearea>*<facex[l=1]>,<fluid walls>)/facesum(<facearea>*<facex[l=1]>,<fluid walls>)" # calculate average velocity directed into the domain
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)# this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                     #(hash inserted during unwrap)NONE_EQUATION <walls oneface flowrate equation> "<walls u_av_calc>-<walls u>" # set flowrate through region to give required average velocity
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <walls oneface flowrate equation> "<p_f>-<walls p>" ON <walls oneface> # set pressure at oneface to <region p>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: nofluxpset"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "celldivgrad"
                  #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "facegrad"
                  #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "p"
                  #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                     #(hash inserted during unwrap)#  <<i>> 1,2
                     #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                     #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                     #(hash inserted during unwrap)#     <<dim1comment>> CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                     #(hash inserted during unwrap)#     <<dim2comment>> CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                     #(hash inserted during unwrap)#     <<dim3comment>> CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                     #(hash inserted during unwrap)NONE_DERIVED <walls oneface gradp> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<walls oneface>)"
                     #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<walls oneface gradp>" ON <walls sans oneface> # apply specified pressure over inlet
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_DERIVED <walls oneface gradp> "facesum(<dynamic_force_f>,region=<walls oneface>)"
                     #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "<dynamic_force_f>-<walls oneface gradp>" ON <walls sans oneface>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_DERIVED <walls oneface gradp> "facesum(facegrad(<p>),region=<walls oneface>)"
                     #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "facegrad(<p>)-<walls oneface gradp>" ON <walls sans oneface>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_DERIVED <walls oneface p> "facesum(<p_f>,region=<walls oneface>)"
                     #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "<p_f>-<walls oneface p>" ON <walls sans oneface>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: <<boundarymethodvariable>>"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)END_IF
               
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: nofluxpset"
               #(hash inserted during unwrap)END_IF
   
   #-------------------------------------------------------------------
   NONE_OUTPUT <integrated volume> "cellsum(<ls_phi>*<cellvol>,<level set domain>)"
   
   CELL_LOCAL <u_mag> "sqrt(cellmax(dot(<u[l=:]>,<u[l=:]>),<tinyish>))"
   NONE_DERIVED <u_max> "cellmax(<u_mag>,region=<fluid domain>)" stepoutput
   NONE_DERIVED <CFL> "cellmax(<u_mag>*<dt>/<celldxkernel>,region=<fluid domain>)" stepoutput
   
   NONE_OUTPUT <centroid[l=1]> "cellsum(<cellvol>*<cellx[l=1]>*<ls_phi>,region=<level set domain>)/cellsum(<cellvol>*<ls_phi>,region=<level set domain>)"
   NONE_OUTPUT <centroid[l=2]> "cellsum(<cellvol>*<cellx[l=2]>*<ls_phi>,region=<level set domain>)/cellsum(<cellvol>*<ls_phi>,region=<level set domain>)"
   NONE_OUTPUT <stretch[l=1]> "sqrt(cellsum(<cellvol>*(<cellx[l=1]>-<centroid[l=1]>)^2*<ls_phi>,region=<level set domain>)/cellsum(<cellvol>*<ls_phi>,region=<level set domain>))"
   NONE_OUTPUT <stretch[l=2]> "sqrt(cellsum(<cellvol>*(<cellx[l=2]>-<centroid[l=2]>)^2*<ls_phi>,region=<level set domain>)/cellsum(<cellvol>*<ls_phi>,region=<level set domain>))"
   
   CELL_LOCAL <central flag> "cellif(celltocelllink(expression=<ls_normalised>-<ls_phi_max>,localregion=<fluid domain>,remoteregion=<level set domain>),1.d0,0.d0)"
   NONE_OUTPUT <p central> "cellsum(<central flag>*<cellvol>*<p>,region=<fluid domain>)/cellsum(<central flag>*<cellvol>,region=<fluid domain>)"
   NONE_OUTPUT <p central We> "<p central>*<We>*(2.d0^1)"
   NONE_OUTPUT <p central We err> "abs(<p central>*<We>-1.d0)"
   NONE_OUTPUT <u rms> "sqrt(cellsum(<cellvol>*<u_mag>^2,region=<fluid domain>)/cellsum(<cellvol>,region=<fluid domain>))"
   NONE_OUTPUT <minimum boundary ls> "facemin(-<ls>,region=<level set boundaries>)/<ls_celldxmax>"
   #-------------------------------------------------------------------
##################################################################################
