# arb finite volume solver
# Copyright 2009,2010 Dalton Harvie (daltonh@unimelb.edu.au)
#
# arb is released under the GNU GPL.  For full details see the license directory.
#
#-------------------------------------------------------------------
VERSION 0.50 # the version of syntax used in this file

# the following strings describe the simulation and are passed to the output files
INFO_TITLE "Transient flow around a sphere with species transient"
INFO_DESCRIPTION "Demonstrates transient flow setup as well as transient species transport"
INFO_DESCRIPTION+ ": parameters used in this demonstration file will result in a low accuracy simulation due to large timestep"
INFO_AUTHOR "Dalton Harvie"
INFO_DATE "28/1/15" # interpreted as the last modification date

#-------------------------------------------------------------------
# system constants

#KERNEL_OPTIONS polynomialorder=1,polynomialaverageorder=1,minimumminw=2.d0
#KERNEL_OPTIONS minimumminw=1.d0
#KERNEL_OPTIONS checkminw=.true.,minimumminw=0.8d0 # reducing the minw a bit which will decrease the size of the kernels

#-------------------------------------------------------------------
# geometry

# CELL_REGION/FACE_REGION specified by: <name> "location string" # comments
# where location string could be: "AT x1 x2 x3" for a single point closest to these coordinates
# where location string could be: "WITHIN BOX x1_min x2_min x3_min x1_max x2_max x3_max" for all elements within a box defined by the minimum and maximum coordinate values
# where location string could be: "COMPOUND +<a region>-<another region>" for a + and - compound region list
# where location string could be: "BOUNDARY OF <a region>" - boundary faces/cells contained within or surrounding <a region>
# where location string could be: "DOMAIN OF <a region>" - domain faces/cells contained within <a region>
# where location string could be: "ASSOCIATED WITH <a region>" - faces/cells both contained within and surrounding <a region>

FACE_REGION <slip walls> "COMPOUND <boundaries>-<inlet>-<outlet>-<cylinder>"
FACE_REGION <walls> "COMPOUND <cylinder>"
NODE_REGION <cylinder nodes> "ASSOCIATED WITH <cylinder>"
FACE_REGION <inlet centreline> "AT 0.d0 0.d0 0.d0 PART OF <inlet>"
FACE_REGION <inlet sans centreline> "COMPOUND <inlet>-<inlet centreline>"
FACE_REGION <outlet centreline> "AT 0.d0 0.d0 0.d0 PART OF <outlet>"
FACE_REGION <outlet sans centreline> "COMPOUND <outlet>-<outlet centreline>"
CELL_REGION <wake monitor> "AT 2.5d0 0.5d0 0.d0 PART OF <domain>"

# MSH_FILE instructs arb to read or write a gmsh file (location is read location - write location will always be within the output directory)
# output options are: output,centringoutput,meshoutput,centringmeshoutput,nooutput
# input options are: input,centringinput,meshinput,centringmeshinput,noinput
# data output format options for CELL centred data (which overwrite individual variable options if specified): elementdata,elementnodedata,elementnodelimiteddata
# vtk file output options are: vtkoutput,centringvtkoutput,meshvtkoutput,centringmeshvtkoutput,novtkoutput (novtkoutput is the default)
# dat file output options are: datoutput,centringdatoutput,meshdatoutput,centringmeshdatoutput,nodatoutput (nodatoutput is the default)
MSH_FILE "transient_flow_around_cylinder_with_species.msh"

#-------------------------------------------------------------------
# variable definition reference:
# REGION_LIST <region_1> <region_2> ... <region_n> # comments: line has the ordered names of any regions
# (CELL_|FACE_)REGION_CONSTANT <name> [multiplier*units] numerical_value_for_region_1 .. value_for_region_n options # comments: sets a constant that varies with region
# (CELL_|FACE_|NONE_|)CONSTANT <name> [multiplier*units] numerical_value ON <region> options # comments: sets a constant specific to one region or no regions and has the form
# (CELL_|FACE_|NONE|)CONSTANT <name> [units] "expression (involving only constants)" ON <region> options # comments
# (CELL_|FACE_|NONE|)TRANSIENT <name> [units] "expression (initial value, optional, evaluated in descending relstep order)" "expression (evaluated in ascending relstep order)" ON <region> options # comments
# (CELL_|FACE_|NONE|)NEWTIENT <name> [units] "expression (initial value, optional, evaluated in descending relstep order)" "expression (evaluated in ascending relstep order)" ON <region> options # comments
# (CELL_|FACE_|NONE|)DERIVED <name> [units] "expression" ON <region> options # comments
# (CELL_|FACE_|NONE|)UNKNOWN <name> [units] "expression (initial value, optional)" ON <region> options # comments
# (CELL_|FACE_|NONE|)EQUATION <name> [units] "expression (equation equaling zero)" ON <region> options # comments
# (CELL_|FACE_|NONE|)OUTPUT <name> [units] "expression" ON <region> options # comments
# (CELL_|FACE_|NONE|)CONDITION <name> [units] "expression" ON <region> options # comments
# (CELL_|FACE_|NONE|)LOCAL <name> [units] "expression" ON <region> options # comments

# options include (with p=perl and f=fortran indicating which piece of code needs to know the option):
#p  derivative/noderivative - for DERIVED, EQUATION, LOCAL : do or do not calculate Jacobian derivatives for this variable
#p  positive/negative/nocheck - for DERIVED, UNKNOWN, EQUATION, LOCAL : check at each iteration that variable is positive/negative
#f  output/nooutput - for ALL : output compound to msh files
#f  componentoutput/nocomponentoutput - for ALL : output just this component to msh files
#f  stepoutput/stepoutputnoupdate/nostepoutput - for ALL : output compound to step file.  The noupdate one does not update the variable when the step file is written (needed for recording when output occurred for example).
#f  componentstepoutput/componentstepoutputnoupdate/nocomponentstepoutput - for ALL : output just this component to step files
#f  input/noinput - for CONSTANT, TRANSIENT, UNKNOWN : read in compound from msh files - only these 3 variable types can be read in
#f  componentinput/nocomponentinput - for CONSTANT, TRANSIENT, UNKNOWN : read in just this component from msh files - only these 3 variable types can be read in
#f  elementdata,elementnodedata,elementnodelimiteddata - for CELL centred var : data type when writing this compound (unless gmesh overide is specified) (also same for components with prefix component)
#p  outputcondition,stopcondition,convergencecondition,bellcondition - for CONDITION, type of condition, can have multiple conditions for the one variable
#f  magnitude=value - for EQUATION, UNKNOWN specifies the initial variable magnitude to be used (rather than being based on the initial variable values) - a negative number will cause the magnitude to be set based upon the initial values (which is the default)
#f  dynamicmagnitude/staticmagnitude - for EQUATION, UNKNOWN, adjust magnitude of variable dynamically as the simulation progresses, or keep it constant at the initial magnitude
#f  dynamicmagnitudemultiplier=value - for EQUATION, UNKNOWN, multiplier to use when adjusting magnitude of variable dynamically (=>1.d0, with 1.d0 equivalent to static magnitudes, and large values placing no restriction on the change in magnitude from one newton iteration to the next)
#   clearoptions - remove all previously (to the left and above the clearoptions word) user-specified options for this variable

GENERAL_REPLACEMENTS REPLACE "<<dim3comment>>" WITH "#" # comment out any references to the third dimension in any included files

# variables etc

# and now also letter size, upon which Re is based
NONE_CONSTANT <cylinder size> "nodemax(<nodex[l=2]>,region=<cylinder nodes>)-nodemin(<nodex[l=2]>,region=<cylinder nodes>)"

# use templates from the navier_stokes directory to build up problem
INCLUDE_ROOT "navier_stokes" # this is the base directory that will be appended to the following files
INCLUDE "constants" # specify physical and numerical constants
#INCLUDE "transient_dynamic_setup" # a dynamic timestep to keep the CFL number at a specified level
INCLUDE "transient_constant_setup" # a constant timestep
INCLUDE "domain" # equations to be solved within the domain
INCLUDE "outlet_p_set" # outlet BC
INCLUDE "walls" # nonslip walls BC, used on cylinder
INCLUDE "walls_slip" R "<walls" W "<slip walls" # nonslip walls BC, do string replacement that will cover both equation and region names
INCLUDE "inlet_u_set" # plug flow inlet velocity profile - for inertial problems setting velocity profile directly is more stable than using fully_developed templates

# overwrite the default properties with the following
NONE_CONSTANT <Re> 2.d+2 # this will be based on the cylinder diameter and plug flow velocity
CONSTANT <rho> [1] 1.d0 # density
CONSTANT <u_av> [1] 1.0d0 # average inlet velocity
CONSTANT <mu> [1] "<rho>*<u_av>*<cylinder size>/<Re>" # viscosity of liquid, NB, whole problem is nondimensional

# output a flag telling us which term limited the correction velocity
#FACE_OUTPUT <advection correction limited> "faceif(<u_mf_{adv}>-<u_mf_{vis}>,0.d0,1.d0)" ON <domain faces> # is 1 where advection component is limiting velocity correction
# and turn some outputs on using the generic VARIABLE statement that picks up the last type and centring
VARIABLE <u_f_{correction}> output
VARIABLE <u_f_{raw}> output
VARIABLE <u_f> output
VARIABLE <J_f[l=1]> output
VARIABLE <tau[l=1,1]> output

VARIABLE <p> magnitude=2.d0
VARIABLE <u[l=1]> magnitude=2.d0
VARIABLE <u[l=2]> magnitude=2.d0

# some numerical values
VARIABLE <adv_limiter> 0.d0 # this is the most stable - ie, first order upwinding on momentum advection
CONSTANT <dt_initial> [] 1.d-1 # now taking huge timestep, overwriting the default timestep used in transient_constant_setup which is roughly based on a CFL number

# some monitoring variables
NONE_OUTPUT <centreline inlet p> "facesum(<p_f>,region=<inlet centreline>)"
NONE_OUTPUT <average inlet p> "facesum(<p_f>*<facearea>,region=<inlet>)/facesum(<facearea>,region=<inlet>)"
CELL_OUTPUT <u mag> "sqrt(dot(<u[l=:]>,<u[l=:]>))" ON <all cells>
NONE_OUTPUT <u ave[l=1]> "cellsum(<u[l=1]>*<cellvol>,region=<domain>)/cellsum(<cellvol>,region=<domain>)"
NONE_OUTPUT <u ave[l=2]> "cellsum(<u[l=2]>*<cellvol>,region=<domain>)/cellsum(<cellvol>,region=<domain>)"
NONE_OUTPUT <u mag ave> "cellsum(<u mag>*<cellvol>,region=<domain>)/cellsum(<cellvol>,region=<domain>)"
NONE_OUTPUT <u monitor[l=1]> "cellsum(<u[l=1]>,region=<wake monitor>)"
NONE_OUTPUT <u monitor[l=2]> "cellsum(<u[l=2]>,region=<wake monitor>)"
NONE_OUTPUT <u mag monitor> "cellsum(<u mag>,region=<wake monitor>)"
INCLUDE "u_f_vector" # output u_f as a vector for visualisation
INCLUDE "CFL_number" # this calculates the CFL number actually used

#END # include to only do fluids problem
#-------------------------------------------------------------------
# also track a concentration field, which eminates from the cylinder surface (Dirichlet boundary condition)
INCLUDE_ROOT "species_transport"

# the following implements low order (first order upwind) advection of <c>
#INCLUDE "equations" R "<<speciesloworderadvectioncomment>>" W "" R "<<specieshighorderadvectioncomment>>" W "#"
# the following implements high order limited advection of <c>, with limits on the gradient found from looking upwind 3 levels of separation
INCLUDE "equations" R "<<limiterupwindseparation>>" W "3" # 3 is overboard really, but demonstrates how to change this separation from the default of 2

FACE_EQUATION <c walls> "<c>-1.d0" ON <walls> # <walls> is the cylinder surface, which has the set concentration
FACE_EQUATION <c slip walls> "<c_j_f>" ON <slip walls> # whereas on the <slip walls> we use a zero flux condition
VARIABLE <c_inlet_conc> 0.d0 # nothing coming in
VARIABLE <c_D> 1.d-2 # small, nonzero diffusivities are the hardest to compute accurately using these boundary conditions, as mesh resolution in the concentration boundary layer becomes critical
VARIABLE <c limiter> output
#VARIABLE <c limiter> "0.d0" # low order first order upwind advection employed (remove this line to bring back limited high order advection used in templates files)

# various outlet conditions:
#FACE_EQUATION <c outlet> "faceif(<u_f>,facegrad[adjacentcells](<c>),<c>)" ON <outlet> # boundary condition is zero gradient for outflow, and zero concentration for inflow
FACE_EQUATION <c outlet> "facegrad[adjacentcells](<c>)" ON <outlet> # the most stable type of outlet boundary condition
#FACE_EQUATION <c outlet> "faceif(<u_f>,facegrad(<c>),<c>)" ON <outlet> # boundary condition is zero gradient for outflow, and zero concentration for inflow

# the following can be used as a destruction term
#NONE_CONSTANT <c_source_factor> 0.1d0
#VARIABLE <c_source> "-<c_source_factor>*<c_pos>" # including concentration destruction term now

NONE_OUTPUT <c monitor> "cellsum(<c>,region=<wake monitor>)"

#INCLUDE_ROOT "general"
#INCLUDE "kernel_parameters"
#-------------------------------------------------------------------
# just for the example problem do a few steps only
TIMESTEPOUT 2
#TIMESTEPADDITIONAL 1 # NB, timestepadditional only guarantees than simulation will run an additional number of timesteps, not that it will stop after this number of timesteps
TIMESTEPMAX 4
#-------------------------------------------------------------------
