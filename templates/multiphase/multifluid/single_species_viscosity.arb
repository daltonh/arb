MARKDOWN
Here we find <mu_f_species> for each species
END_MARKDOWN

#REPLACEMENTS D "<<viscosity_method>>" W "einstein"
REPLACEMENTS D "<<viscosity_method>>" W "morrisboulay99"
#REPLACEMENTS D "<<viscosity_method>>" W "thomas65
#REPLACEMENTS D "<<viscosity_method>>" W "quadratic" # for <<stress_method>> = version3
#REPLACEMENTS D "<<viscosity_method>>" W "kriegerdougherty"

INCLUDE "default_replacement_strings"

#REPLACEMENTS D "<<stress_method>>" W "version1" # method, with phi inside viscous stress divergence
REPLACEMENTS D "<<stress_method>>" W "version2" # as per jackson98 and zhang97, have phi outside of stress divergence, version2 default = zhang97 = jackson98 = balls
# in this file jackson98 = version2, zhang97 = balls

IF {{ return string_test('<<stress_method>>','version1') }}
# split stress between phases using the simplest possible consistent partitioning
# here mu is not species specific, so is roughly proportional (or more) to phi
# the multiplier used in the u_f_{correction} calculation is the viscosity/phi, which has a conventional viscosity magnitude as phi -> 0

  IF {{ return string_test('<<species>>','species0') }}
  # for the fluid use a multiplier of mu
    CELL_DERIVED <mu_c_multiplier_<<species>>> [Pa.s] "<mu_species0>" ON <allcells>
  ELSE
  # different functions using this simple partitioning only affect the solid viscosity

    IF {{ return string_test('<<viscosity_method>>','einstein')}}
  # simplest einstein relationship
      CELL_DERIVED <mu_c_multiplier_<<species>>> [Pa.s] "3.5d0*<mu_species0>" ON <allcells>

    ELSE
  # methods that have a maximum total solids magnitude, and can be expressed as a function of total solid volume fraction
      NONE_CONSTANT <mu_phi_max_allsolids> "<phi_max_allsolids>"
      NONE_CONSTANT <mu_phi_tol> "<phi_tol>"
      CELL_DERIVED <mu_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)/<mu_phi_max_allsolids>" output
      CELL_LOCAL <mu_c_multiplier_<<species>>> [Pa.s] "<mu_c_multiplier_allsolids>" ON <allcells>

      IF {{ return string_test('<<viscosity_method>>','morrisboulay99')}}
        NONE_CONSTANT <mu_K_s> 0.1d0
        CELL_DERIVED <mu_c_multiplier_allsolids> [Pa.s] "<mu_species0>*(1.d0+2.5d0/(1.d0-<mu_phi_norm_allsolids>)+<mu_K_s>*<mu_phi_norm_allsolids>/(<mu_phi_max_allsolids>*(1.d0-<mu_phi_norm_allsolids>)**2))" ON <allcells> output
      ELSE_IF {{ return string_test('<<viscosity_method>>','kriegerdougherty')}}
      	NONE_CONSTANT <mu_phi_max_allsolids> "<phi_max_allsolids>"
        NONE_CONSTANT <mu_phi_tol> "<phi_tol>"
        CELL_DERIVED <mu_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)/<mu_phi_max_allsolids>" output # here <mu_phi_max_allsolids> is used to scale across the range
      	NONE_CONSTANT <n> "-2.5d0*<mu_phi_max_allsolids>"
        CELL_DERIVED <mu_c_multiplier_<<species>>> [Pa.s] "<mu_species0>*((1.d0-(1.d0-<mu_phi_norm_allsolids>)**<n>)/(<mu_phi_max_allsolids>*<mu_phi_norm_allsolids>*(1.d0-<mu_phi_norm_allsolids>)**<n>) + 1.d0)" ON <allcells> output

      ELSE
        ERROR "in single_species_viscosity: viscosity_method = <<viscosity_method>> not coded yet or unknown"
      END_IF
    END_IF

  END_IF

  # now construct viscosity and correction viscosity (multiplier) for faces (which tends to a finite value at phi->0 - ie, a non-specific viscosity)
  CELL_LOCAL <mu_c_<<species>>> "<mu_c_multiplier_<<species>>>*<phi_bounded_<<species>>>" ON <allcells> output
  FACE_DERIVED <mu_f_<<species>>> "faceave[harmonic](<mu_c_<<species>>>)" ON <allfaces> output # used in stress
  FACE_DERIVED <mu_f_correction_<<species>>> "faceave[adjacentcells](<mu_c_multiplier_<<species>>>)" ON <allfaces> output # used in rhie-chow

ELSE # version2 or version3 methods, ie, phase specific

  IF {{ return string_test('<<stress_method>>','version3') }}

# no alternative viscosity_methods yet

    IF {{ return string_test('<<species>>','species0') }}
# this should be the viscosity increase within the fluid (same as each solid too) due to the presence of the particles, but without particle particle interactions
# einstein relationship applied to continuous phase, based on total solids present
      CELL_DERIVED <mu_c_<<species>>> [Pa.s] "<mu_species0>*(1.d0+2.5d0*(1.d0-<phi_bounded_<<species>>>))" ON <allcells>
    ELSE
# for each phase the viscosity is made from a single phase (dilute) component and an interaction (collisional) component
# each solution phase made from einstein viscosity, plus collision contributions from each solid phase (including itself)
# the single phase is the same as for the fluid phase
      CELL_DERIVED <mu_c_<<species>>> [Pa.s] "<mu_c_species0>" ON <allcells> # note, einstein relationship based on total solid volume fraction
# now add on collisional contributions, with a term for each possible pair of species interactions
# chose method
# quadratic method, minus the einstein dilute equation leaves a single quadratic coefficient, independent of particle radius
      IF {{ return string_test('<<viscosity_method>>','quadratic')}}
        NONE_CONSTANT <mu^_collision_coefficient2> [1] 6.d0 # 2nd order in phi coefficient for mixture viscosity
        NONE_CONSTANT <mu^_collision_mixture> [Pa.s] "<mu_species0>*<mu^_collision_coefficient2>" # default collision viscosity between two phases which can be overwritten for particular combinations
# calculate collisional viscosity contribution, expressed on a phase specific basis for both phases (ie, mu_collisional => mu^*phi1*phi2)
        {{ my $return_string = '';
          for my $species (string_eval('<<multifluid_disperse_species_list>>','list')) {
            $return_string .= "NONE_CONSTANT <mu^_collision_<<species>>_$species> '<mu^_collision_mixture>'\n";
          }
          return $return_string;
        }}
      ELSE_IF {{ return string_test('<<viscosity_method>>','kriegerdougherty')}}
# kriegerdougherty
        CELL_DERIVED <mu_phi_bounded_allsolids> "1.d0-<phi_bounded_species0>" ON <allcells>
        CELL_LOCAL <mu_phi_max_allsolids> "0.603d0" ON <allcells> # this could be changed to be a function of local phi
        CELL_DERIVED <mu^_collision_mixture> "<mu_species0>*((1.d0-<mu_phi_bounded_allsolids>/<mu_phi_max_allsolids>)**(-2.5d0*<mu_phi_max_allsolids>)-(1.d0+2.5d0*<mu_phi_bounded_allsolids>))/(<mu_phi_bounded_allsolids>**2)" ON <allcells>
# calculate collisional viscosity contribution, expressed on a phase specific basis for both phases (ie, mu_collisional => mu^*phi1*phi2)
        {{ my $return_string = '';
          for my $species (string_eval('<<multifluid_disperse_species_list>>','list')) {
            $return_string .= "CELL_DERIVED <mu^_collision_<<species>>_$species> '<mu^_collision_mixture>' ON <allcells>\n";
          }
          return $return_string;
        }}

      ELSE_IF {{ return string_test('<<viscosity_method>>','morrisboulay99')}}
# morrisboulay99, except for the dilute contribution which is not quite the same
        CELL_DERIVED <mu_phi_bounded_allsolids> "1.d0-<phi_bounded_species0>" ON <allcells>
        CELL_LOCAL <mu_phi_max_allsolids> "0.68d0" ON <allcells> # this could be changed to be a function of local phi
        NONE_CONSTANT <mu_K_s> 0.1d0 # multiplier in single_species_sid_pressure needs to be set correspondingly
        CELL_DERIVED <mu^_collision_mixture> "<mu_species0>*<mu_K_s>/((<mu_phi_max_allsolids>*(1.d0-<mu_phi_bounded_allsolids>/<mu_phi_max_allsolids>))**2)" ON <allcells>

# calculate collisional viscosity contribution, expressed on a phase specific basis for both phases (ie, mu_collisional => mu^*phi1*phi2)
        {{ my $return_string = '';
          for my $species (string_eval('<<multifluid_disperse_species_list>>','list')) {
            $return_string .= "CELL_DERIVED <mu^_collision_<<species>>_$species> '<mu^_collision_mixture>' ON <allcells>\n";
          }
          return $return_string;
        }}

      ELSE
        ERROR "viscosity_method = <<viscosity_method>> not known for stress_method = version3"
      END_IF
# now add collisional contributions, noting that viscosity has been divided by phi_i under stress method 2 and 3
      {{ my $return_string = '';
        for my $species (string_eval('<<multifluid_disperse_species_list>>','list')) {
          $return_string .= "VARIABLE <mu_c_<<species>>> '(<mu_c_<<species>>>)+(<mu^_collision_<<species>>_$species>*<phi_bounded_$species>)'\n";
        }
        return $return_string;
      }}
    END_IF

# in version2 the viscous stress divergence is phase specific, so the viscosity for each phase is roughly a constant as phi -> 0
# the multiplier used in the u_f_{correction} calculation is equal to the viscosity

  ELSE # version2 methods

    IF {{ return string_test('<<species>>','species0') }}
  # define the fluid stress, which is in version2 a mixture stress

      IF {{ return string_test('<<viscosity_method>>','einsteinsingle')}}
  # simplest einstein relationship, for a single phase
        CELL_DERIVED <mu_c_<<species>>> [Pa.s] "<mu_species0>*(1.d0+2.5d0*<phi_bounded_<<species>>>)" ON <allcells>
      ELSE_IF {{ return string_test('<<viscosity_method>>','einstein')}}
  # for more than one solid use fluid phi to calculate total
        CELL_DERIVED <mu_c_<<species>>> [Pa.s] "<mu_species0>*(1.d0+2.5d0*(1.d0-<phi_bounded_species0>))" ON <allcells>
      ELSE
    # methods that have a maximum total solids magnitude, and can be expressed as a function of total solid volume fraction
        NONE_CONSTANT <mu_phi_max_allsolids> "<phi_max_allsolids>"
        NONE_CONSTANT <mu_phi_tol> "<phi_tol>"

        IF {{ return string_test('<<viscosity_method>>','morrisboulay99')}}
          NONE_CONSTANT <mu_K_s> 0.1d0
          CELL_DERIVED <mu_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)/<mu_phi_max_allsolids>" output # here <mu_phi_max_allsolids> is used to scale across the range
          CELL_DERIVED <mu_c_<<species>>> [Pa.s] "<mu_species0>*(1.d0+2.5d0*<mu_phi_norm_allsolids>/(1.d0-<mu_phi_norm_allsolids>)+<mu_K_s>*(<mu_phi_norm_allsolids>/(1.d0-<mu_phi_norm_allsolids>))**2)" ON <allcells> output
        ELSE_IF {{ return string_test('<<viscosity_method>>','kriegerdougherty')}}
          CELL_DERIVED <mu_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)/<mu_phi_max_allsolids>" output # here <mu_phi_max_allsolids> is used to scale across the range
          CELL_DERIVED <mu_c_<<species>>> [Pa.s] "<mu_species0>*((<mu_phi_norm_allsolids>/(1.d0-<mu_phi_norm_allsolids>))**(2.5d0*<mu_phi_max_allsolids>))" ON <allcells> output
        ELSE_IF {{ return string_test('<<viscosity_method>>','thomas65')}}
          CELL_DERIVED <mu_phi_bounded_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)" output # here <mu_phi_max_allsolids> is used as a cut-off
          CELL_DERIVED <mu_c_<<species>>> [Pa.s] "<mu_species0>*(1.d0+2.5d0*<mu_phi_bounded_allsolids>+10.05d0*(<mu_phi_bounded_allsolids>)**2 + 0.00273d0*exp(16.6d0*<mu_phi_bounded_allsolids>))" ON <allcells> output
        ELSE
          ERROR "in single_species_viscosity: viscosity_method = <<viscosity_method>> not coded yet or unknown"
        END_IF
      END_IF

    ELSE
  # for these methods use the same viscosity across phases
      IF {{ return string_test('<<stress_method>>','zhang97') }}
  # only fluid viscosity applied to solid phases, zhang97 = balls
        CELL_DERIVED <mu_c_<<species>>> [Pa.s] "<mu_species0>" ON <allcells> output
      ELSE
  # mixture viscosity applied to all phases, version2 = jackson98
        CELL_LOCAL <mu_c_<<species>>> [Pa.s] "<mu_c_species0>" ON <allcells> output
  # could also do drew76, no viscosity applied to solid phases...
      END_IF

    END_IF

  END_IF

# now construct viscosity on faces for use in stress tensor, as well as viscosity for use in u_f rhiechow interpolation (correction)
# note that for version2 the multiplier is actually just the viscosity - bad notation! - changed to correction viscosity
  FACE_DERIVED <mu_f_<<species>>> "faceave[harmonic](<mu_c_<<species>>>)" ON <allfaces> output # used in stress
  FACE_LOCAL <mu_f_correction_<<species>>> "<mu_f_<<species>>>" ON <allfaces> # used in rhie-chow

END_IF
