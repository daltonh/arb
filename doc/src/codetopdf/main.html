<!-- now starting in code in markdown -->
<pre><code>! file src/main.f90
!
! Copyright 2009-2017 Dalton Harvie (daltonh@unimelb.edu.au)
! 
! This file is part of arb finite volume solver, referred to as `arb&#39;.
! 
! arb is a software package designed to solve arbitrary partial
! differential equations on unstructured meshes using the finite volume
! method.  Primarily it consists of fortran source code, perl source
! code and shell scripts.  arb replies on certain third party software
! to run, most notably the computer algebra system maxima
! &lt;http://maxima.sourceforge.net/&gt; which is released under the GNU GPL.
! 
! The original copyright of arb is held by Dalton Harvie, however the
! project is now under collaborative development.
! 
! arb is released under the GNU GPL.  arb is free software: you can
! redistribute it and/or modify it under the terms of the GNU General
! Public License (version 3) as published by the Free Software Foundation.
! You should have received a copy of the GNU General Public Licence
! along with arb (see file licence/gpl.txt after unpacking).  If not,
! see &lt;http://www.gnu.org/licences/&gt;.
! 
! arb is distributed in the hope that it will be useful, but WITHOUT
! ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
! FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public Licence
! for more details.
! 
! For full details of arb&#39;s licence see the licence directory.
! 
! The current homepage for the arb finite volume solver project is
! &lt;http://people.eng.unimelb.edu.au/daltonh/downloads/arb&gt;.
!
!-------------------------------------------------------------------------
program arb
                  
! written in f90 with object oriented approach, hopefully
! daltonh, 070608

use general_module
use setup_module
use equation_module
use solver_module
use output_module
!$ use omp_lib

implicit none
character(len=1000) :: formatline
integer :: ierror = 0
logical :: newtconverged
logical, parameter :: debug = .true.

!---------------------------------------------------

formatline = &#39;(a,f4.2,a)&#39;
write(*,fmt=formatline) &#39;program arb, version &#39;,version,&#39; (&#39;//trim(versionname)//&#39;), written by dalton harvie&#39;

! find number of threads if openmp is in use
!$omp parallel
!$ nthreads = omp_get_num_threads() 
!$omp end parallel
if (nthreads &gt; 1) then
  formatline = &#39;(a,&#39;//trim(dindexformat(nthreads))//&#39;,a)&#39;
  write(*,fmt=formatline) &#39;INFO: openmp version running, with &#39;,nthreads,&#39; threads in use&#39;
else if (nthreads == 1) then
  write(*,fmt=formatline) &#39;INFO: openmp version running, with 1 thread in use&#39;
else
  write(*,&#39;(a,i2,a)&#39;) &#39;INFO: serial version running&#39;
end if
! now make nthreads = 1 for serial version
nthreads = max(nthreads,1)

call initialise_random_number ! initialise the random seed used to evaluate the arb variable &lt;random&gt;

call time_process
call setup ! sets up variable metadata, reads in values, allocates arrays, creates mesh, initialises fields etc
call time_process(description=&#39;setup&#39;)

! increment timestep if timestepaddional is specified
if (transient_simulation.and.timestepadditional &gt; 0) timestepmin = max(timestepmin,timestep+timestepadditional)

! output initial conditions if transient and this is the first timestep
if (transient_simulation.and.timestep == 0) then
  call time_process
  call output
  if (trim(output_step_file) == &quot;timestep&quot;) call output_step(action=&quot;write&quot;,do_update_outputs=.false.)
  call time_process(description=&#39;initial transient output&#39;)
end if

if (.not.transient_simulation) then
  backline = newtline
  newtline = timeline
end if

!---------------------------------------
time_loop: do while ( &amp;
  (transient_simulation.and..not.check_stopfile(&quot;stoptime&quot;).and.((.not.check_condition(&quot;stop&quot;).and.timestep &lt; timestepmax).or. &amp;
  timestep &lt; timestepmin)).or..not.transient_simulation) 

  newtres = huge(1.d0)

  if (transient_simulation) then
    timestep = timestep + 1
    formatline = &quot;(a,&quot;//trim(dindexformat(timestep))//&quot;,a)&quot;
    write(*,fmt=formatline) repeat(&#39;+&#39;,timeline)//&#39; timestep &#39;,timestep,&#39; starting &#39;//repeat(&#39;+&#39;,totalline-timeline)
    if (convergence_details_file) then
      write(fconverge,fmt=formatline) repeat(&#39;+&#39;,timeline)//&#39; timestep &#39;,timestep,&#39; starting &#39;//repeat(&#39;+&#39;,totalline-timeline)
      call flush(fconverge)
    end if
    call time_process
    call update_and_check_transients(ierror=ierror)
    call time_process(description=&#39;start of timestep update and check transients&#39;)
    if (ierror /= 0) then
      write(*,&#39;(a)&#39;) &#39;ERROR: problem completing update_and_check_transients&#39;
      exit time_loop
    end if
    newtstep = 0  ! only reset this for transient simulations, as may be required to carry-on from old newtstep for steady-state simulations - now resetting is delayed to allow saving in a transient
    if (newtient_simulation) then
      call time_process
      call update_and_check_initial_newtients(ierror=ierror)
      call time_process(description=&#39;start of timestep update and check initial newtients&#39;)
      if (ierror /= 0) then
        write(*,&#39;(a)&#39;) &#39;ERROR: problem completing update_and_check_initial_newtients&#39;
        exit time_loop
      end if
    end if
    call time_process
    call update_and_check_derived_and_equations(ierror=ierror)
    call time_process(description=&#39;start of timestep update and check derived and equations&#39;)
    if (ierror /= 0) then
      write(*,&#39;(a)&#39;) &#39;ERROR: problem completing update_and_check_derived_and_equations&#39;
      exit time_loop
    end if
  end if

  if (trim(output_step_file) == &quot;newtstep&quot;) call output_step(action=&quot;write&quot;)

! dump solution starting point if newtstepout is set to 1 or dumpnewt is found
  if (check_dumpfile(&quot;dumpnewt&quot;).or.newtstepout /= 0) then
    write(*,&#39;(a)&#39;) &#39;INFO: user has requested output via a dump file or newtstepout specification&#39;
    call time_process
    call output(intermediate=.true.)
    call output_step(action=&quot;write&quot;,do_update_outputs=.false.)
    call time_process(description=&#39;output&#39;)
  end if

!--------------------
! newton loop

  newtconverged = .false.
  if (newtres &lt;= newtrestol) newtconverged = .true.
  if (.not.newtconverged) then
    if (check_condition(&quot;convergence&quot;)) newtconverged = .true.
  end if

  newt_loop: do while (((.not.newtconverged.and.newtstep &lt; newtstepmax).or. &amp;
      newtstep &lt; newtstepmin).and.ierror == 0)

    newtstep = newtstep + 1

    formatline = &quot;(a,&quot;//trim(dindexformat(newtstep))//&quot;,a)&quot;
    write(*,fmt=formatline) repeat(&#39;+&#39;,newtline)//&#39; newtstep &#39;,newtstep,&#39; starting &#39;//repeat(&#39;+&#39;,totalline-newtline)
    if (convergence_details_file) then
      write(fconverge,fmt=formatline) repeat(&#39;+&#39;,newtline)//&#39; newtstep &#39;,newtstep,&#39; starting &#39;//repeat(&#39;+&#39;,totalline-newtline)
      call flush(fconverge)
    end if

! calculate and check on the equation magnitudes
    call time_process
    call update_magnitudes(ierror)
    call time_process(description=&#39;start of newtstep calculating variable magnitudes&#39;)
    if (ierror /= 0) then
      write(*,&#39;(a)&#39;) &#39;ERROR: problem completing update_magnitudes&#39;
      exit newt_loop
    end if

! calculate the latest residual, based on the new variable magnitudes
    call time_process
    call residual(ierror=ierror)
    call time_process(description=&#39;start of newtstep calculating residual&#39;)
    if (ierror /= 0) then
      write(*,&#39;(a)&#39;) &#39;ERROR: problem completing residual calculation&#39;
      exit newt_loop
    end if
    write(*,&#39;(a,g10.3,a)&#39;) &quot;INFO: initial newton loop newtres = &quot;,newtres,&quot; after updating variable magnitudes&quot;
    if (convergence_details_file) write(fconverge,&#39;(a,g16.9,a)&#39;) &amp;
      &quot;INFO: initial newton loop newtres = &quot;,newtres,&quot; after updating variable magnitudes&quot;

    if (newtconverged.and.newtstep &gt; newtstepmin) then
      write(*,&#39;(a,g10.3,a)&#39;) &quot;INFO: skipping newtsolver as newtres/newtrestol = &quot;,newtres/newtrestol,&quot; using existing unknowns&quot;
      if (convergence_details_file) write(fconverge,&#39;(a,g10.3,a)&#39;) &quot;INFO: skipping newtsolver as newtres/newtrestol = &quot;, &amp;
        newtres/newtrestol,&quot; using existing unknowns&quot;
    else if (ptotal == 0) then
      write(*,&#39;(a)&#39;) &#39;INFO: skipping newtsolver as no equations are being solved&#39;
      if (convergence_details_file) write(fconverge,&#39;(a)&#39;) &#39;INFO: skipping netsolver as no equations are being solved&#39;
    else
      call newtsolver(ierror) ! uses newton&#39;s method to solve equations - assumes update has been done and that there is valid magnitudes and a newtres
    end if

! if there is a problem in the newton loop (including a stop file prior to convergence), then exit newton loop here
    if (ierror /= 0) then
      write(*,&#39;(a)&#39;) &#39;ERROR: problem completing newtsolver&#39;
      exit newt_loop
    end if

! update any newtient variables if this is a newtient simulation
    if (newtient_simulation) then
      formatline = &quot;(a,&quot;//trim(dindexformat(newtstep))//&quot;,a,g10.3,a,g10.3)&quot;
      write(*,fmt=formatline) &#39;INFO: during newton loop before newtient updates: newtstep = &#39;,newtstep,&#39;: newtres = &#39;,newtres, &amp;
        &#39;: newtres/newtrestol = &#39;,newtres/newtrestol
      if (convergence_details_file) then
        formatline = &quot;(a,&quot;//trim(dindexformat(newtstep))//&quot;,a,g16.9,a,g10.3)&quot;
        write(fconverge,fmt=formatline) &amp;
          &#39;INFO: during newton loop before newtient updates: newtstep = &#39;,newtstep,&#39;: newtres = &#39;,newtres, &amp;
          &#39;: newtres/newtrestol = &#39;,newtres/newtrestol
      end if
      call time_process
      call update_and_check_newtients(ierror=ierror)
      call time_process(description=&#39;intermediate newton step update and check newtients&#39;)
      if (ierror /= 0) then
        write(*,&#39;(a)&#39;) &#39;ERROR: problem completing update_and_check_newtients in newtient update section&#39;
        exit newt_loop
      end if
      call time_process
      call update_and_check_derived_and_equations(ierror=ierror)
      call time_process(description=&#39;intermediate newton step update and check derived and equations after newtient update&#39;)
      if (ierror /= 0) then
        write(*,&#39;(a)&#39;) &#39;ERROR: problem completing update_and_check_derived_and_equations in newtient update section&#39;
        exit newt_loop
      end if
      call residual(ierror=ierror)
      if (ierror /= 0) then
        write(*,&#39;(a)&#39;) &#39;ERROR: problem calculating residual in newtient update section&#39;
        exit newt_loop
      end if
    end if

    if (trim(output_step_file) == &quot;newtstep&quot;) call output_step(action=&quot;write&quot;)

! also start writing output files is newtstep &gt;= newtstepdebugout

    if (check_dumpfile(&quot;dumpnewt&quot;).or.(newtstepout /= 0.and.mod(newtstep,max(newtstepout,1)) == 0).or.newtstep &gt;= newtstepdebugout) then
      write(*,&#39;(a)&#39;) &#39;INFO: user has requested output via a dump file or newtstepout specification&#39;
      call time_process
      call output(intermediate=.true.)
      call output_step(action=&quot;write&quot;,do_update_outputs=.false.)
      call time_process(description=&#39;output&#39;)
    end if

    if (transient_simulation) then
      formatline = &quot;(a,&quot;//trim(dindexformat(newtstep))//&quot;,a,&quot;//trim(dindexformat(timestep))//&quot;,a,g10.3,a,g10.3)&quot;
      write(*,fmt=formatline) &#39;INFO: during newton loop: newtstep = &#39;,newtstep,&#39;: timestep = &#39;,timestep,&#39;: newtres = &#39;,newtres, &amp;
        &#39;: newtres/newtrestol = &#39;,newtres/newtrestol
      if (convergence_details_file) then
        formatline = &quot;(a,&quot;//trim(dindexformat(newtstep))//&quot;,a,&quot;//trim(dindexformat(timestep))//&quot;,a,g16.9,a,g10.3)&quot;
        write(fconverge,fmt=formatline) &amp;
          &#39;INFO: during newton loop: newtstep = &#39;,newtstep,&#39;: timestep = &#39;,timestep,&#39;: newtres = &#39;,newtres, &amp;
          &#39;: newtres/newtrestol = &#39;,newtres/newtrestol
      end if
    else
      formatline = &quot;(a,&quot;//trim(dindexformat(newtstep))//&quot;,a,g10.3,a,g10.3)&quot;
      write(*,fmt=formatline) &#39;INFO: during newton loop: newtstep = &#39;,newtstep,&#39;: newtres = &#39;,newtres,&#39;: newtres/newtrestol = &#39;, &amp;
        newtres/newtrestol
      if (convergence_details_file) then
        formatline = &quot;(a,&quot;//trim(dindexformat(newtstep))//&quot;,a,g16.9,a,g10.3)&quot;
        write(fconverge,fmt=formatline) &amp;
          &#39;INFO: during newton loop: newtstep = &#39;,newtstep,&#39;: newtres = &#39;,newtres,&#39;: newtres/newtrestol = &#39;,newtres/newtrestol
      end if
    end if
    if (convergence_details_file) call flush(fconverge)

! check whether solution is converged
    if (newtres &lt;= newtrestol) newtconverged = .true.
    if (.not.newtconverged) then
      if (check_condition(&quot;convergence&quot;)) newtconverged = .true.
    end if

! only check for stopfile if output isn&#39;t converged
    if (.not.newtconverged) then
      if (check_stopfile(&quot;stopnewt&quot;)) then
        write(*,&#39;(a)&#39;) &#39;INFO: user has requested simulation stop via a stop file&#39;
        ierror = -1 ! negative ierror indicates that user stopped arb before convergence complete
      end if
    end if

    formatline = &quot;(a,&quot;//trim(dindexformat(newtstep))//&quot;,a)&quot;
    write(*,fmt=formatline) repeat(&#39;-&#39;,newtline)//&#39; newtstep &#39;,newtstep,&#39; ending &#39;//repeat(&#39;-&#39;,totalline-newtline+2)
    if (convergence_details_file) then
      write(fconverge,fmt=formatline) repeat(&#39;-&#39;,newtline)//&#39; newtstep &#39;,newtstep,&#39; ending &#39;//repeat(&#39;-&#39;,totalline-newtline+2)
      call flush(fconverge)
    end if

  end do newt_loop
!--------------------

  if (ierror &gt; 0) then
    formatline = &quot;(a,&quot;//trim(dindexformat(ierror))//&quot;)&quot;
    write(*,fmt=formatline) &#39;ERROR: problem in some solution routine within newton loop: error number = &#39;,ierror
    exit time_loop
  else if (ierror &lt; 0) then
    write(*,&#39;(a)&#39;) &#39;ERROR: newton solver did not converge due to user created stop file&#39;
    exit time_loop
  else if (newtconverged) then
    if (newtres &lt;= newtrestol) then
      write(*,&#39;(a)&#39;) &#39;INFO: newton iterations have converged due to newtres condition&#39;
    else
      write(*,&#39;(a)&#39;) &amp;
        &#39;INFO: user-specified newton loop convergence condition satisfied&#39;
    end if
  else
    write(*,&#39;(a)&#39;) &#39;ERROR: newton solver did not converge&#39;
    ierror = 5
    exit time_loop
  end if

! if user has requested to halt then write message
  if (transient_simulation.and.check_stopfile(&quot;stoptime&quot;)) write(*,&#39;(a)&#39;) &amp;
    &#39;INFO: user has requested simulation stop via a stop file&#39;

! silly bell functionality!
  if (check_condition(&quot;bell&quot;)) call ring_bell

! write output if output is due, or we are finishing
  if ((transient_simulation.and.(check_condition(&quot;output&quot;).or.(timestepout /= 0.and.mod(timestep,max(timestepout,1)) == 0).or. &amp;
    check_condition(&quot;stop&quot;).or.timestep &gt;= timestepmax.or.check_stopfile(&quot;stoptime&quot;).or.check_dumpfile(&quot;dumptime&quot;))).or. &amp;
    .not.transient_simulation) then
    if (check_dumpfile(&quot;dumptime&quot;)) write(*,&#39;(a)&#39;) &#39;INFO: user has requested output via a dump file&#39;
    call time_process
    if (output_timings.and.output_timings_on_mesh_write.and.(timestepout /= 0.and.mod(timestep,max(timestepout,1)) == 0)) &amp;
      write(*,&#39;(2(a,g10.3))&#39;) &#39;TIMING: total wall time = &#39;,total_wall_time,&#39;: total cpu time = &#39;,total_cpu_time  
    call output
    if (trim(output_step_file) == &quot;timestep&quot;) call output_step(action=&quot;write&quot;,do_update_outputs=.false.)
    call time_process(description=&#39;output&#39;)
  else
    if (trim(output_step_file) == &quot;timestep&quot;) call output_step(action=&quot;write&quot;)
  end if

  if (transient_simulation) then
    formatline = &quot;(a,&quot;//trim(dindexformat(timestep))//&quot;,a)&quot;
    write(*,fmt=formatline) repeat(&#39;-&#39;,timeline)//&#39; timestep &#39;,timestep,&#39; ending &#39;//repeat(&#39;-&#39;,totalline-timeline+2)
     
    if (convergence_details_file) then
      write(fconverge,fmt=formatline) repeat(&#39;-&#39;,timeline)//&#39; timestep &#39;,timestep,&#39; ending &#39;//repeat(&#39;-&#39;,totalline-timeline+2)
      call flush(fconverge)
    end if
  end if

! if not a transient simulation then exit loop
  if (.not.transient_simulation) exit time_loop

end do time_loop
!---------------------------------------

if (trim(output_step_file) == &quot;final&quot;) call output_step(action=&quot;write&quot;)

if (output_timings) write(*,&#39;(2(a,g10.3))&#39;) &#39;TIMING: total wall time = &#39;,total_wall_time,&#39;: total cpu time = &#39;,total_cpu_time

! if there was an error or earlier stop requested then exit without closing timestep
if (ierror /= 0) then
  write(*,&#39;(a)&#39;) &quot;WARNING: the last output is not converged&quot;
  write(*,&#39;(a)&#39;) &#39;INFO: a debug output file (debug.output.msh) is being written that contains the current values of &#39;// &amp;
    &#39;all variable components&#39;
  call output(debug_dump=.true.)
  if (trim(output_step_file) == &quot;timestep&quot;) call output_step(action=&quot;write&quot;,do_update_outputs=.false.)
  write(*,&#39;(a)&#39;) &quot;ERROR: the simulation was not successful&quot;
else
  write(*,&#39;(a)&#39;) &quot;SUCCESS: the simulation finished gracefully&quot;
end if

if (convergence_details_file) close(fconverge)
call output_step(action=&quot;close&quot;)

if (ierror /= 0) call exit(ierror) ! exit while setting ierror as exit status

end program arb

!-----------------------------------------------------------------
</code></pre>
<!-- now finishing in code in markdown -->




