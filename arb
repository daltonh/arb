#!/bin/bash
#
# file arb
#
# Copyright 2009-2014 Dalton Harvie (daltonh@unimelb.edu.au)
# 
# This file is part of arb finite volume solver, referred to as `arb'.
# 
# arb is a software package designed to solve arbitrary partial
# differential equations on unstructured meshes using the finite volume
# method.  Primarily it consists of fortran source code, perl source
# code and shell scripts.  arb replies on certain third party software
# to run, most notably the computer algebra system maxima
# <http://maxima.sourceforge.net/> which is released under the GNU GPL.
# 
# The copyright of arb is held by Dalton Harvie.
# 
# arb is released under the GNU GPL.  arb is free software: you can
# redistribute it and/or modify it under the terms of the GNU General
# Public License (version 3) as published by the Free Software Foundation.
# You should have received a copy of the GNU General Public Licence
# along with arb (see file licence/gpl.txt after unpacking).  If not,
# see <http://www.gnu.org/licences/>.
# 
# arb is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public Licence
# for more details.
# 
# For full details of arb's licence see the licence directory.
# 
# The current homepage for the arb finite volume solver project is
# <http://people.eng.unimelb.edu.au/daltonh/downloads/arb>.
#
#-------------------------------------------------------------------------
#
# a wrapper script to compile and run arb
# daltonh, 9/10/10 (modified from a much older script though)
#
# possible options:
# -q or --quiet: save screen output of run
# --compile: compile before running
# -c or --continue: continue on from previous run by not deleting output files
# -d or --debug: compile with debug option and run using debugger
# NB: don't -mix options, ie do -q -b rather than -qb
# NB: many more options now - see below
#
# examples:
# ./arb --quiet --no-compile: runs arb without compiling and sends output to output/output.scr
# ./arb --continue : creates fortran, compiles arb, runs arb continuing from previous run
#
# exit status:
# 0: successful
# 1: failed
# 
#-------------------------------------------------------------------------------
# usage function
usage () {
  echo
  echo "HELP/USAGE: ./arb [options] [input_file1.arb [input_file2.arb]]";
  echo
  echo "If no input files are specified on the command line, then any .arb files, and failing that, any .in files,";
  echo "    in the working directory are used";
  echo
  echo "Possible options:";
  echo "  --clean: remove previous meta-programming and object files";
  echo "  --clean-compile: remove previous object files";
  echo "  --clean-setup: remove previous meta-programming files";
  echo "  --setup: perform meta-programming (default)";
  echo "  --no-setup: don't perform meta-programming despite changes to the arb input files";
  echo "              (ie, reuse previous equation_module.f90)";
  echo "  --compile: compile fortran executable (default)";
  echo "  --no-compile: don't compile fortran executable";
  echo "  --run: run the program (default)";
  echo "  --no-run: don't run the program";
  echo "  -q|--quiet: send arb screen output to output/output.scr";
  echo "  --quiet-make: send screen output of make command to output/output_make.scr";
  echo "  -c|--continue: do not delete previous output files (used when continuing on from a previous run)";
  echo "  -d|--debug: compile fortran using debug options and start executable within a debugging environment";
  echo "  --omp: compile fortran using open mp, and use default (maximum) number of processors";
  echo "  --ompN: compile fortran using open mp and specify N processors to use";
  echo "  --ilp|--long-integer: compile with long integer support (ifort only)";
  echo "  -O|--opt: turn on compiler optimsation level 2";
  echo "  -O0|--no-opt: turn off compiler optimsation";
  echo "  -ON|--optN: turn on compiler optimsation level N";
  echo "  --compiler-gnu: use the gnu gfortran compiler (default if ifort isn't available)";
  echo "  --compiler-intel: use the intel ifort compiler (default if ifort is available)";
  echo "  --debugger-gnu: use the gnu debugger (default for ifort)";
  echo "  --debugger-intel: use the intel debugger (default for gfortran)";
  echo "  --no-pardiso: do not link in the native pardiso routines, allowing the intel pardiso routines to be used instead";
  echo "  --no-suitesparse: do not download the fortran 90 suitesparse interface or link in the packaged suitesparse routines";
# echo "  --externals|-e: incorporate the following user fortran external file into the equation_module";
  echo "  --help|-h: display this HELP INFO";
  echo;
  exit 1;
}
#-------------------------------------------------------------------------------
# announce our arrival
echo "arb finite volume solver wrapper script, Copyright Dalton Harvie (see licence directory)"
echo
echo "INFO: for usage options, try ./arb --help"

# initial setup
# define some commands to avoid path problems
RM='rm -f';
MV='mv';
CP='cp -p';
CAT='cat';
AOUT=build/arb;
DEBUGGER=default; # this will default to the debugger that matches the compiler, unless set here explicitly (gdb or idb)
#DEBUGGER=gdb; # set gnu debugger explicitly
#DEBUGGER=idb; # set intel debugger explicitly
VALGRIND=valgrind;
FILE_SEPARATOR="##################################################################################"

# location of ooc temp files for out of core intel pardiso solver
MKL_PARDISO_OOC_DIR=tmp/intel_pardiso_ooc
MKL_PARDISO_OOC_PATH=$MKL_PARDISO_OOC_DIR/intel_pardiso_ooc

# environment variables that specify the location of files for the native pardiso solver
PARDISO_LIC_PATH=src/contributed/pardiso
LD_LIBRARY_PATH="$LD_LIBRARY_PATH:src/contributed/pardiso"
DYLD_LIBRARY_PATH="$DYLD_LIBRARY_PATH:src/contributed/pardiso"

# location where previously run output files will be stored
PREVIOUS_RUN=output/previous

#-------------------------------------------------------------------------------
# loop through options and set flags to say what has to be done

OCLEAN=0;
OCLEANCOMPILE=0;
OCLEANSETUP=0;
OSETUP=1;
OQUIETMAKE=0;
OCOMPILE=1;
ORUN=1;
OQUIET=0;
OCONTINUE=0;
ODEBUG=0;
OVALGRIND=0;
OOMP=0; # 0 means no omp, 1 means compile with omp support
OOPT=1; # default is optimsation level 1
OILP="off";
OPARDISO="present";
OSUITESPARSE="present";
COMPILER="default";
unset ARBFILES; # the input files that will be passed to setup_equations.pl - unset array first
unset EXTERNALS; # a list of external fortran files that will be included in equation_module.f90
EXTERNALS=( `ls src/*_functions.f90 2> /dev/null` ); # all functions files within the src directory get included by default

for i in $*
do
  case $i in
    "--clean") OCLEAN=1;;
    "--clean-compile") OCLEANCOMPILE=1;;
    "--clean-setup") OCLEANSETUP=1;;
    "--setup") OSETUP=1;;
    "--no-setup") OSETUP=0;;
    "--compile") OCOMPILE=1;;
    "--no-compile") OCOMPILE=0;;
    "--run") ORUN=1;;
    "--no-run") ORUN=0;;
    "-qq") OQUIET=1; OQUIETMAKE=1;;
    "--quiet-make"|"-qm") OQUIETMAKE=1;;
    "-q"|"--quiet") OQUIET=1;;
    "-c"|"--continue") OCONTINUE=1;;
    "-d"|"--debug") ODEBUG=1; OVALGRIND=0;; # ODEBUG specified whether code is compiled with debugging options (including -g), while OVALGRIND specifies how the code will be executed (either using gdb or valgrind)
    "--valgrind") ODEBUG=1; OVALGRIND=1;;
    "--compiler-gnu") COMPILER="gnu";;
    "--compiler-intel") COMPILER="intel";;
    "--debugger-gnu") DEBUGGER="gdb";;
    "--debugger-intel") DEBUGGER="idb";;
    "--no-pardiso") OPARDISO="not present";;
    "--no-suitesparse") OSUITESPARSE="not present";;
    "--omp") OOMP=1; unset OMP_NUM_THREADS;;
#   "--omp") OOMP=1;;
#   "--omp"*) OOMP=1; export OMP_NUM_THREADS=${i:5};; # this extracts from character position 6 and onwards (NB ${i:6:10} would extract characters 7 -> 10 or thereabouts)
    "--omp"*) OOMP=1; export OMP_NUM_THREADS=${i:5}; export MKL_NUM_THREADS=${i:5};; # this extracts from character position 6 and onwards (NB ${i:6:10} would extract characters 7 -> 10 or thereabouts)
    "-O"|"--opt") OOPT=2;; # if requested with no level, optimisation level is 2
    "--ilp"|"--long-integer") OILP="on";;
    "--no-opt") OOPT=0;; # this is optimisation turned off
    "-O"?) OOPT=${i:2};;
    "--opt"?) OOPT=${i:5};;
    "--help"|"-h") usage;;
# TODO - additional external
#   "--externals*".") echo "INFO: found arb input file $i"; ARBFILES[${#ARBFILES[@]}]=$i;;
    "--"*|"-"*) echo "ERROR: unknown option $i passed to arb"; usage;;
    *".arb"|*".in") echo "INFO: found arb input file $i"; ARBFILES[${#ARBFILES[@]}]=$i;;
    *) echo "ERROR: unknown command line entry $i"; usage;;
  esac
done ;

# annouce options
echo "INFO: script run with options: clean=$OCLEAN, clean-setup=$OCLEANSETUP, clean-compile=$OCLEANCOMPILE, setup=$OSETUP, compile=$OCOMPILE, run=$ORUN, quiet=$OQUIET, continue=$OCONTINUE, debug=$ODEBUG, valgrind=$OVALGRIND, compiler=$COMPILER, omp=$OOMP, opt=$OOPT, quietmake=$OQUIETMAKE";
if [ -n "${OMP_NUM_THREADS}" ] ; then echo "INFO: arb running with $OMP_NUM_THREADS omp threads" ; fi ;

# check for input files.  If none have been set, then use any *.arb files that exist in the working directory, and failing that, any *.in files
if [ -z "${ARBFILES[0]}" ] ; then ARBFILES=( `ls *.arb 2> /dev/null` ); fi ;
if [ -z "${ARBFILES[0]}" ] ; then ARBFILES=( `ls *.in 2> /dev/null` ); fi ;
echo "INFO: arb input files to be used: ${ARBFILES[@]}" ;
# construct root_input.arb file which consists of include statements to the user's input files, in the order that they are given to this script
$RM build/root_input.arb >/dev/null 2>/dev/null ;
echo "# root_input.arb file created by the arb script" >build/root_input.arb ;
echo $FILE_SEPARATOR >>build/root_input.arb ;
# cycle through each external file including them in the root_input, so that setup_equations can decide whether they are required, and if so, whether they have changed since previously
echo "# the following external fortran files were found by the arb script and are available for inclusion: ${EXTERNALS[@]}" >>build/root_input.arb;
for FILE in "${EXTERNALS[@]}" ; do
  if [ ! -e "$FILE" ] ; then echo "ERROR: the external fortran file $FILE does not exist"; exit 1; fi;
  echo "EXTERNALS \"$FILE\"" >>build/root_input.arb ;
done
echo $FILE_SEPARATOR >>build/root_input.arb ;
echo "# the following working directory files found by the arb script: ${ARBFILES[@]}" >>build/root_input.arb ;
for FILE in "${ARBFILES[@]}" ; do
  if [[ $FILE == *'.in' ]]; then echo "WARNING: the 'in' suffix on arb input files has been depreciated.  For future compatibility replace the suffix on $FILE with 'arb'."; fi
  echo "INCLUDE_WORKING \"$FILE\"" >>build/root_input.arb ;
  echo $FILE_SEPARATOR >>build/root_input.arb ;
done

echo "INFO: the file build/root_input.arb has been created" ;

# export any variables that are required upstream, just in case they haven't been before
# OSTYPE and MACHTYPE are now set directly within make using uname output
export MKL_PARDISO_OOC_PATH
export MKL_HOME
export MKLROOT
export PARDISO_LIC_PATH
export LD_LIBRARY_PATH
export DYLD_LIBRARY_PATH
echo "DYLD_LIBRARY_PATH = $DYLD_LIBRARY_PATH"
echo "OMP_NUM_THREADS = $OMP_NUM_THREADS"

# create output directory if it doesn't already exist
if [ ! -d output ] ; then mkdir output ; fi ;
# always keep copy of previous output
if [ ! -d $PREVIOUS_RUN ] ; then mkdir -p $PREVIOUS_RUN ; fi ;
$RM $PREVIOUS_RUN/* >/dev/null 2>/dev/null ;
# delete other output, debug and communication files always, quietly
for i in fort.* output/debug*.msh output/*_warnings.txt output/*_details.txt kill stop stopback stopnewt stoptime halt dump dumpnewt dumptime
do
  $RM $i >/dev/null 2>/dev/null ;
done ;
# place old output and gmsh files in previous_run directory that are needed to restart the run
if [ $OCONTINUE -eq 0 ] ; then
  $MV output/output*.txt $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  $MV output/output*.csv $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  $MV output/output*.scr $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  $MV output/output*.stat $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  $MV output/*.msh $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  $MV output/*.vtk $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  $MV output/*.dat $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
else
  $CP -R output/output*.txt $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  $CP -R output/output*.csv $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  $CP -R output/output*.scr $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  $CP -R output/output*.stat $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  $CP -R output/*.msh $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  $CP -R output/*.vtk $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  $CP -R output/*.dat $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
fi ;

# create intel pardiso ooc temp directory and clear its contents
if [ ! -d $MKL_PARDISO_OOC_DIR ] ; then mkdir -p $MKL_PARDISO_OOC_DIR ; fi ;
$RM $MKL_PARDISO_OOC_DIR/* >/dev/null 2>/dev/null ;

# move to build directory
cd build

# setup destination for make output
MAKEOUTPUT=""; # to terminal
if [ $OQUIETMAKE -eq 1 ] ; then
  MAKEOUTPUT=">>../output/output_make.scr 2>>../output/output_make.scr"; # to file
fi

# do clean operations first
if [ $OCLEAN -eq 1 ] ; then
# do a complete clean if requested
  eval make compiler=$COMPILER clean $MAKEOUTPUT; # eval is necessary so that MAKEOUTPUT is as typed in, not an extra argument to make
  if [ "$?" -ne 0 ] ; then
    echo "ERROR: problem cleaning files from the build directory" ;
    cd ..
    exit 1 ;
  fi ;
else
  if [ $OCLEANSETUP -eq 1 ] ; then
    eval make compiler=$COMPILER clean_setup $MAKEOUTPUT;
    if [ "$?" -ne 0 ] ; then
      echo "ERROR: problem cleaning setup files from the build directory" ;
      cd ..
      exit 1 ;
    fi ;
  fi ;
  if [ $OCLEANCOMPILE -eq 1 ] ; then
    eval make compiler=$COMPILER clean_compile $MAKEOUTPUT;
    if [ "$?" -ne 0 ] ; then
      echo "ERROR: problem cleaning compilation files from the build directory" ;
      cd ..
      exit 1 ;
    fi ;
  fi
fi


# compile if necessary, checking that options used last time are consistent with this time
if [ $OCOMPILE -eq 1 -o $OSETUP -eq 1 ] ; then

  echo "INFO: compiling or setting up the arb executable"

# if compilation is required then need to find compiler
  if [ $OCOMPILE -eq 1 ] ; then
  # try intel compiler first
    if [ $COMPILER = "intel" -o $COMPILER = "default" ] ; then
      if which ifort >/dev/null 2>/dev/null ; then
        echo "INFO: found intel compiler at `which ifort`";
        COMPILER="intel";
  # find version of intel compiler
        INTEL_VERSION=`ifort -v 2>&1`; # this should give us the version as 'ifort version 12.1.2' say - NB, this is output to stderr, so we redirect this to stdout
        INTEL_VERSION=${INTEL_VERSION#ifort version }; # remove shortest string from the front giving '12.1.2'
        INTEL_VERSION=${INTEL_VERSION#Version }; # format for version 11 was slightly different to versions 12 and 13 (thanks intel!)
        INTEL_VERSION=${INTEL_VERSION%%.*}; # remove longest string from the back giving '12' or '11' or '13'
        if [ "${#INTEL_VERSION}" -gt 2 -o "${#INTEL_VERSION}" -lt 1 ] ; then
          echo "INFO: intel compiler version incorrectly identified as |$INTEL_VERSION|";
          echo "INFO: length of intel compiler ${#INTEL_VERSION}";
          echo "WARNING: set the variable intel_version manually in the makefile to be consistent with the output of 'ifort -v'";
          unset INTEL_VERSION
        else
          echo "INFO: intel compiler version identified as $INTEL_VERSION";
        fi
      else
        if [ $COMPILER = "intel" ] ; then
          echo "ERROR: requested intel compiler is not in the path" ;
          cd ..;
          exit 1;
        fi
      fi
    fi
  # try gnu compiler second
    if [ $COMPILER = "gnu" -o $COMPILER = "default" ] ; then
      if which gfortran >/dev/null 2>/dev/null; then
        echo "INFO: found gfortran compiler at `which gfortran`";
        COMPILER="gnu";
      else
        if [ $COMPILER = "gnu" ] ; then
          echo "ERROR: requested gnu compiler is not in the path" ;
          cd ..;
          exit 1;
        fi
      fi
    fi
  # if nothing is found 
    if [ $COMPILER = "default" ] ; then
      echo "ERROR: no compiler is present";
      cd ..;
      exit 1;
    elif [ ! $COMPILER = "intel" -a ! $COMPILER = "gnu" ] ; then
      echo "ERROR: unknown requested compiler $COMPILER";
      cd ..;
      exit 1;
    fi

    if [ ! $COMPILER = "intel" ] ; then
      OILP="off"; # long integers only implemented for ifort right now
    fi

  # check to see what compiler was used last time, and if different, make clean
  # check to see whether debugging was used last time, and if different, make clean
  # check to see whether open mp was used last time, and if different, make clean
    if [ ! -e last_compiler_was_$COMPILER -o ! -e last_compile_had_debugging_$ODEBUG -o ! -e last_compile_had_omp_$OOMP -o ! -e last_compile_had_opt_$OOPT -o ! -e last_compile_had_ilp_$OILP ] ; then
      echo "INFO: cleaning of compilation files required as compile options different from previous run";
      eval make compiler=$COMPILER clean_compile $MAKEOUTPUT;
      if [ "$?" -ne 0 ] ; then
        echo "ERROR: problem cleaning compilation files from the build directory due to different compilation options" ;
        cd ..
        exit 1 ;
      fi ;
    fi

  # record options used this time
    touch last_compiler_was_$COMPILER ;
    touch last_compile_had_debugging_$ODEBUG ;
    touch last_compile_had_omp_$OOMP ;
    touch last_compile_had_opt_$OOPT ;
    touch last_compile_had_ilp_$OILP ;

  fi

# assemble makeline and make
  MAKELINE="make opt=$OOPT ilp=$OILP pardiso_from_arb=\"$OPARDISO\" suitesparse_from_arb=\"$OSUITESPARSE\"";
# MAKELINE="make opt=$OOPT ilp=$OILP";
  if [ $OSETUP -eq 0 ] ; then
    MAKELINE="$MAKELINE compile_only" ;
  else
    if which maxima >/dev/null ; then
      echo "INFO: found maxima at `which maxima`";
    else
      echo "ERROR: maxima is not in the path - is it installed?" ;
      cd ..;
      exit 1;
    fi
    if [ $OCOMPILE -eq 0 ] ; then
      MAKELINE="$MAKELINE setup_only" ;
    fi ;
  fi ;
  if [ $ODEBUG -eq 1 ] ; then MAKELINE="$MAKELINE debug=on" ; fi ;
  if [ $OOMP -eq 1 ] ; then MAKELINE="$MAKELINE omp=on" ; fi ; # if omp is greater than 1 then use open mp
  if [ -n "${INTEL_VERSION}" ] ; then MAKELINE="$MAKELINE intel_version=$INTEL_VERSION" ; fi ;

# echo "MAKELINE = $MAKELINE";

  MAKELINE="$MAKELINE compiler=$COMPILER $MAKEOUTPUT";
  echo "INFO: running make using commands: $MAKELINE";
  eval $MAKELINE;

  if [ "$?" -ne 0 ] ; then
    echo "ERROR: problem compiling/settting up arb" ;
    cd ..
    exit 1 ;
  else
    echo "INFO: arb make/setup successful" ;
  fi ;
fi ;

# move back to working directory
cd ..

# finally run program
if [ $ORUN -eq 1 ] ; then

  echo "INFO: running arb executable"

  if [ ! -e $AOUT ] ; then
    echo "ERROR: arb executable does not exist" ;
    exit 1 ;
  fi

  if [ $OQUIET -eq 1 ] ; then
    RUNOUTPUT=">>output/output.scr 2>>output/output.scr";
  else
    RUNOUTPUT="";
    echo
  fi

  if [ $ODEBUG -eq 1 ] ; then
    if [ $OVALGRIND -eq 1 ] ; then
      DEBUGGER=${VALGRIND}; # if valgrind is on then just change DEBUGGER executable to VALGRIND
    elif [ $DEBUGGER = "default" ]; then
      if [ $COMPILER = "gnu" ] ; then # if DEBUGGER is not explicitly set, set it to be consistent with the compiler
        DEBUGGER="gdb";
      else
        DEBUGGER="idb";
      fi;
    fi
    if which $DEBUGGER >/dev/null ; then
      echo "INFO: found $DEBUGGER at `which $DEBUGGER`";
    else
      echo "ERROR: $DEBUGGER is not in the path - is it installed?" ;
      exit 1;
    fi
    eval $DEBUGGER $AOUT $RUNOUTPUT;
  else
    eval $AOUT $RUNOUTPUT;
  fi ;
  echo "INFO: finishing running arb";
fi ;

exit 0 ;

# done
#-------------------------------------------------------------------------------
