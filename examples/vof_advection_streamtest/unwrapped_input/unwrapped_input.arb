# root_input.arb file created by the arb script
##################################################################################
# the following external fortran files were found by the arb script and are available for inclusion: src/free_surface_functions.f90
EXTERNALS "src/free_surface_functions.f90"
##################################################################################
# the following working directory files found by the arb script: vof_advection_streamtest.arb
#INCLUDE_WORKING "vof_advection_streamtest.arb"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../vof_advection_streamtest.arb without any search/replace combinations
VERSION 0.42

# simulation information
INFO_TITLE "VOF advection test 1 (uniform velocity) from the stream paper"
INFO_TITLE+ ": u=(2,1)"
INFO_TITLE+ ": circle"
INFO_AUTHOR "Dalton Harvie"
INFO_DATE "22/4/14"
INFO_VERSION "4"
INFO_DESCRIPTION "Does a linear advection test in line with that presented in DOI:10.1006/jcph.2000.6510, which itself is based on tests by Rudman and other workers"

#-------------------------------------------------------------------
# user-defined constants

#KERNEL_OPTIONS polynomialorder=2,polynomialaverageorder=2,polynomialcellorder=2

#GENERAL_REPLACEMENTS REPLACE "<<dim3comment>>" WITH "#" # comment out any references to the third dimension in any included files

TIMESTEPMAX 5 # just compute 5 timesteps

# this should be a square box of sidelength 4 and origin at (0,0)
MSH_FILE "box.msh"
#MSH_FILE "box_unstructured.msh"

NONE_CONSTANT <phi_initial_tol> 1.d-3
# the cellvofphishape function takes two vectors, a size and centre, returning a volume fraction for each cell
# the size of the object is determined by the maximum size that is consistent with all of the object's dimensions (defaults to huge), so for a sphere set one size to the sphere's diameter
# the centre of the object is specified by the centre vector, defaulting to zero if a component is not specified
# for 2D shapes choose a 3D shape that gives the correct intersection with the 2D plane (ie, sphere for circle, box for rectangle)
OVERRIDE_OPTIONS noinput,output
# circle
CELL_CONSTANT <phi_initial> "cellmax(cellmin(cellvofphishape[sphere](size[l=1]=0.8d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<phi_initial_tol>)-cellvofphishape[sphere](size[l=1]=0.4d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<phi_initial_tol>),1.d0),0.d0)"  input
CELL_CONSTANT <phi_initial1> "cellmax(cellmin(cellvofphishape[sphere](size[l=1]=0.8d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<phi_initial_tol>)-cellvofphishape[sphere](size[l=1]=0.4d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<phi_initial_tol>),1.d0),0.d0)" input
CELL_CONSTANT <phi_final1> "cellmax(cellmin(cellvofphishape[sphere](size[l=1]=0.8d0,centre[l=1]=3.5d0,centre[l=2]=0.5d0,phitol=<phi_initial_tol>)-cellvofphishape[sphere](size[l=1]=0.4d0,centre[l=1]=3.5d0,centre[l=2]=0.5d0,phitol=<phi_initial_tol>),1.d0),0.d0)"   input
CELL_CONSTANT <phi_final2> "cellmax(cellmin(cellvofphishape[sphere](size[l=1]=0.8d0,centre[l=1]=3.5d0,centre[l=2]=2.0d0,phitol=<phi_initial_tol>)-cellvofphishape[sphere](size[l=1]=0.4d0,centre[l=1]=3.5d0,centre[l=2]=2.0d0,phitol=<phi_initial_tol>),1.d0),0.d0)"   input
# square
#CELL_CONSTANT <phi_initial> "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<phi_initial_tol>),1.d0),0.d0)"  input
#CELL_CONSTANT <phi_initial1> "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<phi_initial_tol>),1.d0),0.d0)" input
#CELL_CONSTANT <phi_final1> "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=3.5d0,centre[l=2]=0.5d0,phitol=<phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=3.5d0,centre[l=2]=0.5d0,phitol=<phi_initial_tol>),1.d0),0.d0)"   input
#CELL_CONSTANT <phi_final2> "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=3.5d0,centre[l=2]=2.0d0,phitol=<phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=3.5d0,centre[l=2]=2.0d0,phitol=<phi_initial_tol>),1.d0),0.d0)"   input
# rotated square (not working yet)
#CELL_CONSTANT <phi_initial>  "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<phi_initial_tol>),1.d0),0.d0)"  input
#CELL_CONSTANT <phi_initial1> "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<phi_initial_tol>),1.d0),0.d0)" input
#CELL_CONSTANT <phi_final1>   "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=3.5d0,centre[l=2]=0.5d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=3.5d0,centre[l=2]=0.5d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<phi_initial_tol>),1.d0),0.d0)"   input
#CELL_CONSTANT <phi_final2>   "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=3.5d0,centre[l=2]=2.0d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=3.5d0,centre[l=2]=2.0d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<phi_initial_tol>),1.d0),0.d0)"   input
OVERRIDE_OPTIONS

# set up velocity field
CELL_CONSTANT <u[l=1]> 2.d0
CELL_CONSTANT <u[l=2]> 1.d0
FACE_LOCAL <u_f_vect[l=1]> "faceave[reflect=1](<u[l=1]>)" output
FACE_LOCAL <u_f_vect[l=2]> "faceave[reflect=2](<u[l=2]>)"
FACE_CONSTANT <u_f> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" output
CELL_CONSTANT <CFL/dt local> "facesum(faceif(<facedivop>*<u_f>,<facedivop>*<u_f>,0.d0),region=<celljfaces>)" ON <domain> output
NONE_CONSTANT <CFL/dt> "cellmax(<CFL/dt local>,region=<domain>)" output
NONE_CONSTANT <CFL> 0.125d0 # this is the target CFL, based on the volume of fluid flowing out of each cell
NONE_CONSTANT <dt> "<CFL>/nonemax(<CFL/dt>,1.d-10)" # this is the timestep based on the target CFL
CONSTANT <celldxave> "cellsum(<celldxmax>,region=<domain>)/cellsum(1.d0,region=<domain>)" # average cell dimension

# set up time variables
NONE_CONSTANT <t_end> "3.d0/cellmax(abs(<u[l=1]>),region=<domain>)" # base final time on form moving 3 in the horizontal direction
NONE_CONSTANT <dt_out> "<t_end>/20.d0" # base output time on a number of steps within the end time
TRANSIENT_SIMULATION
NONE_TRANSIENT <t[r=0]> "0.d0" "<t[r=1]>+<dt[r=0]>" # time
NONE_TRANSIENT <t[r=1]> "<t>-<dt[r=0]>" "<t>" # time at last step
NONE_CONDITION <output test> "<t>-<t_out>-<dt_out>+<dt>*1.d-10" outputcondition # this will be true (>0.) whenever we are <dt_out> from last output
NONE_OUTPUT <t_out> "<t>" stepoutputnoupdate # this will record the time of the last output
NONE_CONDITION <stop test> "<t>-<t_end>" stopcondition # when this becomes true (>0.) the simulation stops

#TIMESTEPMAX 20
#TIMESTEPMAX 1
#TIMESTEPOUT 1

CELL_LOCAL <phi_rounded> "cellif(<phi>-<vof_phi_tol>,cellif(1.d0-<vof_phi_tol>-<phi>,<phi>,1.d0),0.d0)"
CELL_TRANSIENT <phi[r=1]> "<phi_initial>" "<phi_rounded>" output
CONSTANT <vof_phi_tol> 1.d-8
CELL_LOCAL <phi_lim> "cellmax(cellmin(<phi>,1.d0),0.d0)" ON <all cells>

#INCLUDE_ROOT "free_surface/volume_of_fluid"
# INFO: setting include root directory to free_surface/volume_of_fluid
DEFAULT_OPTIONS noderivative
# compute a smoothed phi, which is used in the surface tension calculation and later in the vof advection
#INCLUDE "smooth_phi" R "<vof_phi" W "<phi"
