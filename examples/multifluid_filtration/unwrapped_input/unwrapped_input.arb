#(comment created during unwrap): new block = resources/test_suite_results/gnu/output/build/root_input.arb: sub_block = 0
# root_input.arb file created by the arb script
##################################################################################
# the following external fortran files were found by the arb script and are available for inclusion: /home/daltonh/fortran/arb/testsuite/arb_develop/src/free_surface_functions.f90
EXTERNALS "/home/daltonh/fortran/arb/testsuite/arb_develop/src/free_surface_functions.f90"
##################################################################################
# the following working directory files found by the arb script: multifluid_filtration.arb
   #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 0
   #(hash inserted during unwrap)INCLUDE_WORKING "multifluid_filtration.arb"
   INFO_TITLE "Multifluid filtration example"
   INFO_DATE "21/3/19"
   INFO_DESCRIPTION "Simulation of flow through a 2D cartesian channel with a membrane along one side, here accomplished using multi-fluid equations with one solid species (ie, a two-fluid model)"
   
   # ue this string to set whether a membrane is present or not
   
   #INCLUDE_TEMPLATE "kernel_presets"
   #INCLUDE "kernel_1st_order_compact"
   
   MSH_FILE "filtration_channel_coarse.msh" input # hopelessly unresolved coarse mesh
   #MSH_FILE "filtration_channel_short.msh" input
   
      #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 1
      #(hash inserted during unwrap)IF 1 # don't rely on the <walls> definition in the msh file
      FACE_REGION <walls> "compound(<boundaries>-<inlet>-<outlet>-<membrane>)"
      #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 1
      #(hash inserted during unwrap)ELSE
      #(hash inserted during unwrap)FACE_REGION <walls> "compound(<boundaries>-<inlet>-<outlet>)"
      #(hash inserted during unwrap)END_IF
   
   GLUE_FACES <centreline> reflect=2
   
   #GENERAL_REPLACEMENTS R "<<dynamic_force_f_method>>" W "facegrad"
   #GENERAL_REPLACEMENTS R "<<dynamic_force_f_method>>" W "dxunit"
   
      #(comment created during unwrap): new block = ../../templates/general/cartesian_x1y2.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE_TEMPLATE "general/cartesian_x1y2"
      #(hash inserted during unwrap)MARKDOWN
      #(hash inserted during unwrap)sets general replacements for cartesian 2D coordinates in the xy plane
      #(hash inserted during unwrap)END_MARKDOWN
      
      
      
   
   #GLOBAL_REPLACEMENTS R "<<multifluid_species_max>>" W "2" # this is the maximum species number, which is equivalent to the number of disperse phases
   # this is the maximum species number, which is equivalent to the number of disperse phases
      #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/setup_species_strings.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE_TEMPLATE "multiphase/multifluid/setup_species_strings"
      #(hash inserted during unwrap)MARKDOWN
      #(hash inserted during unwrap)Here we set the list strings <<multifluid_species_list>>, <<multifluid_number_list>>, <<multifluid_disperse_species_list>>, <<multifluid_disperse_number_list>> based on 1 variable (which defaults to 1)
      #(hash inserted during unwrap)END_MARKDOWN
      
      # this is the maximum species number, which is equivalent to the number of disperse phases
      # if not set, defaults to a global value of 1, ie, the two_fluid model
      
      
      
      
      
   
   # method used for rhie-chow u_f interpolation
   
   #GLOBAL_REPLACEMENTS D '<<u_f_method>>' W 'species' # default behaviour for v0.60
   
   #REPLACEMENTS R "<<shearinduceddiffusion>>" W "0"
   
   #{{ print "string_debug = ".string_debug."\n"; }}
   
   #INCLUDE_TEMPLATE "navier_stokes/stokes"
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "multiphase/multifluid"
      #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/constants.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "constants"
      #(hash inserted during unwrap)MARKDOWN
      #(hash inserted during unwrap)Here we run through all species setting constants
      #(hash inserted during unwrap)END_MARKDOWN
      
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/default_replacement_strings.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "default_replacement_strings"
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Set some default equation settings via replacement strings for the multifluid problem
         #(hash inserted during unwrap)END_MARKDOWN
         
         # <<implicitadvection>> modifies both the advection of phi and u, making both implicit (ie, using r=0 values rather than r=1 values).  You need implicit advection to be able to push CFL over 1.
         # default is now implicit advection
         
         #GLOBAL_REPLACEMENTS D "<<stress_method>>" W "version1" # method, with phi inside viscous stress divergence
         # as per jackson98 and zhang97, have phi outside of stress divergence, version2 default = zhang97 = jackson98 = balls
         
         # default hindered settling function is now as defined in masliyah79 = balls
         # version1 gives an equivalent hindered settling function which is / phi_0^2
         
         
         # method used for rhie-chow u_f interpolation
         
         #GLOBAL_REPLACEMENTS D '<<u_f_method>>' W 'species' # default behaviour for v0.60
         
      
      # get boltzmann's constant
      #(hash inserted during unwrap)INCLUDE_TEMPLATE "general"
         #(comment created during unwrap): new block = ../../templates/general/physical_constants.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "physical_constants"
         # list of fundamental physical constants
         # note, in all of these definitions, the word subscript is given in small letters, except for degreesC
         # source: https://physics.nist.gov/cuu/Constants/Table/allascii.txt
         CONSTANT <k_boltzmann> [J/K] 1.38064852d-23 # boltzmann constant
         CONSTANT <N_avogadro> [1/mol] 6.022140857d+23 # avogadro constant
         CONSTANT <R_gas_constant> [J/K.mol] "<k_boltzmann>*<N_avogadro>"
         CONSTANT <e_electron> [C] 1.6021766208d-19 # elementary charge (magnitude of the charge of an electron)
         CONSTANT <eps_0> [F/m] 8.854187817d-12 # vacuum permittivity
         CONSTANT <T_absolute_zero> [C] -273.15d0 # absolute zero in celsius
         CONSTANT <T_zero_degreesC> [K] "-<T_absolute_zero>" # zero degrees celsius in kelvin
      # set some constants related to the solids
      CONSTANT <T> [K] 298.15 # temperature
      
      # first the constants that are in common with the navier_stokes equations
         #(comment created during unwrap): new block = ../../templates/navier_stokes/constants.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/constants' 
         
         # physical data
         CONSTANT <mu_species0> [Pa.s] 1.d-3 # viscosity of liquid
         CONSTANT <rho_species0> [kg/m^3] 1.d0 # density
         CONSTANT <u_av_species0> [m/s] 1.d0 # required average inlet velocity (if used, sets flowrate through inlet)
         
         #-------------
         # set default strings using the following template file, which sets up a steady-state solution to the navier-stokes equations, with uniform viscosity and density
         # see below for appropriate statements to change these decisions
         # these strings are used throughout the navier_stokes template files
         # strings can also be set when calling the template files using per-file replacements, although this isn't the standard way of implementing these settings
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, which requires three things to be set for each option.  The comment type variables will eventually be phased out, but are still required for many of the template files.
            #(hash inserted during unwrap)END_MARKDOWN
            
            # the following strings require a flag variable and two comment variables to be set
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
         
         #-------------
         
         # numerical data
         CONSTANT <C_{Rhie-Chow}> [] 1.0d+0 # multiplier for Rhie-Chow-type velocity interpolation
         CONSTANT <adv_limiter> [] 1.d0 # multiplier used to limit gradients when calculating advection fluxes
         
         # find an estimate of the domain size using general template
         #(hash inserted during unwrap)INCLUDE_TEMPLATE "general"
            #(comment created during unwrap): new block = ../../templates/general/domain_lengthscale.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "domain_lengthscale" # this will find the none constant <a_lengthscale>
            # find an estimate of the domain size
            # here we use the maximum domain length in each dimension
            # previously used a more accurate but expensive formulation (see minimum_face_boundary_distance)
               #(comment created during unwrap): new block = ../../templates/general/domain_lengths.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "domain_lengths" # this will find a constant vector domain length in each dimension
               # based on node locations, here we calculate the maximum length of the domain in each dimension
               # these loops could be conducted over <boundarynodes>, but although cheaper, this will break if the domain has no boundaries (ie, fully periodic)
               # as this is only a single loop through each node this isn't an expensive calculation anyway (unlike the levelset-based minimum boundary distance)
               NONE_CONSTANT <nodexmax[l=1]> "nodemax(<nodex[l=1]>,region=<allnodes>)"
               NONE_CONSTANT <nodexmax[l=2]> "nodemax(<nodex[l=2]>,region=<allnodes>)"
               #NONE_CONSTANT <nodexmax[l=3]> "nodemax(<nodex[l=3]>,region=<allnodes>)"
               NONE_CONSTANT <nodexmin[l=1]> "nodemin(<nodex[l=1]>,region=<allnodes>)"
               NONE_CONSTANT <nodexmin[l=2]> "nodemin(<nodex[l=2]>,region=<allnodes>)"
               #NONE_CONSTANT <nodexmin[l=3]> "nodemin(<nodex[l=3]>,region=<allnodes>)"
               NONE_CONSTANT <domain_length[l=1]> "<nodexmax[l=1]>-<nodexmin[l=1]>"
               NONE_CONSTANT <domain_length[l=2]> "<nodexmax[l=2]>-<nodexmin[l=2]>"
               #NONE_CONSTANT <domain_length[l=3]> "<nodexmax[l=3]>-<nodexmin[l=3]>"
            # this is based on a vector from the minimum to the maximum coordinates
            #NONE_CONSTANT <a_lengthscale> "sqrt(nonemax(dot(<domain_length[l=:]>,<domain_length[l=:]>),0.d0))"
            # this is based on the maximum domain length over the three dimensions
            NONE_CONSTANT <a_lengthscale> "nonemax(<domain_length[l=1]>,nonemax(<domain_length[l=2]>,<domain_length[l=3]>))"
         
         # for reference calculate some nondimensional quantities
         # these should be overwritten by real nondimensional quantities if this is a nondimensional problem
         CONSTANT <Re_species0> "<u_av_species0>*<rho_species0>*<a_lengthscale>/<mu_species0>" # Reynolds number
         #(comment created during unwrap): new block = ../../templates/navier_stokes/constants.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/constants' 
         
         # physical data
         CONSTANT <mu_species1> [Pa.s] 1.d-3 # viscosity of liquid
         CONSTANT <rho_species1> [kg/m^3] 1.d0 # density
         CONSTANT <u_av_species1> [m/s] 1.d0 # required average inlet velocity (if used, sets flowrate through inlet)
         
         #-------------
         # set default strings using the following template file, which sets up a steady-state solution to the navier-stokes equations, with uniform viscosity and density
         # see below for appropriate statements to change these decisions
         # these strings are used throughout the navier_stokes template files
         # strings can also be set when calling the template files using per-file replacements, although this isn't the standard way of implementing these settings
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, which requires three things to be set for each option.  The comment type variables will eventually be phased out, but are still required for many of the template files.
            #(hash inserted during unwrap)END_MARKDOWN
            
            # the following strings require a flag variable and two comment variables to be set
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
         
         #-------------
         
         # numerical data
         CONSTANT <C_{Rhie-Chow}> [] 1.0d+0 # multiplier for Rhie-Chow-type velocity interpolation
         CONSTANT <adv_limiter> [] 1.d0 # multiplier used to limit gradients when calculating advection fluxes
         
         # find an estimate of the domain size using general template
         #(hash inserted during unwrap)INCLUDE_TEMPLATE "general"
            #(comment created during unwrap): new block = ../../templates/general/domain_lengthscale.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "domain_lengthscale" # this will find the none constant <a_lengthscale>
            # find an estimate of the domain size
            # here we use the maximum domain length in each dimension
            # previously used a more accurate but expensive formulation (see minimum_face_boundary_distance)
               #(comment created during unwrap): new block = ../../templates/general/domain_lengths.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "domain_lengths" # this will find a constant vector domain length in each dimension
               # based on node locations, here we calculate the maximum length of the domain in each dimension
               # these loops could be conducted over <boundarynodes>, but although cheaper, this will break if the domain has no boundaries (ie, fully periodic)
               # as this is only a single loop through each node this isn't an expensive calculation anyway (unlike the levelset-based minimum boundary distance)
               NONE_CONSTANT <nodexmax[l=1]> "nodemax(<nodex[l=1]>,region=<allnodes>)"
               NONE_CONSTANT <nodexmax[l=2]> "nodemax(<nodex[l=2]>,region=<allnodes>)"
               #NONE_CONSTANT <nodexmax[l=3]> "nodemax(<nodex[l=3]>,region=<allnodes>)"
               NONE_CONSTANT <nodexmin[l=1]> "nodemin(<nodex[l=1]>,region=<allnodes>)"
               NONE_CONSTANT <nodexmin[l=2]> "nodemin(<nodex[l=2]>,region=<allnodes>)"
               #NONE_CONSTANT <nodexmin[l=3]> "nodemin(<nodex[l=3]>,region=<allnodes>)"
               NONE_CONSTANT <domain_length[l=1]> "<nodexmax[l=1]>-<nodexmin[l=1]>"
               NONE_CONSTANT <domain_length[l=2]> "<nodexmax[l=2]>-<nodexmin[l=2]>"
               #NONE_CONSTANT <domain_length[l=3]> "<nodexmax[l=3]>-<nodexmin[l=3]>"
            # this is based on a vector from the minimum to the maximum coordinates
            #NONE_CONSTANT <a_lengthscale> "sqrt(nonemax(dot(<domain_length[l=:]>,<domain_length[l=:]>),0.d0))"
            # this is based on the maximum domain length over the three dimensions
            NONE_CONSTANT <a_lengthscale> "nonemax(<domain_length[l=1]>,nonemax(<domain_length[l=2]>,<domain_length[l=3]>))"
         
         # for reference calculate some nondimensional quantities
         # these should be overwritten by real nondimensional quantities if this is a nondimensional problem
         CONSTANT <Re_species1> "<u_av_species1>*<rho_species1>*<a_lengthscale>/<mu_species1>" # Reynolds number
      
      
      # now particle radius and volume, for each disperse phase
      CONSTANT <a_species1> [m] 1.d-6
      CONSTANT <V_species1> [m^3] '4.d0*<pi>*<a_species1>^3/3.d0'
      CONSTANT <A_species1> [m^2] '4.d0*<pi>*<a_species1>^2'
      CONSTANT <phi_initial_species1> '0.1d0'
      
      CONSTANT <p_initial> 10.d0
      CONSTANT <phi_max_allsolids> 0.68d0 # this can be used for consistency across various solid property functions as the maximum allowable total phi
      
      # Also construct some overall variables
      # <u_av> which is the maximum of all phase <u_av>'s, and used to set <dt_initial>
      CONSTANT <u_av> 'nonemax(<u_av_species0>,<u_av_species1>)'
      
      
      # conventional vertical gravity, defined whether buoyancy is on or off
      # whether this is included as a force is determined by whether buoyancy_dynamic_force is included
      # performing index string loops on the following index list pairs:
      #  <<i>> 1,2
      CONSTANT <gravity[l=1]> [m/s^2] 0.d0
      CONSTANT <gravity[l=2]> [m/s^2] 0.d0
      CONSTANT <gravity[l=2]> -9.81d0
   #INCLUDE "transient_constant_setup"
      #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/transient_dynamic_setup.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "transient_dynamic_setup"
      # use this file to initial a transient Navier-Stokes simulation using explicit dynamic timestepping
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/transient_all_setup.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE_LOCAL "transient_all_setup" 
         
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)This is the multiphase equivalent of the navier_stokes/transient_all_setup, using that file as a template
         #(hash inserted during unwrap)END_MARKDOWN
         
         # early definition of strings that are used here, and also in called navier-stokes transient_all_setup file
         
         
         
         # now deal with CFL number calculation
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/transient_all_setup.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1
            # species specific method
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/transient_all_setup.arb: sub_block = 2
               #(hash inserted during unwrap)IF 1
               
               # first save species-specific u_fs
               FACE_TRANSIENT <u_f_species0[r=1]> '0.d0' '<u_f_species0>' ON <allfaces>
               FACE_TRANSIENT <u_f_species1[r=1]> '0.d0' '<u_f_species1>' ON <allfaces>
               
               
               # now deal with CFL numbers, treating implicit and explicit timestepping differently
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/transient_all_setup.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 0
                  #(hash inserted during unwrap)# implicit timestepping
                  #(hash inserted during unwrap)# have to call CFL_number with correct species replacements, and also form mixture <CFL local/dt> for use in timestepping
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE "navier_stokes/transient_all_setup"
                  #(hash inserted during unwrap)VARIABLE <u_f[r=1]> CANCEL
                  #(hash inserted during unwrap)# redefine <CFL local/dt>
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# mixture based CFL numbers for reporting purposes only
                  #(hash inserted during unwrap)CELL_LOCAL <CFL local> "<dt>*<CFL local/dt>" ON <domain> nooutput
                  #(hash inserted during unwrap)NONE_OUTPUT <CFL> "cellmax(<CFL local>,region=<domain>)" output
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/transient_all_setup.arb: sub_block = 3
                  #(hash inserted during unwrap)ELSE
                  # explicit timestepping
                  # timestep is based on explicit mixture <CFL[r=1]> which needs to be formed from species specific CFL's
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/CFL_number.arb: sub_block = 0
                     #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/CFL_number' 
                     
                     # these lines just output the global CFL number for a transient simulation
                     # replace nooutput with output to also output local CFL number
                     # <facedivop> is positive if a face normal points outwards from the last cell, so these numbers are based on the total flowrate out of each cell
                     CELL_LOCAL <CFL local/dt_species0[r=1]> "facesum(faceif(<facedivop>*<u_f_species0[r=1]>,<facedivop>*<u_f_species0[r=1]>,0.d0),region=<celljfaces>)" ON <domain> nooutput
                     #CELL_LOCAL <CFL local/dt_species0[r=1]> "facesum(faceif(<facedivop>*<u_f_species0[r=1]>,1.d0*<facedivop>*<u_f_species0[r=1]>,0.d0),region=<celljfaces>)/1.d0" ON <domain> nooutput
                     CELL_LOCAL <CFL local_species0[r=1]> "<dt[r=1]>*<CFL local/dt_species0[r=1]>" ON <domain> nooutput
                     NONE_TRANSIENT <CFL_species0[r=1]> "cellmax(<CFL local_species0[r=1]>,region=<domain>)" output
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/CFL_number.arb: sub_block = 0
                     #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/CFL_number' 
                     
                     # these lines just output the global CFL number for a transient simulation
                     # replace nooutput with output to also output local CFL number
                     # <facedivop> is positive if a face normal points outwards from the last cell, so these numbers are based on the total flowrate out of each cell
                     CELL_LOCAL <CFL local/dt_species1[r=1]> "facesum(faceif(<facedivop>*<u_f_species1[r=1]>,<facedivop>*<u_f_species1[r=1]>,0.d0),region=<celljfaces>)" ON <domain> nooutput
                     #CELL_LOCAL <CFL local/dt_species1[r=1]> "facesum(faceif(<facedivop>*<u_f_species1[r=1]>,1.d0*<facedivop>*<u_f_species1[r=1]>,0.d0),region=<celljfaces>)/1.d0" ON <domain> nooutput
                     CELL_LOCAL <CFL local_species1[r=1]> "<dt[r=1]>*<CFL local/dt_species1[r=1]>" ON <domain> nooutput
                     NONE_TRANSIENT <CFL_species1[r=1]> "cellmax(<CFL local_species1[r=1]>,region=<domain>)" output
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_all_setup.arb: sub_block = 0
                     #(hash inserted during unwrap)INCLUDE_TEMPLATE "navier_stokes/transient_all_setup"
                     #(hash inserted during unwrap)MARKDOWN
                     #(hash inserted during unwrap)Setup things needed for transient flow
                     #(hash inserted during unwrap)This file works for either dynamic or constant timestepping
                     #(hash inserted during unwrap)Designed to be called by either transient_constant_setup (linked to transient_setup) or transient_dynamic_setup
                     #(hash inserted during unwrap)String replacements default to constant timestepping, or if dynamic timestepping is specified, explicit dynamic timestepping
                     #(hash inserted during unwrap)Choice can be made by performing replacements when calling
                     #(hash inserted during unwrap)END_MARKDOWN
                     
                     # first set global replacements strings that specify a transient simulation, and overwrite what is specified in default_string_replacements
                     GENERAL_OPTIONS transientsimulation
                     
                     
                     # <dt_initial> is used to set the intial timestep during dynamic timestepping or constant timestep otherwise
                     
                     CONSTANT <t_end> [] 1.d2 # time for simulation to stop
                     CONSTANT <celldxave> "cellsum(<celldxmax>,region=<domain>)/cellsum(1.d0,region=<domain>)" # average cell dimension
                     CONSTANT <CFL_initial> 1.d-2 # enter a CFL number to set the initial timestep (roughly) - depending on the geometry of cells and non-uniformity of mesh, this may significantly underestimate the actual CFL that results - ie, you may need to choose a smaller number 
                     CONSTANT <dt_initial> [] "<CFL_initial>*<celldxave>/<u_av>" # initial timestep based on cell dimension, expecting a velocity of magnitude <u_av>
                     CONSTANT <CFL_out> 10.d0 # one way of entering the time between output is based on how many times a cell should be flushed between output, based on the average inlet velocity
                     CONSTANT <dt_out> [] "<CFL_out>*<celldxave>/<u_av>" # initial timestep based on cell dimension, expecting a velocity of magnitude <u_av>
                     #CONSTANT <dt_out> [] "<t_end>/50.d0" # time between output
                     
                     # the default is for constant as opposed to dynamic timestepping
                     # change this by calling with <<dynamictimestep>> = 1
                     
                     
                     #---------------------------------------------------------------------------------------------------------
                     # dynamic timestepping
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_all_setup.arb: sub_block = 1
                        #(hash inserted during unwrap)IF 1
                        
                        # dynamic timestep constants
                        CONSTANT <dt_increase> 1.2d0
                        CONSTANT <dt_max> "<dt_initial>*1.d4"
                        CONSTANT <dt_min> "<dt_initial>*1.d-3"
                        CONSTANT <CFL_max> 0.25d0
                        
                        # by default there is an explicit newtstep timestep limitation that changes the timestep based on the number of newtsteps required to converge the last iteration
                        # to remove this restraint set <<newtsteptimestepping>> = 0
                        
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_all_setup.arb: sub_block = 2
                           #(hash inserted during unwrap)IF 1
                           CONSTANT <dt_decrease> 0.7d0
                           CONSTANT <newtstepdtlimiterlow> 4.d0 # explicitly calculated timestep is only increased if <newtstep[r=1]> is <= than this value
                           CONSTANT <newtstepdtlimiterhigh> 8.d0 # explicitly calculated timestep is decreased if <newtstep[r=1]> is > than this value
                           NONE_TRANSIENT <newtstep[r=1]> "0.d0" "<newtstep>" # we save the previous timestep <newtstep> for the above explicit timestep calculation
                           NONE_TRANSIENT <dt_newtstep_increase[r=1]> "1.d0" "noneif(<newtstep[r=1]>-<newtstepdtlimiterhigh>,<dt_decrease>,noneif(<newtstep[r=1]>-<newtstepdtlimiterlow>,1.d0,<dt_increase>))" # apply this to the previous timestep to keep newtstep roughly between high/low ranges
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_all_setup.arb: sub_block = 2
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)NONE_LOCAL <dt_newtstep_increase[r=1]> "<dt_increase>" # placeholder for nonnewtsteplimited timestepping
                           #(hash inserted during unwrap)END_IF
                        
                        NONE_TRANSIENT <dt[r=1]> "<dt_initial>" "<dt>" stepoutput
                        FACE_TRANSIENT <u_f[r=1]> "0.d0" "<u_f>" ON <allfaces> # don't actually need this for implicit timestepping, but it is used in input files for some of the problems for output, so in the interests of not breaking things...
                        
                        # the default is for explicit timestepping, but implicit can also be enabled by reversing the following strings
                        
                        
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_all_setup.arb: sub_block = 2
                           #(hash inserted during unwrap)IF 0
                           #(hash inserted during unwrap)# implicit
                           #(hash inserted during unwrap)# note, a newtstepmax may be applied to <dt_target> within u_f.arb (unfortunately this must be done after <u_f> derived has been calculated, hence, newtstepmax can't be applied here)
                           #(hash inserted during unwrap)INCLUDE "CFL_number"
                           #(hash inserted during unwrap)# straight minimum
                           #(hash inserted during unwrap)# advantage of straight minimum is that provided convergence is achieved the CFL constraint will be rigorously obeyed
                           #(hash inserted during unwrap)NONE_LOCAL <dt_target> "nonemax(nonemin(nonemin(<dt_newtstep_increase[r=1]>*<dt[r=1]>,<CFL_max>/cellmax(<CFL local/dt>,default=<tiny>,region=<domain>)),<dt_max>),<dt_min>)"
                           #(hash inserted during unwrap)# harmonically averaged, for smoother convergence than the straight minimum which can bounce around
                           #(hash inserted during unwrap)# disadvantage of the particular harmonic function used is for a factor of two (see below) the dt could be up to twice what the CFL criterion dictates, but using a factor of one can unreasonably decrease timestep below the CFL limit for many timestep combinations
                           #(hash inserted during unwrap)#   NONE_LOCAL <dt_explicit_target> "nonemax(nonemin(<dt_newtstep_increase[r=1]>*<dt[r=1]>,<dt_max>),<dt_min>)" stepoutput
                           #(hash inserted during unwrap)#   NONE_LOCAL <dt_CFL_target> "nonemax(<CFL_max>/cellmax(<CFL local/dt>,default=<tiny>,region=<domain>),<dt_min>)" stepoutput
                           #(hash inserted during unwrap)# using two factor here which really doesn't respect dt_increase and CFL_max values correctly, but performs best when both timescales are about the same - ie, more thought required
                           #(hash inserted during unwrap)#   NONE_LOCAL <dt_target> "2.d0/(1.d0/<dt_explicit_target>+1.d0/<dt_CFL_target>)" stepoutput
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)NONE_UNKNOWN <dt[r=0]> "<dt_initial>" stepoutput,input,output,timesteprewind
                           #(hash inserted during unwrap)NONE_DERIVED <t[r=0]> "<t[r=1]>+<dt[r=0]>" timesteprewind,input,output
                           #(hash inserted during unwrap)NONE_TRANSIENT <t[r=1]> "-<dt[r=0]>" "<t>" timesteprewind,input,output # time at last step
                           #(hash inserted during unwrap)NONE_EQUATION <dt implicit equation> "<dt>-<dt_target>"
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)# this causes <dt_target> to be made constant after a certain number of newtsteps
                           #(hash inserted during unwrap)# this is enacted in u_f.arb
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_all_setup.arb: sub_block = 2
                           #(hash inserted during unwrap)ELSE
                           # explicit
                           # use CFL_number template, but make the calculation explicit - ie, based on r=1 values
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/CFL_number.arb: sub_block = 0
                              #(hash inserted during unwrap)INCLUDE "CFL_number" 
                              
                              # these lines just output the global CFL number for a transient simulation
                              # replace nooutput with output to also output local CFL number
                              # <facedivop> is positive if a face normal points outwards from the last cell, so these numbers are based on the total flowrate out of each cell
                              CELL_LOCAL <CFL local/dt[r=1]> "facesum(faceif(<facedivop>*<u_f[r=1]>,<facedivop>*<u_f[r=1]>,0.d0),region=<celljfaces>)" ON <domain> nooutput
                              #CELL_LOCAL <CFL local/dt[r=1]> "facesum(faceif(<facedivop>*<u_f[r=1]>,1.d0*<facedivop>*<u_f[r=1]>,0.d0),region=<celljfaces>)/1.d0" ON <domain> nooutput
                              CELL_LOCAL <CFL local[r=1]> "<dt[r=1]>*<CFL local/dt[r=1]>" ON <domain> nooutput
                              NONE_TRANSIENT <CFL[r=1]> "" "cellmax(<CFL local[r=1]>,region=<domain>)" output
                           #   NONE_TRANSIENT <CFL[r=1]> "" "cellmax(<CFL local[r=1]>,region=<domain>)" output,stepoutput
                           NONE_TRANSIENT <CFL[r=1]> output,stepoutput
                           NONE_TRANSIENT <dt[r=0]> "<dt_initial>" "nonemax(nonemin(nonemin(<dt_newtstep_increase[r=1]>,<CFL_max>/nonemax(<CFL[r=1]>,<tiny>))*<dt[r=1]>,<dt_max>),<dt_min>)" stepoutput,input,output,timesteprewind
                           NONE_TRANSIENT <t[r=0]> "0.d0" "<t[r=1]>+<dt[r=0]>" timesteprewind,input,output # time
                           NONE_TRANSIENT <t[r=1]> "<t>-<dt[r=0]>" "<t>" timesteprewind,input,output # time at last step
                           
                           #(hash inserted during unwrap)END_IF
                        
                        #---------------------------------------------------------------------------------------------------------
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_all_setup.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)# constant timestep
                        #(hash inserted during unwrap)NONE_CONSTANT <dt> "<dt_initial>"
                        #(hash inserted during unwrap)NONE_TRANSIENT <t[r=0]> "0.d0" "<t[r=1]>+<dt[r=0]>" # time
                        #(hash inserted during unwrap)NONE_TRANSIENT <t[r=1]> "<t>-<dt[r=0]>" "<t>" # time at last step
                        #(hash inserted during unwrap)END_IF
                     #---------------------------------------------------------------------------------------------------------
                     
                     NONE_CONDITION <output test> "<t>-<t_out>-<dt_out>+<dt>*1.d-10" outputcondition # this will be true (>0.) whenever we are <dt_out> from last output
                     NONE_OUTPUT <t_out> "<t>" stepoutputnoupdate,timesteprewind # this will record the time of the last output
                     NONE_CONDITION <stop test> "<t>-<t_end>" stopcondition # when this becomes true (>0.) the simulation stops
                     
                     # the initial values are blank, which means they will be set equal to the r=0 components, which when updated will mean that they will be set to the initial values for the r=0 components
                     # performing index string loops on the following index list pairs:
                     #  <<i>> 1,2
                     CELL_TRANSIENT <u[l=1,r=1]> "" "<u[l=1]>" ON <allcells>
                     CELL_TRANSIENT <u[l=2,r=1]> "" "<u[l=2]>" ON <allcells>
                     
                  VARIABLE <u_f[r=1]> CANCEL
                  VARIABLE <CFL local/dt[r=1]> CANCEL
                  VARIABLE <CFL local[r=1]> CANCEL
                  # now redefine <CFL[r=1]> using species CFLs, but keep position
                  NONE_TRANSIENT <CFL[r=1]> '0.d0' output
                  VARIABLE <CFL[r=1]> 'nonemax(<CFL_species0[r=1]>,default=<CFL[r=1]>)'
                  VARIABLE <CFL[r=1]> 'nonemax(<CFL_species1[r=1]>,default=<CFL[r=1]>)'
                  
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)END_IF
            
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/transient_all_setup.arb: sub_block = 1
            #(hash inserted during unwrap)ELSE
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)INCLUDE_TEMPLATE "navier_stokes/transient_all_setup"
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)# mixture based CFL - doesn't work
            #(hash inserted during unwrap)# define a <u_f[r=1]> from the current phi_f_adv and <u_f_species> to use in CFL calculation, overwriting above expression
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)END_IF
         
         # cancel the single phase <u[l=:,r=1]> variables that were defined in the navier_stokes file, and replace with phase specific ones
         CELL_TRANSIENT <u[l=1,r=1]> CANCEL
         CELL_TRANSIENT <u[l=2,r=1]> CANCEL
         
         
         # now define saved r=1 phase specific velocities and phi
         CELL_TRANSIENT <u_species0[l=1,r=1]> '' '<u_species0[l=1]>' ON <allcells>
         CELL_TRANSIENT <u_species0[l=2,r=1]> '' '<u_species0[l=2]>' ON <allcells>
         CELL_TRANSIENT <phi_species0[r=1]> '' '<phi_species0>' ON <allcells>
         CELL_TRANSIENT <u_species1[l=1,r=1]> '' '<u_species1[l=1]>' ON <allcells>
         CELL_TRANSIENT <u_species1[l=2,r=1]> '' '<u_species1[l=2]>' ON <allcells>
         CELL_TRANSIENT <phi_species1[r=1]> '' '<phi_species1>' ON <allcells>
         
      #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/unknowns.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "unknowns" # define unknowns and various derivatives, including the various phi functions
      #(hash inserted during unwrap)MARKDOWN
      #(hash inserted during unwrap)Here we setup the cell-centred velocities, pressures and volume fractions for each phase
      #(hash inserted during unwrap)END_MARKDOWN
      
      CELL_UNKNOWN <u_species0[l=1]> [] '0.d0' ON <allcells> magnitude=<u_av_species0>
      # performing index string loops on the following index list pairs:
      #  <<i>> 1,2
      FACE_LOCAL <u_f_vect_species0[l=1]> 'faceave[](<u_species0[l=1]>)' ON <allfaces>
      FACE_LOCAL <u_f_vect_species0[l=2]> 'faceave[reflect=2](<u_species0[l=2]>)' ON <allfaces>
      CELL_LOCAL <extra_force_species0[l=1]> '0.d0' ON <domain>
      CELL_UNKNOWN <u_species0[l=2]> [] '0.d0' ON <allcells> magnitude=<u_av_species0>
      # performing index string loops on the following index list pairs:
      #  <<i>> 1,2
      FACE_LOCAL <u_f_vect_species0[l=1]> 'faceave[](<u_species0[l=1]>)' ON <allfaces>
      FACE_LOCAL <u_f_vect_species0[l=2]> 'faceave[reflect=2](<u_species0[l=2]>)' ON <allfaces>
      CELL_LOCAL <extra_force_species0[l=2]> '0.d0' ON <domain>
      CELL_UNKNOWN <p_species0> [] '<p_initial>' ON <allcells>
      CELL_UNKNOWN <u_species1[l=1]> [] '0.d0' ON <allcells> magnitude=<u_av_species1>
      # performing index string loops on the following index list pairs:
      #  <<i>> 1,2
      FACE_LOCAL <u_f_vect_species1[l=1]> 'faceave[](<u_species1[l=1]>)' ON <allfaces>
      FACE_LOCAL <u_f_vect_species1[l=2]> 'faceave[reflect=2](<u_species1[l=2]>)' ON <allfaces>
      CELL_LOCAL <extra_force_species1[l=1]> '0.d0' ON <domain>
      CELL_UNKNOWN <u_species1[l=2]> [] '0.d0' ON <allcells> magnitude=<u_av_species1>
      # performing index string loops on the following index list pairs:
      #  <<i>> 1,2
      FACE_LOCAL <u_f_vect_species1[l=1]> 'faceave[](<u_species1[l=1]>)' ON <allfaces>
      FACE_LOCAL <u_f_vect_species1[l=2]> 'faceave[reflect=2](<u_species1[l=2]>)' ON <allfaces>
      CELL_LOCAL <extra_force_species1[l=2]> '0.d0' ON <domain>
      CELL_UNKNOWN <phi_species1> [] '<phi_initial_species1>' ON <allcells> magnitude=1.d0
      CELL_DERIVED <phi_species0> [] '1.d0-<phi_species1>' ON <allcells>
      
      
      # also define some derivatives of phi here
      NONE_CONSTANT <phi_tol> 1.d-6 # this is a minimum phi to consider any phase present, contributing to <phi_bounded_speciesN>
      CELL_LOCAL <phi_bounded_species0> [] 'cellmax(cellmin(<phi_species0>,1.d0-<phi_tol>),<phi_tol>)'
      CELL_LOCAL <phi_bounded_species0[r=1]> [] 'cellmax(cellmin(<phi_species0[r=1]>,1.d0-<phi_tol>),<phi_tol>)'
      CELL_LOCAL <phi_pos_species0> [] 'cellmax(cellmin(<phi_species0>,1.d0),0.d0)'
      CELL_LOCAL <phi_pos_species0[r=1]> [] 'cellmax(cellmin(<phi_species0[r=1]>,1.d0),0.d0)'
      FACE_DERIVED <phi_f_pos_species0> [] 'faceave(<phi_pos_species0>)' ON <allfaces>
      FACE_LOCAL <phi_f_bounded_species0> [] 'faceave(<phi_bounded_species0>)' ON <allfaces>
      FACE_LOCAL <phi_f_species0> [] 'faceave(<phi_species0>)' ON <allfaces>
      FACE_LOCAL <phi_f_pos_adjacent_species0> [] 'faceave[adjacentcells](<phi_pos_species0>)' ON <allfaces>
      FACE_LOCAL <phi_f_bounded_adjacent_species0> [] 'faceave[adjacentcells](<phi_bounded_species0>)' ON <allfaces>
      FACE_LOCAL <phi_f_bounded_harmonic_species0> [] 'faceave[harmonic](<phi_bounded_species0>)' ON <allfaces>
      FACE_LOCAL <phi_f_bounded_adjacent_species0[r=1]> [] 'faceave[adjacentcells](<phi_bounded_species0[r=1]>)' ON <allfaces>
      FACE_LOCAL <phi_f_bounded_adjacent_nob_species0> [] 'faceif(facedelta(<boundaries>),faceave[downcell](<phi_bounded_species0>),<phi_f_bounded_adjacent_species0>)' ON <allfaces>
      CELL_LOCAL <phi_fc_bounded_species0> [] 'cellave(<phi_f_bounded_species0>)'
      CELL_LOCAL <phi_bounded_species1> [] 'cellmax(cellmin(<phi_species1>,1.d0-<phi_tol>),<phi_tol>)'
      CELL_LOCAL <phi_bounded_species1[r=1]> [] 'cellmax(cellmin(<phi_species1[r=1]>,1.d0-<phi_tol>),<phi_tol>)'
      CELL_LOCAL <phi_pos_species1> [] 'cellmax(cellmin(<phi_species1>,1.d0),0.d0)'
      CELL_LOCAL <phi_pos_species1[r=1]> [] 'cellmax(cellmin(<phi_species1[r=1]>,1.d0),0.d0)'
      FACE_DERIVED <phi_f_pos_species1> [] 'faceave(<phi_pos_species1>)' ON <allfaces>
      FACE_LOCAL <phi_f_bounded_species1> [] 'faceave(<phi_bounded_species1>)' ON <allfaces>
      FACE_LOCAL <phi_f_species1> [] 'faceave(<phi_species1>)' ON <allfaces>
      FACE_LOCAL <phi_f_pos_adjacent_species1> [] 'faceave[adjacentcells](<phi_pos_species1>)' ON <allfaces>
      FACE_LOCAL <phi_f_bounded_adjacent_species1> [] 'faceave[adjacentcells](<phi_bounded_species1>)' ON <allfaces>
      FACE_LOCAL <phi_f_bounded_harmonic_species1> [] 'faceave[harmonic](<phi_bounded_species1>)' ON <allfaces>
      FACE_LOCAL <phi_f_bounded_adjacent_species1[r=1]> [] 'faceave[adjacentcells](<phi_bounded_species1[r=1]>)' ON <allfaces>
      FACE_LOCAL <phi_f_bounded_adjacent_nob_species1> [] 'faceif(facedelta(<boundaries>),faceave[downcell](<phi_bounded_species1>),<phi_f_bounded_adjacent_species1>)' ON <allfaces>
      CELL_LOCAL <phi_fc_bounded_species1> [] 'cellave(<phi_f_bounded_species1>)'
      
      #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/species_viscosity.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "species_viscosity" # calculate all species viscosities
      #(hash inserted during unwrap)MARKDOWN
      #(hash inserted during unwrap)Here we setup the viscosity for each species, using the single_species_viscosity template file
      #(hash inserted during unwrap)END_MARKDOWN
      
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE_LOCAL 'single_species_viscosity' 
         
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Here we find <mu_f_species> for each species
         #(hash inserted during unwrap)END_MARKDOWN
         
         #REPLACEMENTS D "<<viscosity_method>>" W "einstein"
         
         #REPLACEMENTS D "<<viscosity_method>>" W "thomas65
         
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/default_replacement_strings.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_replacement_strings"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)Set some default equation settings via replacement strings for the multifluid problem
            #(hash inserted during unwrap)END_MARKDOWN
            
            # <<implicitadvection>> modifies both the advection of phi and u, making both implicit (ie, using r=0 values rather than r=1 values).  You need implicit advection to be able to push CFL over 1.
            # default is now implicit advection
            
            #GLOBAL_REPLACEMENTS D "<<stress_method>>" W "version1" # method, with phi inside viscous stress divergence
            # as per jackson98 and zhang97, have phi outside of stress divergence, version2 default = zhang97 = jackson98 = balls
            
            # default hindered settling function is now as defined in masliyah79 = balls
            # version1 gives an equivalent hindered settling function which is / phi_0^2
            
            
            # method used for rhie-chow u_f interpolation
            
            #GLOBAL_REPLACEMENTS D '<<u_f_method>>' W 'species' # default behaviour for v0.60
            
         
         #REPLACEMENTS D "<<stress_method>>" W "version1" # method, with phi inside viscous stress divergence
         # as per jackson98 and zhang97, have phi outside of stress divergence, version2 default = zhang97 = jackson98 = balls
         # in this file jackson98 = version2, zhang97 = balls
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 1
            #(hash inserted during unwrap)IF 
            #(hash inserted during unwrap)# split stress between phases using the simplest possible consistent partitioning
            #(hash inserted during unwrap)# here mu is not species specific, so is roughly proportional (or more) to phi
            #(hash inserted during unwrap)# the multiplier used in the u_f_{correction} calculation is the viscosity/phi, which has a conventional viscosity magnitude as phi -> 0
            #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 2
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)# for the fluid use a multiplier of mu
               #(hash inserted during unwrap)CELL_DERIVED <mu_c_multiplier_species0> [Pa.s] "<mu_species0>" ON <allcells>
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 2
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)# different functions using this simple partitioning only affect the solid viscosity
               #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)# simplest einstein relationship
                  #(hash inserted during unwrap)CELL_DERIVED <mu_c_multiplier_species0> [Pa.s] "3.5d0*<mu_species0>" ON <allcells>
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)# methods that have a maximum total solids magnitude, and can be expressed as a function of total solid volume fraction
                  #(hash inserted during unwrap)NONE_CONSTANT <mu_phi_max_allsolids> "<phi_max_allsolids>"
                  #(hash inserted during unwrap)NONE_CONSTANT <mu_phi_tol> "<phi_tol>"
                  #(hash inserted during unwrap)CELL_DERIVED <mu_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)/<mu_phi_max_allsolids>" output
                  #(hash inserted during unwrap)CELL_LOCAL <mu_c_multiplier_species0> [Pa.s] "<mu_c_multiplier_allsolids>" ON <allcells>
                  #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)NONE_CONSTANT <mu_K_s> 0.1d0
                     #(hash inserted during unwrap)CELL_DERIVED <mu_c_multiplier_allsolids> [Pa.s] "<mu_species0>*(1.d0+2.5d0/(1.d0-<mu_phi_norm_allsolids>)+<mu_K_s>*<mu_phi_norm_allsolids>/(<mu_phi_max_allsolids>*(1.d0-<mu_phi_norm_allsolids>)**2))" ON <allcells> output
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_CONSTANT <mu_phi_max_allsolids> "<phi_max_allsolids>"
                     #(hash inserted during unwrap)NONE_CONSTANT <mu_phi_tol> "<phi_tol>"
                     #(hash inserted during unwrap)CELL_DERIVED <mu_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)/<mu_phi_max_allsolids>" output # here <mu_phi_max_allsolids> is used to scale across the range
                     #(hash inserted during unwrap)NONE_CONSTANT <n> "-2.5d0*<mu_phi_max_allsolids>"
                     #(hash inserted during unwrap)CELL_DERIVED <mu_c_multiplier_species0> [Pa.s] "<mu_species0>*((1.d0-(1.d0-<mu_phi_norm_allsolids>)**<n>)/(<mu_phi_max_allsolids>*<mu_phi_norm_allsolids>*(1.d0-<mu_phi_norm_allsolids>)**<n>) + 1.d0)" ON <allcells> output
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "in single_species_viscosity: viscosity_method = morrisboulay99 not coded yet or unknown"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)END_IF
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)# now construct viscosity and correction viscosity (multiplier) for faces (which tends to a finite value at phi->0 - ie, a non-specific viscosity)
            #(hash inserted during unwrap)CELL_LOCAL <mu_c_species0> "<mu_c_multiplier_species0>*<phi_bounded_species0>" ON <allcells> output
            #(hash inserted during unwrap)FACE_DERIVED <mu_f_species0> "faceave[harmonic](<mu_c_species0>)" ON <allfaces> output # used in stress
            #(hash inserted during unwrap)FACE_DERIVED <mu_f_correction_species0> "faceave[adjacentcells](<mu_c_multiplier_species0>)" ON <allfaces> output # used in rhie-chow
            #(hash inserted during unwrap)
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 1
            #(hash inserted during unwrap)ELSE
            # in version2 the viscous stress divergence is phase specific, so the viscosity for each phase is roughly a constant as phi -> 0
            # the multiplier used in the u_f_{correction} calculation is equal to the viscosity
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 2
               #(hash inserted during unwrap)IF 1
               # define the fluid stress, which is in version2 a mixture stress
               
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)# simplest einstein relationship, for a single phase
                  #(hash inserted during unwrap)CELL_DERIVED <mu_c_species0> [Pa.s] "<mu_species0>*(1.d0+2.5d0*<phi_bounded_species0>)" ON <allcells>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)# for more than one solid use fluid phi to calculate total
                  #(hash inserted during unwrap)CELL_DERIVED <mu_c_species0> [Pa.s] "<mu_species0>*(1.d0+2.5d0*(1.d0-<phi_bounded_species0>))" ON <allcells>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)ELSE
                  # methods that have a maximum total solids magnitude, and can be expressed as a function of total solid volume fraction
                  NONE_CONSTANT <mu_phi_max_allsolids> "<phi_max_allsolids>"
                  NONE_CONSTANT <mu_phi_tol> "<phi_tol>"
                  
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)IF 1
                     NONE_CONSTANT <mu_K_s> 0.1d0
                     CELL_DERIVED <mu_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)/<mu_phi_max_allsolids>" output # here <mu_phi_max_allsolids> is used to scale across the range
                     CELL_DERIVED <mu_c_species0> [Pa.s] "<mu_species0>*(1.d0+2.5d0*<mu_phi_norm_allsolids>/(1.d0-<mu_phi_norm_allsolids>)+<mu_K_s>*(<mu_phi_norm_allsolids>/(1.d0-<mu_phi_norm_allsolids>))**2)" ON <allcells> output
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)CELL_DERIVED <mu_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)/<mu_phi_max_allsolids>" output # here <mu_phi_max_allsolids> is used to scale across the range
                     #(hash inserted during unwrap)CELL_DERIVED <mu_c_species0> [Pa.s] "<mu_species0>*((<mu_phi_norm_allsolids>/(1.d0-<mu_phi_norm_allsolids>))**(2.5d0*<mu_phi_max_allsolids>))" ON <allcells> output
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)CELL_DERIVED <mu_phi_bounded_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)" output # here <mu_phi_max_allsolids> is used as a cut-off
                     #(hash inserted during unwrap)CELL_DERIVED <mu_c_species0> [Pa.s] "<mu_species0>*(1.d0+2.5d0*<mu_phi_bounded_allsolids>+10.05d0*(<mu_phi_bounded_allsolids>)**2 + 0.00273d0*exp(16.6d0*<mu_phi_bounded_allsolids>))" ON <allcells> output
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "in single_species_viscosity: viscosity_method = morrisboulay99 not coded yet or unknown"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)END_IF
               
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 2
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)# for these methods use the same viscosity across phases
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)# only fluid viscosity applied to solid phases, zhang97 = balls
                  #(hash inserted during unwrap)CELL_DERIVED <mu_c_species0> [Pa.s] "<mu_species0>" ON <allcells> output
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)# mixture viscosity applied to all phases, version2 = jackson98
                  #(hash inserted during unwrap)CELL_LOCAL <mu_c_species0> [Pa.s] "<mu_c_species0>" ON <allcells> output
                  #(hash inserted during unwrap)# could also do drew76, no viscosity applied to solid phases...
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)END_IF
            
            # now construct viscosity on faces for use in stress tensor, as well as viscosity for use in u_f rhiechow interpolation (correction)
            # note that for version2 the multiplier is actually just the viscosity - bad notation! - changed to correction viscosity
            FACE_DERIVED <mu_f_species0> "faceave[harmonic](<mu_c_species0>)" ON <allfaces> output # used in stress
            FACE_LOCAL <mu_f_correction_species0> "<mu_f_species0>" ON <allfaces> # used in rhie-chow
            
            #(hash inserted during unwrap)END_IF
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE_LOCAL 'single_species_viscosity' 
         
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Here we find <mu_f_species> for each species
         #(hash inserted during unwrap)END_MARKDOWN
         
         #REPLACEMENTS D "<<viscosity_method>>" W "einstein"
         
         #REPLACEMENTS D "<<viscosity_method>>" W "thomas65
         
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/default_replacement_strings.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_replacement_strings"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)Set some default equation settings via replacement strings for the multifluid problem
            #(hash inserted during unwrap)END_MARKDOWN
            
            # <<implicitadvection>> modifies both the advection of phi and u, making both implicit (ie, using r=0 values rather than r=1 values).  You need implicit advection to be able to push CFL over 1.
            # default is now implicit advection
            
            #GLOBAL_REPLACEMENTS D "<<stress_method>>" W "version1" # method, with phi inside viscous stress divergence
            # as per jackson98 and zhang97, have phi outside of stress divergence, version2 default = zhang97 = jackson98 = balls
            
            # default hindered settling function is now as defined in masliyah79 = balls
            # version1 gives an equivalent hindered settling function which is / phi_0^2
            
            
            # method used for rhie-chow u_f interpolation
            
            #GLOBAL_REPLACEMENTS D '<<u_f_method>>' W 'species' # default behaviour for v0.60
            
         
         #REPLACEMENTS D "<<stress_method>>" W "version1" # method, with phi inside viscous stress divergence
         # as per jackson98 and zhang97, have phi outside of stress divergence, version2 default = zhang97 = jackson98 = balls
         # in this file jackson98 = version2, zhang97 = balls
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 1
            #(hash inserted during unwrap)IF 
            #(hash inserted during unwrap)# split stress between phases using the simplest possible consistent partitioning
            #(hash inserted during unwrap)# here mu is not species specific, so is roughly proportional (or more) to phi
            #(hash inserted during unwrap)# the multiplier used in the u_f_{correction} calculation is the viscosity/phi, which has a conventional viscosity magnitude as phi -> 0
            #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 2
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)# for the fluid use a multiplier of mu
               #(hash inserted during unwrap)CELL_DERIVED <mu_c_multiplier_species1> [Pa.s] "<mu_species0>" ON <allcells>
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 2
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)# different functions using this simple partitioning only affect the solid viscosity
               #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)# simplest einstein relationship
                  #(hash inserted during unwrap)CELL_DERIVED <mu_c_multiplier_species1> [Pa.s] "3.5d0*<mu_species0>" ON <allcells>
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)# methods that have a maximum total solids magnitude, and can be expressed as a function of total solid volume fraction
                  #(hash inserted during unwrap)NONE_CONSTANT <mu_phi_max_allsolids> "<phi_max_allsolids>"
                  #(hash inserted during unwrap)NONE_CONSTANT <mu_phi_tol> "<phi_tol>"
                  #(hash inserted during unwrap)CELL_DERIVED <mu_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)/<mu_phi_max_allsolids>" output
                  #(hash inserted during unwrap)CELL_LOCAL <mu_c_multiplier_species1> [Pa.s] "<mu_c_multiplier_allsolids>" ON <allcells>
                  #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)NONE_CONSTANT <mu_K_s> 0.1d0
                     #(hash inserted during unwrap)CELL_DERIVED <mu_c_multiplier_allsolids> [Pa.s] "<mu_species0>*(1.d0+2.5d0/(1.d0-<mu_phi_norm_allsolids>)+<mu_K_s>*<mu_phi_norm_allsolids>/(<mu_phi_max_allsolids>*(1.d0-<mu_phi_norm_allsolids>)**2))" ON <allcells> output
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_CONSTANT <mu_phi_max_allsolids> "<phi_max_allsolids>"
                     #(hash inserted during unwrap)NONE_CONSTANT <mu_phi_tol> "<phi_tol>"
                     #(hash inserted during unwrap)CELL_DERIVED <mu_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)/<mu_phi_max_allsolids>" output # here <mu_phi_max_allsolids> is used to scale across the range
                     #(hash inserted during unwrap)NONE_CONSTANT <n> "-2.5d0*<mu_phi_max_allsolids>"
                     #(hash inserted during unwrap)CELL_DERIVED <mu_c_multiplier_species1> [Pa.s] "<mu_species0>*((1.d0-(1.d0-<mu_phi_norm_allsolids>)**<n>)/(<mu_phi_max_allsolids>*<mu_phi_norm_allsolids>*(1.d0-<mu_phi_norm_allsolids>)**<n>) + 1.d0)" ON <allcells> output
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "in single_species_viscosity: viscosity_method = morrisboulay99 not coded yet or unknown"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)END_IF
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)# now construct viscosity and correction viscosity (multiplier) for faces (which tends to a finite value at phi->0 - ie, a non-specific viscosity)
            #(hash inserted during unwrap)CELL_LOCAL <mu_c_species1> "<mu_c_multiplier_species1>*<phi_bounded_species1>" ON <allcells> output
            #(hash inserted during unwrap)FACE_DERIVED <mu_f_species1> "faceave[harmonic](<mu_c_species1>)" ON <allfaces> output # used in stress
            #(hash inserted during unwrap)FACE_DERIVED <mu_f_correction_species1> "faceave[adjacentcells](<mu_c_multiplier_species1>)" ON <allfaces> output # used in rhie-chow
            #(hash inserted during unwrap)
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 1
            #(hash inserted during unwrap)ELSE
            # in version2 the viscous stress divergence is phase specific, so the viscosity for each phase is roughly a constant as phi -> 0
            # the multiplier used in the u_f_{correction} calculation is equal to the viscosity
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 2
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)# define the fluid stress, which is in version2 a mixture stress
               #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)# simplest einstein relationship, for a single phase
                  #(hash inserted during unwrap)CELL_DERIVED <mu_c_species1> [Pa.s] "<mu_species0>*(1.d0+2.5d0*<phi_bounded_species1>)" ON <allcells>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)# for more than one solid use fluid phi to calculate total
                  #(hash inserted during unwrap)CELL_DERIVED <mu_c_species1> [Pa.s] "<mu_species0>*(1.d0+2.5d0*(1.d0-<phi_bounded_species0>))" ON <allcells>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)# methods that have a maximum total solids magnitude, and can be expressed as a function of total solid volume fraction
                  #(hash inserted during unwrap)NONE_CONSTANT <mu_phi_max_allsolids> "<phi_max_allsolids>"
                  #(hash inserted during unwrap)NONE_CONSTANT <mu_phi_tol> "<phi_tol>"
                  #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)NONE_CONSTANT <mu_K_s> 0.1d0
                     #(hash inserted during unwrap)CELL_DERIVED <mu_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)/<mu_phi_max_allsolids>" output # here <mu_phi_max_allsolids> is used to scale across the range
                     #(hash inserted during unwrap)CELL_DERIVED <mu_c_species1> [Pa.s] "<mu_species0>*(1.d0+2.5d0*<mu_phi_norm_allsolids>/(1.d0-<mu_phi_norm_allsolids>)+<mu_K_s>*(<mu_phi_norm_allsolids>/(1.d0-<mu_phi_norm_allsolids>))**2)" ON <allcells> output
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)CELL_DERIVED <mu_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)/<mu_phi_max_allsolids>" output # here <mu_phi_max_allsolids> is used to scale across the range
                     #(hash inserted during unwrap)CELL_DERIVED <mu_c_species1> [Pa.s] "<mu_species0>*((<mu_phi_norm_allsolids>/(1.d0-<mu_phi_norm_allsolids>))**(2.5d0*<mu_phi_max_allsolids>))" ON <allcells> output
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)CELL_DERIVED <mu_phi_bounded_allsolids> "cellmin(1.d0-<phi_pos_species0>,<mu_phi_max_allsolids>-<mu_phi_tol>)" output # here <mu_phi_max_allsolids> is used as a cut-off
                     #(hash inserted during unwrap)CELL_DERIVED <mu_c_species1> [Pa.s] "<mu_species0>*(1.d0+2.5d0*<mu_phi_bounded_allsolids>+10.05d0*(<mu_phi_bounded_allsolids>)**2 + 0.00273d0*exp(16.6d0*<mu_phi_bounded_allsolids>))" ON <allcells> output
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 4
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "in single_species_viscosity: viscosity_method = morrisboulay99 not coded yet or unknown"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 2
               #(hash inserted during unwrap)ELSE
               # for these methods use the same viscosity across phases
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)# only fluid viscosity applied to solid phases, zhang97 = balls
                  #(hash inserted during unwrap)CELL_DERIVED <mu_c_species1> [Pa.s] "<mu_species0>" ON <allcells> output
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_viscosity.arb: sub_block = 3
                  #(hash inserted during unwrap)ELSE
                  # mixture viscosity applied to all phases, version2 = jackson98
                  CELL_LOCAL <mu_c_species1> [Pa.s] "<mu_c_species0>" ON <allcells> output
                  # could also do drew76, no viscosity applied to solid phases...
                  #(hash inserted during unwrap)END_IF
               
               #(hash inserted during unwrap)END_IF
            
            # now construct viscosity on faces for use in stress tensor, as well as viscosity for use in u_f rhiechow interpolation (correction)
            # note that for version2 the multiplier is actually just the viscosity - bad notation! - changed to correction viscosity
            FACE_DERIVED <mu_f_species1> "faceave[harmonic](<mu_c_species1>)" ON <allfaces> output # used in stress
            FACE_LOCAL <mu_f_correction_species1> "<mu_f_species1>" ON <allfaces> # used in rhie-chow
            
            #(hash inserted during unwrap)END_IF
      
      #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/total_stress.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "total_stress" # formulate stress tensors for all phases
      #(hash inserted during unwrap)MARKDOWN
      #(hash inserted during unwrap)Here we setup the viscous stresses for each phase, including the velocity gradients, using the navier_stokes template file
      #(hash inserted during unwrap)END_MARKDOWN
      
      #REPLACEMENTS D "<<stress_method>>" W "version1" # the gamma used in each phase is specific to that phase
      # the gamma used in each phase is a function of all velocities
      
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/total_stress.arb: sub_block = 1
         #(hash inserted during unwrap)IF 
         #(hash inserted during unwrap)
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/total_stress.arb: sub_block = 1
         #(hash inserted during unwrap)ELSE
         # version2
         # first assemble mixture averaged velocity
         # calculate velocity gradients for all species at the same time - time about variable type
         # performing index string loops on the following index list pairs:
         #  <<i>> 1,2
         CELL_DERIVED <u_mixture[l=1]> '0.d0' ON <allcells>
         CELL_DERIVED <u_mixture[l=2]> '0.d0' ON <allcells>
         # performing index string loops on the following index list pairs:
         #  <<i>> 1,2
         VARIABLE <u_mixture[l=1]> '<u_mixture[l=1]>+<phi_pos_species0>*<u_species0[l=1]>'
         VARIABLE <u_mixture[l=2]> '<u_mixture[l=2]>+<phi_pos_species0>*<u_species0[l=2]>'
         # performing index string loops on the following index list pairs:
         #  <<i>> 1,2
         #  <<j>> 1,2
         FACE_DERIVED <ugrad_f_species0[l=1,1]> 'facegrad[l=1,](<u_species0[l=1]>)' ON <allfaces>
         FACE_DERIVED <ugrad_f_species0[l=2,1]> 'facegrad[l=2,](<u_species0[l=1]>)' ON <allfaces>
         FACE_DERIVED <ugrad_f_species0[l=1,2]> 'facegrad[l=1,reflect=2](<u_species0[l=2]>)' ON <allfaces>
         FACE_DERIVED <ugrad_f_species0[l=2,2]> 'facegrad[l=2,reflect=2](<u_species0[l=2]>)' ON <allfaces>
         # performing index string loops on the following index list pairs:
         #  <<i>> 1,2
         VARIABLE <u_mixture[l=1]> '<u_mixture[l=1]>+<phi_pos_species1>*<u_species1[l=1]>'
         VARIABLE <u_mixture[l=2]> '<u_mixture[l=2]>+<phi_pos_species1>*<u_species1[l=2]>'
         # performing index string loops on the following index list pairs:
         #  <<i>> 1,2
         #  <<j>> 1,2
         FACE_DERIVED <ugrad_f_species1[l=1,1]> 'facegrad[l=1,](<u_species1[l=1]>)' ON <allfaces>
         FACE_DERIVED <ugrad_f_species1[l=2,1]> 'facegrad[l=2,](<u_species1[l=1]>)' ON <allfaces>
         FACE_DERIVED <ugrad_f_species1[l=1,2]> 'facegrad[l=1,reflect=2](<u_species1[l=2]>)' ON <allfaces>
         FACE_DERIVED <ugrad_f_species1[l=2,2]> 'facegrad[l=2,reflect=2](<u_species1[l=2]>)' ON <allfaces>
         
         
         # calculate the fluid species0 viscous stress, which for all methods is now based on the mixture (volume) averaged velocity and mixture viscosity (and hence mixture stress)
         # performing index string loops on the following index list pairs:
         #  <<i>> 1,2
         #  <<j>> 1,2
         FACE_LOCAL <ugrad_f_mixture[l=1,1]> "facegrad[l=1,](<u_mixture[l=1]>)" ON <allfaces>
         FACE_LOCAL <ugrad_f_mixture[l=2,1]> "facegrad[l=2,](<u_mixture[l=1]>)" ON <allfaces>
         FACE_LOCAL <ugrad_f_mixture[l=1,2]> "facegrad[l=1,reflect=2](<u_mixture[l=2]>)" ON <allfaces>
         FACE_LOCAL <ugrad_f_mixture[l=2,2]> "facegrad[l=2,reflect=2](<u_mixture[l=2]>)" ON <allfaces>
         # performing index string loops on the following index list pairs:
         #  <<i>> 1,2
         #  <<j>> 1,2
         FACE_DERIVED <tau_species0[l=1,1]> "-<mu_f_species0>*(<ugrad_f_mixture[l=1,1]>+<ugrad_f_mixture[l=1,1]>)" ON <allfaces> 
         FACE_DERIVED <tau_species0[l=2,1]> "-<mu_f_species0>*(<ugrad_f_mixture[l=2,1]>+<ugrad_f_mixture[l=1,2]>)" ON <allfaces> 
         FACE_DERIVED <tau_species0[l=1,2]> "-<mu_f_species0>*(<ugrad_f_mixture[l=1,2]>+<ugrad_f_mixture[l=2,1]>)" ON <allfaces> 
         FACE_DERIVED <tau_species0[l=2,2]> "-<mu_f_species0>*(<ugrad_f_mixture[l=2,2]>+<ugrad_f_mixture[l=2,2]>)" ON <allfaces> # note, maxima will simplify diagonal components
         
         # and the solid phases stresses
         # here equal to the fluid stress which is based on mixture averaged velocities and a mixture viscosity, version2 = jackson98
         # note, only species0 viscosity used
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/total_stress.arb: sub_block = 2
            #(hash inserted during unwrap)IF 1
            # performing index string loops on the following index list pairs:
            #  <<i>> 1,2
            #  <<j>> 1,2
            FACE_DERIVED <tau_species1[l=1,1]> '<tau_species0[l=1,1]>' ON <allfaces>
            FACE_DERIVED <tau_species1[l=2,1]> '<tau_species0[l=2,1]>' ON <allfaces>
            FACE_DERIVED <tau_species1[l=1,2]> '<tau_species0[l=1,2]>' ON <allfaces>
            FACE_DERIVED <tau_species1[l=2,2]> '<tau_species0[l=2,2]>' ON <allfaces>
            
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/total_stress.arb: sub_block = 2
            #(hash inserted during unwrap)ELSE # balls = zhang97
            #(hash inserted during unwrap)# here equal to the fluid stress based on fluid velocities and fluid viscosity
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)END_IF
         #(hash inserted during unwrap)END_IF
      #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 1
      #(hash inserted during unwrap)IF 0
      #(hash inserted during unwrap)INCLUDE "species_pressure" 
      #(hash inserted during unwrap)# calculate all disperse phase pressures
      #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 1
      #(hash inserted during unwrap)ELSE
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/species_pressure.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "species_pressure" # calculate all disperse phase pressures
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Here we setup the pressure for each species, using the single_species_pressure template file
         #(hash inserted during unwrap)END_MARKDOWN
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_pressure.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE_LOCAL 'single_species_pressure' 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)Here we find <p_species> for each disperse phase species species1
            #(hash inserted during unwrap)END_MARKDOWN
            
            # first add osmotic pressure using separate template
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_osmotic_pressure.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "single_species_osmotic_pressure"
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)Here we find the osmotic pressure for a disperse phase species species1
               #(hash inserted during unwrap)END_MARKDOWN
               
               # this specifies the type of osmotic pressure function
               #REPLACEMENTS D "<<osmotic_pressure_method>>" W "none"
               #REPLACEMENTS D "<<osmotic_pressure_method>>" W "dilute"
               #REPLACEMENTS D "<<osmotic_pressure_method>>" W "carnahanstarling"
               # same as carnahanstarling, but goes to infinity at <p_osmotic_phi_max_allsolids> rather than 1
               #REPLACEMENTS D "<<osmotic_pressure_method>>" W "carnahanstarlingsinglelimited"
               
               # we can also include steric hindrance using some type of step function
               
               #REPLACEMENTS D "<<steric_pressure_method>>" W "step"
               
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_osmotic_pressure.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)NONE_CONSTANT <p_osmotic_multiplier_species1> [Pa] "0.d0"
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_osmotic_pressure.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)# linear osmotic pressure, dilute assumption, multiplier is location independent
                  #(hash inserted during unwrap)NONE_CONSTANT <p_osmotic_multiplier_species1> [Pa] "<k_boltzmann>*<T>/<V_species1>"
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_osmotic_pressure.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)NONE_CONSTANT <p_osmotic_phi_max_species1> "<phi_max_allsolids>"
                  #(hash inserted during unwrap)NONE_CONSTANT <p_osmotic_phi_tol> "<phi_tol>"
                  #(hash inserted during unwrap)CELL_DERIVED <p_osmotic_phi_norm_species1> "cellmin(<phi_pos_species1>,<p_osmotic_phi_max_species1>-<p_osmotic_phi_tol>)/<p_osmotic_phi_max_species1>" output
                  #(hash inserted during unwrap)CELL_DERIVED <p_osmotic_Z_species1> [Pa] "(1.d0+<p_osmotic_phi_norm_species1>+<p_osmotic_phi_norm_species1>^2-<p_osmotic_phi_norm_species1>^3)/((1.d0-<p_osmotic_phi_norm_species1>)^3)" ON <allcells>
                  #(hash inserted during unwrap)CELL_LOCAL <p_osmotic_multiplier_species1> [Pa] "<k_boltzmann>*<T>*<p_osmotic_Z_species1>/<V_species1>" ON <allcells>
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_osmotic_pressure.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE
                  # methods that have a maximum total solids magnitude, with a multiplier that can be expressed as a function of total solid volume fraction
                  # create a possibly normalised and limited phi for use in the allsolids multiplier
                  NONE_CONSTANT <p_osmotic_phi_max_allsolids> "<phi_max_allsolids>"
                  NONE_CONSTANT <p_osmotic_phi_tol> "<phi_tol>"
                  CELL_DERIVED <p_osmotic_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<p_osmotic_phi_max_allsolids>-<p_osmotic_phi_tol>)/<p_osmotic_phi_max_allsolids>" output
                  
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_osmotic_pressure.arb: sub_block = 2
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)# for the true carnahanstarling method the osmotic pressure approaches infinity at phi=1
                     #(hash inserted during unwrap)NONE_CONSTANT <p_osmotic_phi_max_allsolids> 1.d0
                     #(hash inserted during unwrap)END_IF
                  
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_osmotic_pressure.arb: sub_block = 2
                     #(hash inserted during unwrap)IF 1
                     CELL_DERIVED <p_osmotic_Z_allsolids> [Pa] "(1.d0+<p_osmotic_phi_norm_allsolids>+<p_osmotic_phi_norm_allsolids>^2-<p_osmotic_phi_norm_allsolids>^3)/((1.d0-<p_osmotic_phi_norm_allsolids>)^3)" ON <allcells>
                     
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_osmotic_pressure.arb: sub_block = 2
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "in single_species_osmotic_pressure: osmotic_pressure_method = carnahanstarlinglimited not coded yet or unknown"
                     #(hash inserted during unwrap)END_IF
                  
                  CELL_LOCAL <p_osmotic_multiplier_species1> [Pa] "<k_boltzmann>*<T>*<p_osmotic_Z_allsolids>/<V_species1>" ON <allcells>
                  
                  #(hash inserted during unwrap)END_IF
               
               CELL_LOCAL <p_osmotic_species1> "<p_osmotic_multiplier_species1>*<phi_species1>" ON <allcells> # note that phi here isn't limited so that negative osmotic pressures could be generated at boundaries where phi goes negative
               
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_osmotic_pressure.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# define some constants
                  #(hash inserted during unwrap)NONE_CONSTANT <p_steric_gradient_low> [Pa] 1.d+0
                  #(hash inserted during unwrap)NONE_CONSTANT <p_steric_gradient_high> [Pa] 1.d+5
                  #(hash inserted during unwrap)NONE_CONSTANT <p_steric_phi_max_allsolids> "<phi_max_allsolids>"
                  #(hash inserted during unwrap)NONE_CONSTANT <p_steric_delta_phi_1> 0.05d0
                  #(hash inserted during unwrap)NONE_CONSTANT <p_steric_delta_phi_2> 0.05d0
                  #(hash inserted during unwrap)NONE_CONSTANT <p_steric_A> "<p_steric_gradient_high>/(2.d0*<p_steric_delta_phi_2>)"
                  #(hash inserted during unwrap)NONE_CONSTANT <p_steric_phi_1_max> "<p_steric_phi_max_allsolids>-<p_steric_delta_phi_1>"
                  #(hash inserted during unwrap)NONE_CONSTANT <p_steric_phi_2_max> "<p_steric_phi_1_max>-<p_steric_delta_phi_2>"
                  #(hash inserted during unwrap)NONE_CONSTANT <p_steric_B> "<p_steric_phi_1_max>-<p_steric_delta_phi_2>/2.d0"
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)CELL_DERIVED <p_steric_phi_allsolids> "1.d0-<phi_pos_species0>" ON <allcells>
                  #(hash inserted during unwrap)CELL_LOCAL <p_steric_species1> "0.d0" ON <allcells> output
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_osmotic_pressure.arb: sub_block = 2
                     #(hash inserted during unwrap)IF 1 # add low contribution
                     #(hash inserted during unwrap)CELL_LOCAL <p_steric_species1> "<p_steric_gradient_low>*<phi_species1>"
                     #(hash inserted during unwrap)END_IF
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_osmotic_pressure.arb: sub_block = 2
                     #(hash inserted during unwrap)IF 1 # add high contribution
                     #(hash inserted during unwrap)CELL_LOCAL <p_steric_species1> "<p_steric_species1>+cellif(<p_steric_phi_allsolids>-<p_steric_phi_2_max>,(<phi_pos_species1>/<p_steric_phi_allsolids>)*cellif(<p_steric_phi_allsolids>-<p_steric_phi_1_max>,<p_steric_gradient_high>*(<p_steric_phi_allsolids>-<p_steric_B>),<p_steric_A>*(<p_steric_phi_allsolids>-<p_steric_phi_2_max>)^2),0.d0)"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)CELL_LOCAL <p_osmotic_species1> "<p_osmotic_species1>+<p_steric_species1>"
                  #(hash inserted during unwrap)END_IF
            CELL_DERIVED <p_species1> "<p_osmotic_species1>"
            FACE_LOCAL <p_osmotic_f_species1> "faceave(<p_osmotic_species1>)" ON <allfaces> # just used in visualise_forces
            
            # next sid pressure too
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_pressure.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)INCLUDE "single_species_sid_pressure"
               #(hash inserted during unwrap)CELL_DERIVED <p_species1> "<p_species1> + <p_sid_species1>"
               #(hash inserted during unwrap)FACE_LOCAL <p_sid_f_species1> "faceave(<p_sid_species1>)" ON <allfaces> # just used in visualise_forces
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_pressure.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               FACE_LOCAL <p_sid_f_species1> "0.d0" ON <allfaces> # just used in visualise_forces
               #(hash inserted during unwrap)END_IF
            
            FACE_DERIVED <p_f_species1> "faceave(<p_species1>)" ON <allfaces>
         
      #(hash inserted during unwrap)END_IF
      #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 1
      #(hash inserted during unwrap)IF 0
      #(hash inserted during unwrap)INCLUDE "species_drag" 
      #(hash inserted during unwrap)# calculate all continuous to disperse phase drag functions
      #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 1
      #(hash inserted during unwrap)ELSE
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/species_drag.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "species_drag" # calculate all continuous to disperse phase drag functions
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Here we setup the drag functions for each disperse phase species, using the single_species_drag template file.  Right now only drag between the continuous (species0) and disperse phases is included.
         #(hash inserted during unwrap)END_MARKDOWN
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE_LOCAL 'single_species_drag' 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)Here we find <beta*_species1_species0> and <beta*_species0_species1> for combinations of species in which one of them is the continuous phase (species0)
            #(hash inserted during unwrap)END_MARKDOWN
            
            #OVERRIDE_OPTIONS output
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 1
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)ERROR "single_species_drag can only be called with disperse phase species: was called with species = species1"
               #(hash inserted during unwrap)END_IF
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/default_replacement_strings.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "default_replacement_strings"
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)Set some default equation settings via replacement strings for the multifluid problem
               #(hash inserted during unwrap)END_MARKDOWN
               
               # <<implicitadvection>> modifies both the advection of phi and u, making both implicit (ie, using r=0 values rather than r=1 values).  You need implicit advection to be able to push CFL over 1.
               # default is now implicit advection
               
               #GLOBAL_REPLACEMENTS D "<<stress_method>>" W "version1" # method, with phi inside viscous stress divergence
               # as per jackson98 and zhang97, have phi outside of stress divergence, version2 default = zhang97 = jackson98 = balls
               
               # default hindered settling function is now as defined in masliyah79 = balls
               # version1 gives an equivalent hindered settling function which is / phi_0^2
               
               
               # method used for rhie-chow u_f interpolation
               
               #GLOBAL_REPLACEMENTS D '<<u_f_method>>' W 'species' # default behaviour for v0.60
               
            
            # this string is now set globally in constants, but can be overwritten with local values here
            
            
            # default hindered settling function is now as defined in masliyah79 = balls
            # version1 gives an equivalent hindered settling function which is / phi_0^2
            
            #REPLACEMENTS D "<<hindered_settling_function>>" W "dilute" # = stokes
            #REPLACEMENTS D "<<hindered_settling_function>>" W "richardsonzaki"
            # same as richardsonzaki, but phi is scaled so that behaviour at <drag_phi_max_allsolids> matches that of the standard richardsonzaki at phi = 0.68
            #REPLACEMENTS D "<<hindered_settling_function>>" W "rourkeernstene" # from kim16, referencing Rourke and Ernstene 1930, which is specifically for rbcs
            
            # calculate beta^ at the faces, and then average to the cells.  Otherwise (default), calculate at the cells and then average to the faces
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 1
               #(hash inserted during unwrap)BLOCK # enclose replacements inside a block to isolate them from later expressions
               
               # setup replacements so that code only has to be written once, but can be used for face or cell centred calculation
               # these are the default replacements to be used if beta is to be calculated at cells first
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 0
                  #(hash inserted during unwrap)# use these replacements if variables are going to be face based
                  #(hash inserted during unwrap)END_IF
               
               # calculate kappa*, which only has one value for each combination of species, define with the lower index coming first
               #Stokes drag = dilute
               CELL_DERIVED <kappa*_species0_species1> "2.d0*<a_species1>^2/9.d0" ON <allcells> 
               
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 1
                  # if we are here then the drag is not dilute
                  
                  # methods that have a maximum total solids magnitude
                  # create a possibly normalised and limited phi for use in the allsolids multiplier
                  NONE_CONSTANT <drag_phi_tol> "<phi_tol>"
                  
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 3
                     #(hash inserted during unwrap)IF 1
                     NONE_CONSTANT <drag_phi_packed_richardsonzaki> 0.68d0 # used for scaling the phi used in the hindered settling function, this is the phi that we assume the normal richardsonzaki drag represents packed hard-sphere behaviour
                     NONE_CONSTANT <drag_richardsonzaki_n> 5.5d0 # exponent used in the richardsonzaki hindered settling function
                        #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 4
                        #(hash inserted during unwrap)IF 
                        #(hash inserted during unwrap)# for the true richardsonzaki method to recover the non-scaled variable, set the max to 0.68
                        #(hash inserted during unwrap)NONE_CONSTANT <drag_phi_max_allsolids> "<drag_phi_packed_richardsonzaki>"
                        #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 4
                        #(hash inserted during unwrap)ELSE_IF 1
                        NONE_CONSTANT <drag_phi_max_allsolids> "<phi_max_allsolids>"
                        #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 4
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)ERROR "hindered_settling_function = richardsonzakilimited not known in single_species_drag"
                        #(hash inserted during unwrap)END_IF
                     CELL_LOCAL <drag_phi_norm_allsolids> "<drag_phi_packed_richardsonzaki>*cellmin(1.d0-<phi_pos_species0>,<drag_phi_max_allsolids>-<drag_phi_tol>)/<drag_phi_max_allsolids>" ON <allcells> output
                     
                     # for now use total solids fraction to calculate hindered settling function
                     VARIABLE <kappa*_species0_species1> "(<kappa*_species0_species1>)*(1.d0-<drag_phi_norm_allsolids>)**<drag_richardsonzaki_n>" ON <allcells>	
                     
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)# FIXME
                     #(hash inserted during unwrap)ERROR "not done yet"
                     #(hash inserted during unwrap)NONE_CONSTANT <drag_phi_max_allsolids> "<phi_max_allsolids>"
                     #(hash inserted during unwrap)CELL_LOCAL <drag_phi_norm_allsolids> "cellmin(1.d0-<phi_pos_species0>,<drag_phi_max_allsolids>-<drag_phi_tol>)/<drag_phi_max_allsolids>" ON <allcells> output
                     #(hash inserted during unwrap)VARIABLE <kappa*_species0_species1> "(<kappa*_species0_species1>)*(1.d0-<drag_phi_norm_allsolids>)**<drag_richardsonzaki_n>" ON <allcells>	
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)# FIXME
                     #(hash inserted during unwrap)ERROR "hindered_settling_function = richardsonzakilimited not known in single_species_drag"
                     #(hash inserted during unwrap)END_IF
                  
                  #(hash inserted during unwrap)END_IF
               
               #(hash inserted during unwrap)END_BLOCK
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)ERROR "face based drag has to be version2 only, in single_species_drag"
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)FACE_DERIVED <beta^_f_species1_species0> "<mu_species0>/<kappa*_f_species0_species1>" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 1
                  #(hash inserted during unwrap)FACE_DERIVED <beta^_f_species0_species1> "<beta^_f_species1_species0>*<phi_f_bounded_species1>/<phi_f_bounded_species0>" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)FACE_DERIVED <beta^_f_species0_species1> "<beta^_f_species1_species0>*<phi_f_bounded_adjacent_nob_species1>/(<phi_f_bounded_adjacent_nob_species0>)" ON <allfaces>
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 1 # base on real phi's rather than interpolating 
                  #(hash inserted during unwrap)CELL_LOCAL <beta^_species1_species0> "<beta^_f_species1_species0>" ON <allcells>
                  #(hash inserted during unwrap)CELL_LOCAL <beta^_species0_species1> "<beta^_species1_species0>*<phi_bounded_species1>/<phi_bounded_species0>" ON <allcells>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE # singular matrix problem
                  #(hash inserted during unwrap)CELL_LOCAL <beta^_species1_species0> "<beta^_f_species1_species0>" ON <allcells>
                  #(hash inserted during unwrap)CELL_LOCAL <beta^_species0_species1> "<beta^_f_species0_species1>" ON <allcells>
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)CELL_DERIVED <beta**_species0_species1> "<mu_species0>*<phi_bounded_species0>/<kappa*_species0_species1>" ON <allcells>
                  #(hash inserted during unwrap)CELL_LOCAL <beta^_species1_species0> "<beta**_species0_species1>*<phi_bounded_species0>" ON <allcells>
                  #(hash inserted during unwrap)CELL_LOCAL <beta^_species0_species1> "<beta**_species0_species1>*<phi_bounded_species1>" ON <allcells>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE
                  CELL_DERIVED <beta^_species1_species0> "<mu_species0>/<kappa*_species0_species1>" ON <allcells>
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 3
                     #(hash inserted during unwrap)IF 1 # bounded phi_<<species>>
                     CELL_DERIVED <beta^_species0_species1> "<beta^_species1_species0>*<phi_bounded_species1>/<phi_bounded_species0>" ON <allcells>
                     #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE # trial using pos for phi_<<species>>, given that this represents flux from species1 to species0
                     #(hash inserted during unwrap)CELL_DERIVED <beta^_species0_species1> "<beta^_species1_species0>*<phi_pos_species1>/<phi_bounded_species0>" ON <allcells>
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)END_IF
               
               # now calculate face centred betas from cell centred
               # there are a whole bunch of alternatives here, but harmonic of beta^ seems to the be only acceptable one
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 1 # harmonic averaging of beta^'s - works well for sedimentation
                  FACE_LOCAL <beta^_f_species0_species1> "faceave[harmonic](<beta^_species0_species1>)" ON <allfaces>
                  FACE_LOCAL <beta^_f_species1_species0> "faceave[harmonic](<beta^_species1_species0>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE_IF 0 # harmonic6 averaging of beta^'s, including using pos cutoff for beta^_species0 calc set above
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species0_species1> "faceave[limitedharmonic](<beta^_species0_species1>)" ON <allfaces>
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species1_species0> "faceave[harmonic](<beta^_species1_species0>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE_IF 0 # harmonic7 averaging of beta^'s
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species0_species1> "faceave[harmonic](<beta^_species0_species1>)" ON <allfaces>
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species1_species0> "faceave[harmonic](<beta^_species0_species1>*<phi_bounded_species1>)*faceave[harmonic](1.d0/<phi_bounded_species0>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE_IF 0 # harmonic8 averaging of beta^'s
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species0_species1> "faceave[harmonic](<beta^_species0_species1>)" ON <allfaces>
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species1_species0> "<beta^_f_species0_species1>*<phi_f_bounded_harmonic_species1>*faceave[harmonic](1.d0/<phi_bounded_species0>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE_IF 1 # harmonic9 averaging of beta^'s
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species0_species1> "faceave[adjacentcells](<beta^_species0_species1>)" ON <allfaces>
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species1_species0> "faceave[harmonic](<beta^_species1_species0>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE_IF 0 # harmonic2 - adjacent cell averaging of beta, then dividing by the same average for phi as used in the osmotic pressure - checkerboarding in sedimentation problem
                  #(hash inserted during unwrap)CELL_LOCAL <beta_species1_species0> "<mu_species0>*<phi_bounded_species1>/<kappa*_species0_species1>" ON <allcells>
                  #(hash inserted during unwrap)CELL_LOCAL <beta_species0_species1> "<beta_species1_species0>" ON <allcells>
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species0_species1> "faceave[adjacent](<beta_species0_species1>)/<phi_f_bounded_harmonic_species0>" ON <allfaces>
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species1_species0> "faceave[adjacent](<beta_species1_species0>)/<phi_f_bounded_harmonic_species1>" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE_IF 0 # harmonic3 - harmonic cell averaging of beta, then dividing by the bounded adjacent average for phi - checkerboarding in sedimentation problem
                  #(hash inserted during unwrap)CELL_LOCAL <beta_species1_species0> "<mu_species0>*<phi_bounded_species1>/<kappa*_species0_species1>" ON <allcells>
                  #(hash inserted during unwrap)CELL_LOCAL <beta_species0_species1> "<beta_species1_species0>" ON <allcells>
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species0_species1> "faceave[harmonic](<beta_species0_species1>)/<phi_f_bounded_adjacent_species0>" ON <allfaces>
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species1_species0> "faceave[harmonic](<beta_species1_species0>)/<phi_f_bounded_adjacent_species1>" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE_IF 1 # harmonic4 - average beta^_<<species>>, which should be fairly uniform, and then create beta^_species0 using local phis which are harmonically averaged, but chosing the species0 one so that the total volume fraction is 1 still
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species1_species0> "faceave[harmonic](<beta^_species1_species0>)" ON <allfaces>
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)VARIABLE <phi_f_bounded_harmonic_allsolids> output
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species0_species1> "<beta^_f_species1_species0>*<phi_f_bounded_harmonic_species1>/(1.d0-<phi_f_bounded_harmonic_allsolids>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE_IF 0 # harmonic5 - should be roughly equivalent to harmonic1, but in practice, doesn't seem to be??
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species1_species0> "faceave[harmonic](<beta^_species1_species0>)" ON <allfaces>
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species0_species1> "<beta^_f_species1_species0>*faceave[harmonic](<phi_bounded_species1>/<phi_bounded_species0>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE_IF 0 # arithmetic averaging of beta^'s
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species0_species1> "<beta^_species0_species1>" ON <allfaces>
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species1_species0> "<beta^_species1_species0>" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE_IF 0 # adjacentcell averaging of beta^'s - seems to be the most stable
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species0_species1> "faceave[adjacentcells](<beta^_species0_species1>)" ON <allfaces>
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species1_species0> "faceave[adjacentcells](<beta^_species1_species0>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE_IF 0 # adjacentcell averaging of beta^'s, except at boundaries
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species0_species1> "faceave[adjacentdomaincells](<beta^_species0_species1>)" ON <allfaces> output
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species1_species0> "faceave[adjacentdomaincells](<beta^_species1_species0>)" ON <allfaces> output
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_drag.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE # average beta^_<<species>>, which should be fairly uniform, and then create beta^_species0 using local phis - think that this might be causing problems
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species1_species0> "faceave[adjacentcells](<beta^_species1_species0>)" ON <allfaces>
                  #(hash inserted during unwrap)FACE_LOCAL <beta^_f_species0_species1> "<beta^_f_species1_species0>*<phi_f_bounded_adjacent_species1>/<phi_f_bounded_adjacent_species0>" ON <allfaces>
                  #(hash inserted during unwrap)END_IF
               
               VARIABLE <beta^_f_species1_species0> output
               VARIABLE <beta^_f_species0_species1> output
               
               #(hash inserted during unwrap)END_IF
         
      #(hash inserted during unwrap)END_IF
      #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/u_f.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "u_f" # setup the dynamic forces, p_error and u_f for all phases
      #(hash inserted during unwrap)MARKDOWN
      #(hash inserted during unwrap)Here we setup the face flux velocity u_f for each phase, basically following the same ideas as the navier-stokes file
      #(hash inserted during unwrap)END_MARKDOWN
      
      # ensure that <<u_f_method>> has been set
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/default_replacement_strings.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE_LOCAL "default_replacement_strings"
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Set some default equation settings via replacement strings for the multifluid problem
         #(hash inserted during unwrap)END_MARKDOWN
         
         # <<implicitadvection>> modifies both the advection of phi and u, making both implicit (ie, using r=0 values rather than r=1 values).  You need implicit advection to be able to push CFL over 1.
         # default is now implicit advection
         
         #GLOBAL_REPLACEMENTS D "<<stress_method>>" W "version1" # method, with phi inside viscous stress divergence
         # as per jackson98 and zhang97, have phi outside of stress divergence, version2 default = zhang97 = jackson98 = balls
         
         # default hindered settling function is now as defined in masliyah79 = balls
         # version1 gives an equivalent hindered settling function which is / phi_0^2
         
         
         # method used for rhie-chow u_f interpolation
         
         #GLOBAL_REPLACEMENTS D '<<u_f_method>>' W 'species' # default behaviour for v0.60
         
      
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/u_f.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1 # only calculate the dynamic_force correction if it isn't already defined
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/dynamic_force.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "dynamic_force"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)Here we calculate the dynamic forces, including <dynamic_force_c[l=:]>, <dynamic_force_f> and <dynamic_force_f_{correction}>
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Note that <dynamic_force_f_{correction}> has different interpretations depending on mixture
            #(hash inserted during unwrap)END_MARKDOWN
            
            # ensure that <<u_f_method>> has been set
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/default_replacement_strings.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "default_replacement_strings"
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)Set some default equation settings via replacement strings for the multifluid problem
               #(hash inserted during unwrap)END_MARKDOWN
               
               # <<implicitadvection>> modifies both the advection of phi and u, making both implicit (ie, using r=0 values rather than r=1 values).  You need implicit advection to be able to push CFL over 1.
               # default is now implicit advection
               
               #GLOBAL_REPLACEMENTS D "<<stress_method>>" W "version1" # method, with phi inside viscous stress divergence
               # as per jackson98 and zhang97, have phi outside of stress divergence, version2 default = zhang97 = jackson98 = balls
               
               # default hindered settling function is now as defined in masliyah79 = balls
               # version1 gives an equivalent hindered settling function which is / phi_0^2
               
               
               # method used for rhie-chow u_f interpolation
               
               #GLOBAL_REPLACEMENTS D '<<u_f_method>>' W 'species' # default behaviour for v0.60
               
            
            # the region <correctionfaces> should be defined if it isn't already
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/dynamic_force.arb: sub_block = 1
               #(hash inserted during unwrap)IF 1 # only calculate the dynamic_force correction if it isn't already defined
               FACE_REGION <correctionfaces> "all" ON <domainfaces>
               #(hash inserted during unwrap)END_IF
            
            # first use the navier_stokes dynamic_force template to create the variables
               #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/dynamic_force' 
               
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)Dynamic force is the sum of forces, including the pressure force, that could cause fluid movement
               #(hash inserted during unwrap)It is added directly to the momentum equations, and used in calculating <dynamic_force_f_{correction}_species0> used in the face velocity interpolation
               #(hash inserted during unwrap)The pressure gradient is calculated via a divergence (consistent with momentum conservation) (on boundary cells values from the adjacent domain cells will be used)
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)A Rhie-Chow-type velocity interpolation is applied to the face flux velocities, and this requires the difference between the facecentred dynamic force (<dynamic_force_f_species0>) and the averaged component of the cell centred dynamic force (<dynamic_force_c_species0[l=:]>), <dynamic_force_f_{correction}_species0>
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)Other dynamic_force templates (eg, vof, electrokinetics) increment both <dynamic_force_c_species0[l=:]> and <dynamic_force_f_species0>, but use the locations specified in this file
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)<dynamic_force_c_species0[l=:]> is on <allcells>, <dynamic_force_f_species0> is on <allfaces>, and <dynamic_force_f_{correction}_species0> is on <correctionfaces> (which can be redefined later if using rhiechow p extrapolation).
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)#History
               #(hash inserted during unwrap)Most of the contents of this file used to be called p_error, with <p_error> = -<dynamic_force_f_{correction}_species0>.  This was changed as <p_error> can include non-pressure effects, and because the sign difference was confusing.  <dynamic_force_f_{correction}_species0> drives <u_f_{correction}>, which is easier to understand/debug.
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)Dynamic force now has the physically correct sign!
               #(hash inserted during unwrap)END_MARKDOWN
               
               #---------------------------------
               # first calculate the cell centred dynamic force (previously contained in a separate file called dynamic_force)
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "p_f"
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Here we average the cell centred pressure <p_species0> to the faces producing <p_f_species0>.  The standard method is to use arithmetic averaging, as in
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)FACE_DERIVED <p_f_species0> "faceave(<p_species0>)" ON <allfaces>
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)Low order averaging adjacentcell averaging uses a distance weighted average of the adjacent cell values.  Select this by setting
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)High order adjacentcell averaging is as per low order adjacentcell averaging, except that the gradient within each cell is used to get a better estimate of the pressure on each side of the interface.  The amount of gradient used is set by `<p_f_grad_limiter>` which should be between 0.d0 (low order) and 1.d0 after the file is included.  To use this high order averaging set
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter_species0> 1.d0 # keep this between 0.d0 and 1.d0
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # this is the default pressure interpolation
                  FACE_DERIVED <p_f_species0> "faceave(<p_species0>)" ON <allfaces>
                  
                  # the following are based on averaging from the adjacentcells only, but possibly using high order averaging
                  
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)VARIABLE <p_f_species0> "faceave[adjacentcells](<p_species0>)" output
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 0
                     #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter_species0> 1.d0 # ranging from 1.d0 (highest order) to 0.d0 which will give same as <<pfadjacentcells>> above
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 1
                        #(hash inserted during unwrap)VARIABLE <p_f_species0> "faceave[adjacentcells](cellave[lastface](faceave[advection](<p_species0>,<facefromcelldirection>,<p_f_gradient_limiter_species0>)))" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE_IF 0
                        #(hash inserted during unwrap)VARIABLE <p_f_species0> "faceave[adjacentcellsevenweighting](cellave[lastface](faceave[advection](<p_species0>,<facefromcelldirection>,<p_f_gradient_limiter_species0>)))" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)VARIABLE <p_f_species0> "0.5d0*(faceave[advection](<p_species0>,1.d0,<p_f_gradient_limiter_species0>)+faceave[advection](<p_species0>,-1.d0,<p_f_gradient_limiter_species0>))" output
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 1
                           #(hash inserted during unwrap)VARIABLE <p_f_species0> "faceif(facedelta(<boundaries>),<p_species0>,<p_f_species0>)" # special case boundary face pressure value to be equal to boundary cell value.  Without this the boundary pressure will be equally weighted.
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)END_IF
               # performing index string loops on the following index list pairs:
               #  <<i>> 1,2
               CELL_DERIVED <dynamic_force_c_species0[l=1]> "-celldivgrad[l=1](<p_f_species0>)" ON <allcells>
               CELL_DERIVED <dynamic_force_c_species0[l=2]> "-celldivgrad[l=2](<p_f_species0>)" ON <allcells>
               
               #--------------------------------
               # now calculate the face centred <dynamic_force_f> and <dynamic_force_f_{correction}>
               
               # the region <correctionfaces> should be defined if it isn't already
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)IF  # only calculate the dynamic_force correction if it isn't already defined
                  #(hash inserted during unwrap)FACE_REGION <correctionfaces> "all" ON <domainfaces>
                  #(hash inserted during unwrap)END_IF
               
               # seems that using <dynamic_force_c_f[l=:]> usually consumes more memory and takes more time to compute, so remove it by default by including the following
               # in the far off future if nobody complains <dynamic_force_c_f[l=:]> may just disappear into the night
               # to bring back <dynamic_force_c_f[l=:]> set this string to 1 to turn this back on
               
               
               # for evaluating the face centred dynamic force there are three options: dxunit, facegrad and facegradadjacentcells
               # right now the default is dxunit, which works well, but implies that u_f_{correction} is not aligned with facenorm (noting that only the component of the correction is applied)
               # facegrad works but is not as effective in damping checkerboarding
               # facegradadjacentcells also works but the implications re directions aren't as clear as the above two options
               
               #GENERAL_REPLACEMENTS D "<<dynamic_force_f_method>>" W "facegrad"
               #GENERAL_REPLACEMENTS D "<<dynamic_force_f_method>>" W "facegradadjacentcells"
               
               # calculate <dynamic_force_c_f[l=:]> if requested
               # interpolation to face centres (for velocity correction) could be done using normal, adjacentcells or adjacentcellsevenweighting, but they're all about the same so choose the computationally simplest
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 0
                  #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                  #(hash inserted during unwrap)#  <<i>> 1,2
                  #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_c_f_species0[l=1]> "faceave[,adjacentcells](<dynamic_force_c_species0[l=1]>)"
                  #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_c_f_species0[l=2]> "faceave[reflect=2,adjacentcells](<dynamic_force_c_species0[l=2]>)"
                  #(hash inserted during unwrap)END_IF
               
               #{{ print "IN dynamic_force.arb\n".string_debug(); }}
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 1
                  # dxunit method
                  FACE_LOCAL <dynamic_force_f_species0> "-facegrad[dxunit](<p_species0>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
                  FACE_CONSTANT <dot_facenorm_facedxunit> "dot(<facenorm[l=:]>,<facedxunit[l=:]>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
                  # dxunit + dynamicforcecf
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species0> "(<dynamic_force_f_species0>-dot(<dynamic_force_c_f_species0[l=:]>,<facedxunit[l=:]>))*<dot_facenorm_facedxunit>" ON <correctionfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                     #(hash inserted during unwrap)ELSE
                     # dxunit - dynamicforcecf
                     # lastface is required when averaging the normal when we have periodic gluing, as we require the normal to be orientated relative to the original face, rather than its glued counterpart - this is now the default when cycling through the region adjacentfaceicells, which is used by faceave[adjacentcells]
                     # for reflect gluing, <dynamic_force_f_{correction}> is zero anyway
                     #   FACE_DERIVED <dynamic_force_f_{correction}> "faceif(<facereflectnorm>,(<dynamic_force_f>-faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <correctionfaces>
                     # need to fix code for adjacentdomaincells for this line to work                             
                     #   FACE_DERIVED <dynamic_force_f_{correction}> "faceif(<facereflectnorm>,(<dynamic_force_f>-faceave[adjacentdomaincells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <correctionfaces>
                     # workaround, explicit code                                                                  
                     FACE_DERIVED <dynamic_force_f_{correction}_species0> "faceif(<facereflectnorm>,(<dynamic_force_f_species0>-faceif(facedelta(region=<boundaries>),faceave[downcell](dot(<dynamic_force_c_species0[l=:]>,cellave[lastface](<facedxunit[l=:]>))),faceave[adjacentcells](dot(<dynamic_force_c_species0[l=:]>,cellave[lastface](<facedxunit[l=:]>)))))*<dot_facenorm_facedxunit>,0.d0)" ON <correctionfaces>
                     #(hash inserted during unwrap)END_IF
                  
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# facegrad method
                  #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_f_species0> "-facegrad(<p_species0>)" ON <allfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)# facegrad + dynamicforcecf
                     #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species0> "<dynamic_force_f_species0>-dot(<dynamic_force_c_f_species0[l=:]>,<facenorm[l=:]>)" ON <correctionfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)# facegrad - dynamicforcecf
                     #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species0> "faceif(<facereflectnorm>,<dynamic_force_f_species0>-faceave[adjacentcells](dot(<dynamic_force_c_species0[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <correctionfaces>
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)# adjacentcells method
                  #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_f_species0> "-facegrad[adjacentcells](<p_species0>)" ON <allfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)# facegradadjacentcells + dynamicforcecf
                     #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species0> "<dynamic_force_f_species0>-dot(<dynamic_force_c_f_species0[l=:]>,<facenorm[l=:]>)" ON <correctionfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)# facegradadjacentcells - dynamicforcecf
                     #(hash inserted during unwrap)#   FACE_DERIVED <dynamic_force_f_{correction}> "faceif(<facereflectnorm>,<dynamic_force_f>-faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <correctionfaces>
                     #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species0> "faceif(<facereflectnorm>,<dynamic_force_f_species0>-faceave[adjacentdomaincells](dot(<dynamic_force_c_species0[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <correctionfaces>
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)ERROR 'No valid dynamicforcefmethod is chosen in the navier_stokes/dynamic_force template file: string currently set as dxunit'
                  #(hash inserted during unwrap)END_IF
               #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/dynamic_force' 
               
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)Dynamic force is the sum of forces, including the pressure force, that could cause fluid movement
               #(hash inserted during unwrap)It is added directly to the momentum equations, and used in calculating <dynamic_force_f_{correction}_species1> used in the face velocity interpolation
               #(hash inserted during unwrap)The pressure gradient is calculated via a divergence (consistent with momentum conservation) (on boundary cells values from the adjacent domain cells will be used)
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)A Rhie-Chow-type velocity interpolation is applied to the face flux velocities, and this requires the difference between the facecentred dynamic force (<dynamic_force_f_species1>) and the averaged component of the cell centred dynamic force (<dynamic_force_c_species1[l=:]>), <dynamic_force_f_{correction}_species1>
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)Other dynamic_force templates (eg, vof, electrokinetics) increment both <dynamic_force_c_species1[l=:]> and <dynamic_force_f_species1>, but use the locations specified in this file
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)<dynamic_force_c_species1[l=:]> is on <allcells>, <dynamic_force_f_species1> is on <allfaces>, and <dynamic_force_f_{correction}_species1> is on <correctionfaces> (which can be redefined later if using rhiechow p extrapolation).
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)#History
               #(hash inserted during unwrap)Most of the contents of this file used to be called p_error, with <p_error> = -<dynamic_force_f_{correction}_species1>.  This was changed as <p_error> can include non-pressure effects, and because the sign difference was confusing.  <dynamic_force_f_{correction}_species1> drives <u_f_{correction}>, which is easier to understand/debug.
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)Dynamic force now has the physically correct sign!
               #(hash inserted during unwrap)END_MARKDOWN
               
               #---------------------------------
               # first calculate the cell centred dynamic force (previously contained in a separate file called dynamic_force)
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "p_f"
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Here we average the cell centred pressure <p_species0> to the faces producing <p_f_species0>.  The standard method is to use arithmetic averaging, as in
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)FACE_DERIVED <p_f_species0> "faceave(<p_species0>)" ON <allfaces>
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)Low order averaging adjacentcell averaging uses a distance weighted average of the adjacent cell values.  Select this by setting
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)High order adjacentcell averaging is as per low order adjacentcell averaging, except that the gradient within each cell is used to get a better estimate of the pressure on each side of the interface.  The amount of gradient used is set by `<p_f_grad_limiter>` which should be between 0.d0 (low order) and 1.d0 after the file is included.  To use this high order averaging set
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter_species0> 1.d0 # keep this between 0.d0 and 1.d0
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # this is the default pressure interpolation
                  FACE_DERIVED <p_f_species0> "faceave(<p_species0>)" ON <allfaces>
                  
                  # the following are based on averaging from the adjacentcells only, but possibly using high order averaging
                  
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)VARIABLE <p_f_species0> "faceave[adjacentcells](<p_species0>)" output
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 0
                     #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter_species0> 1.d0 # ranging from 1.d0 (highest order) to 0.d0 which will give same as <<pfadjacentcells>> above
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 1
                        #(hash inserted during unwrap)VARIABLE <p_f_species0> "faceave[adjacentcells](cellave[lastface](faceave[advection](<p_species0>,<facefromcelldirection>,<p_f_gradient_limiter_species0>)))" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE_IF 0
                        #(hash inserted during unwrap)VARIABLE <p_f_species0> "faceave[adjacentcellsevenweighting](cellave[lastface](faceave[advection](<p_species0>,<facefromcelldirection>,<p_f_gradient_limiter_species0>)))" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)VARIABLE <p_f_species0> "0.5d0*(faceave[advection](<p_species0>,1.d0,<p_f_gradient_limiter_species0>)+faceave[advection](<p_species0>,-1.d0,<p_f_gradient_limiter_species0>))" output
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 1
                           #(hash inserted during unwrap)VARIABLE <p_f_species0> "faceif(facedelta(<boundaries>),<p_species0>,<p_f_species0>)" # special case boundary face pressure value to be equal to boundary cell value.  Without this the boundary pressure will be equally weighted.
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)END_IF
               # performing index string loops on the following index list pairs:
               #  <<i>> 1,2
               CELL_DERIVED <dynamic_force_c_species1[l=1]> "-celldivgrad[l=1](<p_f_species0>)" ON <allcells>
               CELL_DERIVED <dynamic_force_c_species1[l=2]> "-celldivgrad[l=2](<p_f_species0>)" ON <allcells>
               
               #--------------------------------
               # now calculate the face centred <dynamic_force_f> and <dynamic_force_f_{correction}>
               
               # the region <correctionfaces> should be defined if it isn't already
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)IF  # only calculate the dynamic_force correction if it isn't already defined
                  #(hash inserted during unwrap)FACE_REGION <correctionfaces> "all" ON <domainfaces>
                  #(hash inserted during unwrap)END_IF
               
               # seems that using <dynamic_force_c_f[l=:]> usually consumes more memory and takes more time to compute, so remove it by default by including the following
               # in the far off future if nobody complains <dynamic_force_c_f[l=:]> may just disappear into the night
               # to bring back <dynamic_force_c_f[l=:]> set this string to 1 to turn this back on
               
               
               # for evaluating the face centred dynamic force there are three options: dxunit, facegrad and facegradadjacentcells
               # right now the default is dxunit, which works well, but implies that u_f_{correction} is not aligned with facenorm (noting that only the component of the correction is applied)
               # facegrad works but is not as effective in damping checkerboarding
               # facegradadjacentcells also works but the implications re directions aren't as clear as the above two options
               
               #GENERAL_REPLACEMENTS D "<<dynamic_force_f_method>>" W "facegrad"
               #GENERAL_REPLACEMENTS D "<<dynamic_force_f_method>>" W "facegradadjacentcells"
               
               # calculate <dynamic_force_c_f[l=:]> if requested
               # interpolation to face centres (for velocity correction) could be done using normal, adjacentcells or adjacentcellsevenweighting, but they're all about the same so choose the computationally simplest
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 0
                  #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                  #(hash inserted during unwrap)#  <<i>> 1,2
                  #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_c_f_species1[l=1]> "faceave[,adjacentcells](<dynamic_force_c_species1[l=1]>)"
                  #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_c_f_species1[l=2]> "faceave[reflect=2,adjacentcells](<dynamic_force_c_species1[l=2]>)"
                  #(hash inserted during unwrap)END_IF
               
               #{{ print "IN dynamic_force.arb\n".string_debug(); }}
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 1
                  # dxunit method
                  FACE_LOCAL <dynamic_force_f_species1> "-facegrad[dxunit](<p_species0>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
                  FACE_CONSTANT <dot_facenorm_facedxunit> "dot(<facenorm[l=:]>,<facedxunit[l=:]>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
                  # dxunit + dynamicforcecf
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species1> "(<dynamic_force_f_species1>-dot(<dynamic_force_c_f_species1[l=:]>,<facedxunit[l=:]>))*<dot_facenorm_facedxunit>" ON <correctionfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                     #(hash inserted during unwrap)ELSE
                     # dxunit - dynamicforcecf
                     # lastface is required when averaging the normal when we have periodic gluing, as we require the normal to be orientated relative to the original face, rather than its glued counterpart - this is now the default when cycling through the region adjacentfaceicells, which is used by faceave[adjacentcells]
                     # for reflect gluing, <dynamic_force_f_{correction}> is zero anyway
                     #   FACE_DERIVED <dynamic_force_f_{correction}> "faceif(<facereflectnorm>,(<dynamic_force_f>-faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <correctionfaces>
                     # need to fix code for adjacentdomaincells for this line to work                             
                     #   FACE_DERIVED <dynamic_force_f_{correction}> "faceif(<facereflectnorm>,(<dynamic_force_f>-faceave[adjacentdomaincells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <correctionfaces>
                     # workaround, explicit code                                                                  
                     FACE_DERIVED <dynamic_force_f_{correction}_species1> "faceif(<facereflectnorm>,(<dynamic_force_f_species1>-faceif(facedelta(region=<boundaries>),faceave[downcell](dot(<dynamic_force_c_species1[l=:]>,cellave[lastface](<facedxunit[l=:]>))),faceave[adjacentcells](dot(<dynamic_force_c_species1[l=:]>,cellave[lastface](<facedxunit[l=:]>)))))*<dot_facenorm_facedxunit>,0.d0)" ON <correctionfaces>
                     #(hash inserted during unwrap)END_IF
                  
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# facegrad method
                  #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_f_species1> "-facegrad(<p_species0>)" ON <allfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)# facegrad + dynamicforcecf
                     #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species1> "<dynamic_force_f_species1>-dot(<dynamic_force_c_f_species1[l=:]>,<facenorm[l=:]>)" ON <correctionfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)# facegrad - dynamicforcecf
                     #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species1> "faceif(<facereflectnorm>,<dynamic_force_f_species1>-faceave[adjacentcells](dot(<dynamic_force_c_species1[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <correctionfaces>
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)# adjacentcells method
                  #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_f_species1> "-facegrad[adjacentcells](<p_species0>)" ON <allfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)# facegradadjacentcells + dynamicforcecf
                     #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species1> "<dynamic_force_f_species1>-dot(<dynamic_force_c_f_species1[l=:]>,<facenorm[l=:]>)" ON <correctionfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)# facegradadjacentcells - dynamicforcecf
                     #(hash inserted during unwrap)#   FACE_DERIVED <dynamic_force_f_{correction}> "faceif(<facereflectnorm>,<dynamic_force_f>-faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <correctionfaces>
                     #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species1> "faceif(<facereflectnorm>,<dynamic_force_f_species1>-faceave[adjacentdomaincells](dot(<dynamic_force_c_species1[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <correctionfaces>
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)ERROR 'No valid dynamicforcefmethod is chosen in the navier_stokes/dynamic_force template file: string currently set as dxunit'
                  #(hash inserted during unwrap)END_IF
            
            
            # add on contributions due to disperse phase species pressures, possibly osmotic in nature so not multiplied by phi
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_dynamic_force.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE_LOCAL 'single_species_dynamic_force' 
               
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)Here we add contributions to the dynamic force due to the already calculated <p_species> for each disperse phase
               #(hash inserted during unwrap)END_MARKDOWN
               
               VARIABLE <dynamic_force_c_species1[l=1]> '<dynamic_force_c_species1[l=1]>-celldivgrad[l=1](<p_f_species1>)/(<phi_bounded_species1>)'
               VARIABLE <dynamic_force_c_species1[l=2]> '<dynamic_force_c_species1[l=2]>-celldivgrad[l=2](<p_f_species1>)/(<phi_bounded_species1>)'
               
               
               # trying different phi variables for the osmotic pressure term
               
               #REPLACEMENTS R "<<dynamic_force_f_phi_variable>>" W "<phi_f_bounded_adjacent_nob_<<species>>>" # version1, unstable in presence of large phi gradients
               #REPLACEMENTS R "<<dynamic_force_f_phi_variable>>" W "<phi_f_bounded_adjacent_<<species>>>"
               
               
               # now deal with dynamic_force_f
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 1
                  # we are now using the bounded phi from the adjacent domain cell when considering the boundaries, which is the relevant physical phi used in the rhiechow boundary condition treatment
                  # VARIABLE <dynamic_force_f_<<species>>> "<dynamic_force_f_<<species>>>-facegrad[dxunit](<p_<<species>>>)/(<phi_f_bounded_adjacent_<<species>>>)"
                  VARIABLE <dynamic_force_f_species1> "<dynamic_force_f_species1>-facegrad[dxunit](<p_species1>)/(<phi_f_bounded_harmonic_species1>)"
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)# VARIABLE <dynamic_force_f_<<species>>> "<dynamic_force_f_<<species>>>-facegrad(<p_<<species>>>)/(<phi_f_bounded_<<species>>>)"
                  #(hash inserted during unwrap)VARIABLE <dynamic_force_f_species1> "<dynamic_force_f_species1>-facegrad(<p_species1>)/(<phi_f_bounded_harmonic_species1>)"
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)# VARIABLE <dynamic_force_f_<<species>>> "<dynamic_force_f_<<species>>>-facegrad[adjacentcells](<p_<<species>>>)/(<phi_f_bounded_adjacent_<<species>>>)"
                  #(hash inserted during unwrap)VARIABLE <dynamic_force_f_species1> "<dynamic_force_f_species1>-facegrad[adjacentcells](<p_species1>)/(<phi_f_bounded_harmonic_species1>)"
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_dynamic_force.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)ERROR 'No valid dynamicforcefmethod is chosen in the multifluid/single_species_dynamic_force template file: string currently set as dxunit'
                  #(hash inserted during unwrap)END_IF
            
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/dynamic_force.arb: sub_block = 1
               #(hash inserted during unwrap)IF 1
               # for the mixture method, <dynamic_force_f_{correction}> is based solely on the phase pressures, without other body forces etc
               # calculate these here overwriting those calculated above, using navier_stokes templates but with dummy dynamic_force_c and dynamic_force_f variables
               # note that this does not touch <dynamic_force_c[l=:]> or <dynamic_force_f>, which are used in the momentum equations and boundary conditions, respectively
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/dynamic_force' 
                  
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Dynamic force is the sum of forces, including the pressure force, that could cause fluid movement
                  #(hash inserted during unwrap)It is added directly to the momentum equations, and used in calculating <dynamic_force_f_{correction}_species0> used in the face velocity interpolation
                  #(hash inserted during unwrap)The pressure gradient is calculated via a divergence (consistent with momentum conservation) (on boundary cells values from the adjacent domain cells will be used)
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)A Rhie-Chow-type velocity interpolation is applied to the face flux velocities, and this requires the difference between the facecentred dynamic force (<dynamic_force_corcalc_f_species0>) and the averaged component of the cell centred dynamic force (<dynamic_force_corcalc_c_species0[l=:]>), <dynamic_force_f_{correction}_species0>
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)Other dynamic_force templates (eg, vof, electrokinetics) increment both <dynamic_force_corcalc_c_species0[l=:]> and <dynamic_force_corcalc_f_species0>, but use the locations specified in this file
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)<dynamic_force_corcalc_c_species0[l=:]> is on <allcells>, <dynamic_force_corcalc_f_species0> is on <allfaces>, and <dynamic_force_f_{correction}_species0> is on <correctionfaces> (which can be redefined later if using rhiechow p extrapolation).
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)#History
                  #(hash inserted during unwrap)Most of the contents of this file used to be called p_error, with <p_error> = -<dynamic_force_f_{correction}_species0>.  This was changed as <p_error> can include non-pressure effects, and because the sign difference was confusing.  <dynamic_force_f_{correction}_species0> drives <u_f_{correction}>, which is easier to understand/debug.
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)Dynamic force now has the physically correct sign!
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  #---------------------------------
                  # first calculate the cell centred dynamic force (previously contained in a separate file called dynamic_force)
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 0
                     #(hash inserted during unwrap)INCLUDE "p_f"
                     #(hash inserted during unwrap)MARKDOWN
                     #(hash inserted during unwrap)Here we average the cell centred pressure <p_species0> to the faces producing <p_f_species0>.  The standard method is to use arithmetic averaging, as in
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)```arb
                     #(hash inserted during unwrap)FACE_DERIVED <p_f_species0> "faceave(<p_species0>)" ON <allfaces>
                     #(hash inserted during unwrap)```
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)Low order averaging adjacentcell averaging uses a distance weighted average of the adjacent cell values.  Select this by setting
                     #(hash inserted during unwrap)```arb
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)```
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)High order adjacentcell averaging is as per low order adjacentcell averaging, except that the gradient within each cell is used to get a better estimate of the pressure on each side of the interface.  The amount of gradient used is set by `<p_f_grad_limiter>` which should be between 0.d0 (low order) and 1.d0 after the file is included.  To use this high order averaging set
                     #(hash inserted during unwrap)```arb
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter_species0> 1.d0 # keep this between 0.d0 and 1.d0
                     #(hash inserted during unwrap)```
                     #(hash inserted during unwrap)END_MARKDOWN
                     
                     # this is the default pressure interpolation
                     FACE_DERIVED <p_f_species0> "faceave(<p_species0>)" ON <allfaces>
                     
                     # the following are based on averaging from the adjacentcells only, but possibly using high order averaging
                     
                     
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                        #(hash inserted during unwrap)IF 0
                        #(hash inserted during unwrap)VARIABLE <p_f_species0> "faceave[adjacentcells](<p_species0>)" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 0
                        #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter_species0> 1.d0 # ranging from 1.d0 (highest order) to 0.d0 which will give same as <<pfadjacentcells>> above
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                           #(hash inserted during unwrap)IF 1
                           #(hash inserted during unwrap)VARIABLE <p_f_species0> "faceave[adjacentcells](cellave[lastface](faceave[advection](<p_species0>,<facefromcelldirection>,<p_f_gradient_limiter_species0>)))" output
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                           #(hash inserted during unwrap)ELSE_IF 0
                           #(hash inserted during unwrap)VARIABLE <p_f_species0> "faceave[adjacentcellsevenweighting](cellave[lastface](faceave[advection](<p_species0>,<facefromcelldirection>,<p_f_gradient_limiter_species0>)))" output
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)VARIABLE <p_f_species0> "0.5d0*(faceave[advection](<p_species0>,1.d0,<p_f_gradient_limiter_species0>)+faceave[advection](<p_species0>,-1.d0,<p_f_gradient_limiter_species0>))" output
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 3
                              #(hash inserted during unwrap)IF 1
                              #(hash inserted during unwrap)VARIABLE <p_f_species0> "faceif(facedelta(<boundaries>),<p_species0>,<p_f_species0>)" # special case boundary face pressure value to be equal to boundary cell value.  Without this the boundary pressure will be equally weighted.
                              #(hash inserted during unwrap)END_IF
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)END_IF
                  # performing index string loops on the following index list pairs:
                  #  <<i>> 1,2
                  CELL_DERIVED <dynamic_force_corcalc_c_species0[l=1]> "-celldivgrad[l=1](<p_f_species0>)" ON <allcells>
                  CELL_DERIVED <dynamic_force_corcalc_c_species0[l=2]> "-celldivgrad[l=2](<p_f_species0>)" ON <allcells>
                  
                  #--------------------------------
                  # now calculate the face centred <dynamic_force_f> and <dynamic_force_f_{correction}>
                  
                  # the region <correctionfaces> should be defined if it isn't already
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                     #(hash inserted during unwrap)IF  # only calculate the dynamic_force correction if it isn't already defined
                     #(hash inserted during unwrap)FACE_REGION <correctionfaces> "all" ON <domainfaces>
                     #(hash inserted during unwrap)END_IF
                  
                  # seems that using <dynamic_force_c_f[l=:]> usually consumes more memory and takes more time to compute, so remove it by default by including the following
                  # in the far off future if nobody complains <dynamic_force_c_f[l=:]> may just disappear into the night
                  # to bring back <dynamic_force_c_f[l=:]> set this string to 1 to turn this back on
                  
                  
                  # for evaluating the face centred dynamic force there are three options: dxunit, facegrad and facegradadjacentcells
                  # right now the default is dxunit, which works well, but implies that u_f_{correction} is not aligned with facenorm (noting that only the component of the correction is applied)
                  # facegrad works but is not as effective in damping checkerboarding
                  # facegradadjacentcells also works but the implications re directions aren't as clear as the above two options
                  
                  #GENERAL_REPLACEMENTS D "<<dynamic_force_f_method>>" W "facegrad"
                  #GENERAL_REPLACEMENTS D "<<dynamic_force_f_method>>" W "facegradadjacentcells"
                  
                  # calculate <dynamic_force_c_f[l=:]> if requested
                  # interpolation to face centres (for velocity correction) could be done using normal, adjacentcells or adjacentcellsevenweighting, but they're all about the same so choose the computationally simplest
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                     #(hash inserted during unwrap)#  <<i>> 1,2
                     #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_corcalc_c_f_species0[l=1]> "faceave[,adjacentcells](<dynamic_force_corcalc_c_species0[l=1]>)"
                     #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_corcalc_c_f_species0[l=2]> "faceave[reflect=2,adjacentcells](<dynamic_force_corcalc_c_species0[l=2]>)"
                     #(hash inserted during unwrap)END_IF
                  
                  #{{ print "IN dynamic_force.arb\n".string_debug(); }}
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 1
                     # dxunit method
                     FACE_LOCAL <dynamic_force_corcalc_f_species0> "-facegrad[dxunit](<p_species0>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
                     FACE_CONSTANT <dot_facenorm_facedxunit> "dot(<facenorm[l=:]>,<facedxunit[l=:]>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
                     # dxunit + dynamicforcecf
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 0
                        #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species0> "(<dynamic_force_corcalc_f_species0>-dot(<dynamic_force_corcalc_c_f_species0[l=:]>,<facedxunit[l=:]>))*<dot_facenorm_facedxunit>" ON <correctionfaces>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                        # dxunit - dynamicforcecf
                        # lastface is required when averaging the normal when we have periodic gluing, as we require the normal to be orientated relative to the original face, rather than its glued counterpart - this is now the default when cycling through the region adjacentfaceicells, which is used by faceave[adjacentcells]
                        # for reflect gluing, <dynamic_force_f_{correction}> is zero anyway
                        #   FACE_DERIVED <dynamic_force_f_{correction}> "faceif(<facereflectnorm>,(<dynamic_force_f>-faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <correctionfaces>
                        # need to fix code for adjacentdomaincells for this line to work                             
                        #   FACE_DERIVED <dynamic_force_f_{correction}> "faceif(<facereflectnorm>,(<dynamic_force_f>-faceave[adjacentdomaincells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <correctionfaces>
                        # workaround, explicit code                                                                  
                        FACE_DERIVED <dynamic_force_f_{correction}_species0> "faceif(<facereflectnorm>,(<dynamic_force_corcalc_f_species0>-faceif(facedelta(region=<boundaries>),faceave[downcell](dot(<dynamic_force_corcalc_c_species0[l=:]>,cellave[lastface](<facedxunit[l=:]>))),faceave[adjacentcells](dot(<dynamic_force_corcalc_c_species0[l=:]>,cellave[lastface](<facedxunit[l=:]>)))))*<dot_facenorm_facedxunit>,0.d0)" ON <correctionfaces>
                        #(hash inserted during unwrap)END_IF
                     
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)# facegrad method
                     #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_corcalc_f_species0> "-facegrad(<p_species0>)" ON <allfaces>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 0
                        #(hash inserted during unwrap)# facegrad + dynamicforcecf
                        #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species0> "<dynamic_force_corcalc_f_species0>-dot(<dynamic_force_corcalc_c_f_species0[l=:]>,<facenorm[l=:]>)" ON <correctionfaces>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)# facegrad - dynamicforcecf
                        #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species0> "faceif(<facereflectnorm>,<dynamic_force_corcalc_f_species0>-faceave[adjacentcells](dot(<dynamic_force_corcalc_c_species0[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <correctionfaces>
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)# adjacentcells method
                     #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_corcalc_f_species0> "-facegrad[adjacentcells](<p_species0>)" ON <allfaces>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 0
                        #(hash inserted during unwrap)# facegradadjacentcells + dynamicforcecf
                        #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species0> "<dynamic_force_corcalc_f_species0>-dot(<dynamic_force_corcalc_c_f_species0[l=:]>,<facenorm[l=:]>)" ON <correctionfaces>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)# facegradadjacentcells - dynamicforcecf
                        #(hash inserted during unwrap)#   FACE_DERIVED <dynamic_force_f_{correction}> "faceif(<facereflectnorm>,<dynamic_force_f>-faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <correctionfaces>
                        #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species0> "faceif(<facereflectnorm>,<dynamic_force_corcalc_f_species0>-faceave[adjacentdomaincells](dot(<dynamic_force_corcalc_c_species0[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <correctionfaces>
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR 'No valid dynamicforcefmethod is chosen in the navier_stokes/dynamic_force template file: string currently set as dxunit'
                     #(hash inserted during unwrap)END_IF
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/dynamic_force' 
                  
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Dynamic force is the sum of forces, including the pressure force, that could cause fluid movement
                  #(hash inserted during unwrap)It is added directly to the momentum equations, and used in calculating <dynamic_force_f_{correction}_species1> used in the face velocity interpolation
                  #(hash inserted during unwrap)The pressure gradient is calculated via a divergence (consistent with momentum conservation) (on boundary cells values from the adjacent domain cells will be used)
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)A Rhie-Chow-type velocity interpolation is applied to the face flux velocities, and this requires the difference between the facecentred dynamic force (<dynamic_force_corcalc_f_species1>) and the averaged component of the cell centred dynamic force (<dynamic_force_corcalc_c_species1[l=:]>), <dynamic_force_f_{correction}_species1>
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)Other dynamic_force templates (eg, vof, electrokinetics) increment both <dynamic_force_corcalc_c_species1[l=:]> and <dynamic_force_corcalc_f_species1>, but use the locations specified in this file
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)<dynamic_force_corcalc_c_species1[l=:]> is on <allcells>, <dynamic_force_corcalc_f_species1> is on <allfaces>, and <dynamic_force_f_{correction}_species1> is on <correctionfaces> (which can be redefined later if using rhiechow p extrapolation).
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)#History
                  #(hash inserted during unwrap)Most of the contents of this file used to be called p_error, with <p_error> = -<dynamic_force_f_{correction}_species1>.  This was changed as <p_error> can include non-pressure effects, and because the sign difference was confusing.  <dynamic_force_f_{correction}_species1> drives <u_f_{correction}>, which is easier to understand/debug.
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)Dynamic force now has the physically correct sign!
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  #---------------------------------
                  # first calculate the cell centred dynamic force (previously contained in a separate file called dynamic_force)
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 0
                     #(hash inserted during unwrap)INCLUDE "p_f"
                     #(hash inserted during unwrap)MARKDOWN
                     #(hash inserted during unwrap)Here we average the cell centred pressure <p_species1> to the faces producing <p_f_species1>.  The standard method is to use arithmetic averaging, as in
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)```arb
                     #(hash inserted during unwrap)FACE_DERIVED <p_f_species1> "faceave(<p_species1>)" ON <allfaces>
                     #(hash inserted during unwrap)```
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)Low order averaging adjacentcell averaging uses a distance weighted average of the adjacent cell values.  Select this by setting
                     #(hash inserted during unwrap)```arb
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)```
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)High order adjacentcell averaging is as per low order adjacentcell averaging, except that the gradient within each cell is used to get a better estimate of the pressure on each side of the interface.  The amount of gradient used is set by `<p_f_grad_limiter>` which should be between 0.d0 (low order) and 1.d0 after the file is included.  To use this high order averaging set
                     #(hash inserted during unwrap)```arb
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter_species1> 1.d0 # keep this between 0.d0 and 1.d0
                     #(hash inserted during unwrap)```
                     #(hash inserted during unwrap)END_MARKDOWN
                     
                     # this is the default pressure interpolation
                     FACE_DERIVED <p_f_species1> "faceave(<p_species1>)" ON <allfaces>
                     
                     # the following are based on averaging from the adjacentcells only, but possibly using high order averaging
                     
                     
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                        #(hash inserted during unwrap)IF 0
                        #(hash inserted during unwrap)VARIABLE <p_f_species1> "faceave[adjacentcells](<p_species1>)" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 0
                        #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter_species1> 1.d0 # ranging from 1.d0 (highest order) to 0.d0 which will give same as <<pfadjacentcells>> above
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                           #(hash inserted during unwrap)IF 1
                           #(hash inserted during unwrap)VARIABLE <p_f_species1> "faceave[adjacentcells](cellave[lastface](faceave[advection](<p_species1>,<facefromcelldirection>,<p_f_gradient_limiter_species1>)))" output
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                           #(hash inserted during unwrap)ELSE_IF 0
                           #(hash inserted during unwrap)VARIABLE <p_f_species1> "faceave[adjacentcellsevenweighting](cellave[lastface](faceave[advection](<p_species1>,<facefromcelldirection>,<p_f_gradient_limiter_species1>)))" output
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)VARIABLE <p_f_species1> "0.5d0*(faceave[advection](<p_species1>,1.d0,<p_f_gradient_limiter_species1>)+faceave[advection](<p_species1>,-1.d0,<p_f_gradient_limiter_species1>))" output
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 3
                              #(hash inserted during unwrap)IF 1
                              #(hash inserted during unwrap)VARIABLE <p_f_species1> "faceif(facedelta(<boundaries>),<p_species1>,<p_f_species1>)" # special case boundary face pressure value to be equal to boundary cell value.  Without this the boundary pressure will be equally weighted.
                              #(hash inserted during unwrap)END_IF
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)END_IF
                  # performing index string loops on the following index list pairs:
                  #  <<i>> 1,2
                  CELL_DERIVED <dynamic_force_corcalc_c_species1[l=1]> "-celldivgrad[l=1](<p_f_species1>)" ON <allcells>
                  CELL_DERIVED <dynamic_force_corcalc_c_species1[l=2]> "-celldivgrad[l=2](<p_f_species1>)" ON <allcells>
                  
                  #--------------------------------
                  # now calculate the face centred <dynamic_force_f> and <dynamic_force_f_{correction}>
                  
                  # the region <correctionfaces> should be defined if it isn't already
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                     #(hash inserted during unwrap)IF  # only calculate the dynamic_force correction if it isn't already defined
                     #(hash inserted during unwrap)FACE_REGION <correctionfaces> "all" ON <domainfaces>
                     #(hash inserted during unwrap)END_IF
                  
                  # seems that using <dynamic_force_c_f[l=:]> usually consumes more memory and takes more time to compute, so remove it by default by including the following
                  # in the far off future if nobody complains <dynamic_force_c_f[l=:]> may just disappear into the night
                  # to bring back <dynamic_force_c_f[l=:]> set this string to 1 to turn this back on
                  
                  
                  # for evaluating the face centred dynamic force there are three options: dxunit, facegrad and facegradadjacentcells
                  # right now the default is dxunit, which works well, but implies that u_f_{correction} is not aligned with facenorm (noting that only the component of the correction is applied)
                  # facegrad works but is not as effective in damping checkerboarding
                  # facegradadjacentcells also works but the implications re directions aren't as clear as the above two options
                  
                  #GENERAL_REPLACEMENTS D "<<dynamic_force_f_method>>" W "facegrad"
                  #GENERAL_REPLACEMENTS D "<<dynamic_force_f_method>>" W "facegradadjacentcells"
                  
                  # calculate <dynamic_force_c_f[l=:]> if requested
                  # interpolation to face centres (for velocity correction) could be done using normal, adjacentcells or adjacentcellsevenweighting, but they're all about the same so choose the computationally simplest
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                     #(hash inserted during unwrap)#  <<i>> 1,2
                     #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_corcalc_c_f_species1[l=1]> "faceave[,adjacentcells](<dynamic_force_corcalc_c_species1[l=1]>)"
                     #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_corcalc_c_f_species1[l=2]> "faceave[reflect=2,adjacentcells](<dynamic_force_corcalc_c_species1[l=2]>)"
                     #(hash inserted during unwrap)END_IF
                  
                  #{{ print "IN dynamic_force.arb\n".string_debug(); }}
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 1
                     # dxunit method
                     FACE_LOCAL <dynamic_force_corcalc_f_species1> "-facegrad[dxunit](<p_species1>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
                     FACE_CONSTANT <dot_facenorm_facedxunit> "dot(<facenorm[l=:]>,<facedxunit[l=:]>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
                     # dxunit + dynamicforcecf
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 0
                        #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species1> "(<dynamic_force_corcalc_f_species1>-dot(<dynamic_force_corcalc_c_f_species1[l=:]>,<facedxunit[l=:]>))*<dot_facenorm_facedxunit>" ON <correctionfaces>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                        # dxunit - dynamicforcecf
                        # lastface is required when averaging the normal when we have periodic gluing, as we require the normal to be orientated relative to the original face, rather than its glued counterpart - this is now the default when cycling through the region adjacentfaceicells, which is used by faceave[adjacentcells]
                        # for reflect gluing, <dynamic_force_f_{correction}> is zero anyway
                        #   FACE_DERIVED <dynamic_force_f_{correction}> "faceif(<facereflectnorm>,(<dynamic_force_f>-faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <correctionfaces>
                        # need to fix code for adjacentdomaincells for this line to work                             
                        #   FACE_DERIVED <dynamic_force_f_{correction}> "faceif(<facereflectnorm>,(<dynamic_force_f>-faceave[adjacentdomaincells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <correctionfaces>
                        # workaround, explicit code                                                                  
                        FACE_DERIVED <dynamic_force_f_{correction}_species1> "faceif(<facereflectnorm>,(<dynamic_force_corcalc_f_species1>-faceif(facedelta(region=<boundaries>),faceave[downcell](dot(<dynamic_force_corcalc_c_species1[l=:]>,cellave[lastface](<facedxunit[l=:]>))),faceave[adjacentcells](dot(<dynamic_force_corcalc_c_species1[l=:]>,cellave[lastface](<facedxunit[l=:]>)))))*<dot_facenorm_facedxunit>,0.d0)" ON <correctionfaces>
                        #(hash inserted during unwrap)END_IF
                     
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)# facegrad method
                     #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_corcalc_f_species1> "-facegrad(<p_species1>)" ON <allfaces>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 0
                        #(hash inserted during unwrap)# facegrad + dynamicforcecf
                        #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species1> "<dynamic_force_corcalc_f_species1>-dot(<dynamic_force_corcalc_c_f_species1[l=:]>,<facenorm[l=:]>)" ON <correctionfaces>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)# facegrad - dynamicforcecf
                        #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species1> "faceif(<facereflectnorm>,<dynamic_force_corcalc_f_species1>-faceave[adjacentcells](dot(<dynamic_force_corcalc_c_species1[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <correctionfaces>
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)# adjacentcells method
                     #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_corcalc_f_species1> "-facegrad[adjacentcells](<p_species1>)" ON <allfaces>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 0
                        #(hash inserted during unwrap)# facegradadjacentcells + dynamicforcecf
                        #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species1> "<dynamic_force_corcalc_f_species1>-dot(<dynamic_force_corcalc_c_f_species1[l=:]>,<facenorm[l=:]>)" ON <correctionfaces>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)# facegradadjacentcells - dynamicforcecf
                        #(hash inserted during unwrap)#   FACE_DERIVED <dynamic_force_f_{correction}> "faceif(<facereflectnorm>,<dynamic_force_f>-faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <correctionfaces>
                        #(hash inserted during unwrap)FACE_DERIVED <dynamic_force_f_{correction}_species1> "faceif(<facereflectnorm>,<dynamic_force_corcalc_f_species1>-faceave[adjacentdomaincells](dot(<dynamic_force_corcalc_c_species1[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <correctionfaces>
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR 'No valid dynamicforcefmethod is chosen in the navier_stokes/dynamic_force template file: string currently set as dxunit'
                     #(hash inserted during unwrap)END_IF
               
               #(hash inserted during unwrap)END_IF
         #(hash inserted during unwrap)END_IF
      
      # run through all species, calculating the {raw} interpolated velocity u_f_{raw}, and then calculating all of the alpha coefficients
      FACE_DERIVED <u_f_{raw}_species0> 'dot(<u_f_vect_species0[l=:]>,<facenorm[l=:]>)' ON <allfaces>
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/u_f_coefficients' 
         
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Here we calculate the <u_f_alpha coefficients that each represent the relationship between change in velocity and change in dynamic force, based on an order-of-magnitude analysis of the momentum equations
         #(hash inserted during unwrap)There are potentially three coefficients, being transient, adv (advection) and vis (viscous)
         #(hash inserted during unwrap)IE, for navier-stokes:
         #(hash inserted during unwrap)<u_f_alpha_{transient}_species0>*(<u_f_{correction}>-<u_f_{correction}[r=1]>) + <u_f_alpha_{adv}_species0>*<u_f_{correction}> + <u_f_alpha_{vis}_species0>*<u_f_{correction}> = <C_{Rhie-Chow}>*<dynamic_force_f_{correction}_species0>
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)Now also defining a local <u_f_alpha_species0> which is the sum of the three alpha coefficients.
         #(hash inserted during unwrap)END_MARKDOWN
         
         # the region <correctionfaces> will have been defined when <dynamic_force_f_{correction}> was calculated
         
         # sum of all relvant alpha coefficients
         FACE_LOCAL <u_f_alpha_species0> "0.d0" ON <correctionfaces>
         
         # all equation variants here have viscous contribution, so add this first
         # same piece of code as in total_stress to deal with <mu_f> replacement - really clunky, for backwards compatibility
         # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 1
            #(hash inserted during unwrap)IF   # this evaluates as true (1) if replacement string '<mu_f>' isn't defined, AND <<uniformviscosity>> is on (1)
            #(hash inserted during unwrap)# if we are here then we apply the uniform viscosity substitution
            #(hash inserted during unwrap)END_IF
         FACE_LOCAL <u_f_alpha_{vis}_species0> "<mu_f_correction_species0>/<facedx>^2" ON <correctionfaces> # incase pextrapolationrhiechow is on, define these locals on allfaces (makes no difference to efficiency as they are locals anyway)
         VARIABLE <u_f_alpha_species0> "(<u_f_alpha_species0>)+<u_f_alpha_{vis}_species0>"
         
         # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 1
            #(hash inserted during unwrap)IF   # this evaluates as true (1) if replacement string '<rho_f>' isn't defined, AND <<uniformviscosity>> is on (1)
            #(hash inserted during unwrap)# if we are here then we apply the uniform density substitution
            #(hash inserted during unwrap)END_IF
         
         # advection term
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1 # only for navier-stokes equations
            #--------------
            # use this option to base the adv component on the total velocity magnitude, rather than the component over each face
            # the old way (pre v0.59) was to use <u_f_{raw}> which is the flux across the face when calculating the advective rhie-chow term
            # the new way (v0.59 and onwards) is based on the total velocity magnitude, so overwrite the string <<ufmagnitude>> with <u_f_vect_magnitude> which is the total magnitude of <u_f_vect[l=:]>
            
            #--------------
            # initialise variable using the old way, within the applicable block
               #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 2
               #(hash inserted during unwrap)IF 1 # ie, the new way
               # for a transient simulation the previous velocity magnitude is used, consistent with that used in the momentum advection
               # (although this can be overwritten by setting <<ufvectmagnitudeexplicit>> = 0 directly)
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 1
                  # performing index string loops on the following index list pairs:
                  #  <<i>> 1,2
                  FACE_LOCAL <u_f_vect_species0[l=1,r=1]> "faceave[](<u_species0[l=1,r=1]>)" ON <allfaces>
                  FACE_LOCAL <u_f_vect_species0[l=2,r=1]> "faceave[reflect=2](<u_species0[l=2,r=1]>)" ON <allfaces>
                  #     FACE_TRANSIENT <u_f_vect_magnitude[r=1]> "" "sqrt(facemax(dot(<u_f_vect[l=:,r=1]>,<u_f_vect[l=:,r=1]>),<tinyish>))" ON <correctionfaces>
                  FACE_TRANSIENT <u_f_vect_magnitude_species0[r=1]> "" "mag(<u_f_vect_species0[l=:,r=1]>)" ON <correctionfaces>
                  # S or SUBSTITUTE will redefine variable but in old context, ie, outside of IF block
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 3
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)#     FACE_LOCAL <u_f_vect_magnitude> "sqrt(facemax(dot(<u_f_vect[l=:]>,<u_f_vect[l=:]>),<tinyish>))" ON <correctionfaces>
                  #(hash inserted during unwrap)FACE_LOCAL <u_f_vect_magnitude_species0> "mag(<u_f_vect_species0[l=:]>)" ON <correctionfaces>
                  #(hash inserted during unwrap)# S or SUBSTITUTE will redefine variable but in old context, ie, outside of IF block
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)END_IF
            # now calculate <u_f_alpha_{adv}>
            #-------------
            # advective contribution can be either simple or more complex (set by <<ufadvectioncomplex>>)
            # the default behaviour is to use the simple advective contribution
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)# more complex variant, which does not assume generally small correction velocities (and under steady-state conditions is equivalent to what was used pre v0.55) but is more expensive to compute, for what seems like little practical gain.  There is some evidence that the more complex variant can allow steady-state sims to converge more as Re increases, but very very marginal.
               #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_f_{correction}_magnitude_species0> "facemax(abs(<dynamic_force_f_{correction}_species0>),<tinyish>)" ON <correctionfaces>
               #(hash inserted during unwrap)FACE_LOCAL <u_f_alpha_{adv}_species0> "<dynamic_force_f_{correction}_magnitude_species0>/(-<u_f_vect_magnitude_species0[r=1]>+sqrt(<u_f_vect_magnitude_species0[r=1]>^2+<dynamic_force_f_{correction}_magnitude_species0>*<facedx>/<rho_species0>))" ON <correctionfaces>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 2
               #(hash inserted during unwrap)ELSE
               # simple advective contribution (which really assumes that locally |<u_f_{raw}>| >> |<u_f_{correction}>|
               FACE_LOCAL <u_f_alpha_{adv}_species0> "2.d0*<rho_species0>*<u_f_vect_magnitude_species0[r=1]>/<facedx>" ON <correctionfaces>
               #(hash inserted during unwrap)END_IF
            # ---------
            VARIABLE <u_f_alpha_species0> "(<u_f_alpha_species0>)+<u_f_alpha_{adv}_species0>"
            #(hash inserted during unwrap)END_IF
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1
            FACE_LOCAL <u_f_alpha_{transient}_species0> "<rho_species0>/<dt>" ON <correctionfaces>
            VARIABLE <u_f_alpha_species0> "(<u_f_alpha_species0>)+<u_f_alpha_{transient}_species0>"
            #(hash inserted during unwrap)END_IF
      FACE_DERIVED <u_f_{raw}_species1> 'dot(<u_f_vect_species1[l=:]>,<facenorm[l=:]>)' ON <allfaces>
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/u_f_coefficients' 
         
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Here we calculate the <u_f_alpha coefficients that each represent the relationship between change in velocity and change in dynamic force, based on an order-of-magnitude analysis of the momentum equations
         #(hash inserted during unwrap)There are potentially three coefficients, being transient, adv (advection) and vis (viscous)
         #(hash inserted during unwrap)IE, for navier-stokes:
         #(hash inserted during unwrap)<u_f_alpha_{transient}_species1>*(<u_f_{correction}>-<u_f_{correction}[r=1]>) + <u_f_alpha_{adv}_species1>*<u_f_{correction}> + <u_f_alpha_{vis}_species1>*<u_f_{correction}> = <C_{Rhie-Chow}>*<dynamic_force_f_{correction}_species1>
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)Now also defining a local <u_f_alpha_species1> which is the sum of the three alpha coefficients.
         #(hash inserted during unwrap)END_MARKDOWN
         
         # the region <correctionfaces> will have been defined when <dynamic_force_f_{correction}> was calculated
         
         # sum of all relvant alpha coefficients
         FACE_LOCAL <u_f_alpha_species1> "0.d0" ON <correctionfaces>
         
         # all equation variants here have viscous contribution, so add this first
         # same piece of code as in total_stress to deal with <mu_f> replacement - really clunky, for backwards compatibility
         # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 1
            #(hash inserted during unwrap)IF   # this evaluates as true (1) if replacement string '<mu_f>' isn't defined, AND <<uniformviscosity>> is on (1)
            #(hash inserted during unwrap)# if we are here then we apply the uniform viscosity substitution
            #(hash inserted during unwrap)END_IF
         FACE_LOCAL <u_f_alpha_{vis}_species1> "<mu_f_correction_species1>/<facedx>^2" ON <correctionfaces> # incase pextrapolationrhiechow is on, define these locals on allfaces (makes no difference to efficiency as they are locals anyway)
         VARIABLE <u_f_alpha_species1> "(<u_f_alpha_species1>)+<u_f_alpha_{vis}_species1>"
         
         # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 1
            #(hash inserted during unwrap)IF   # this evaluates as true (1) if replacement string '<rho_f>' isn't defined, AND <<uniformviscosity>> is on (1)
            #(hash inserted during unwrap)# if we are here then we apply the uniform density substitution
            #(hash inserted during unwrap)END_IF
         
         # advection term
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1 # only for navier-stokes equations
            #--------------
            # use this option to base the adv component on the total velocity magnitude, rather than the component over each face
            # the old way (pre v0.59) was to use <u_f_{raw}> which is the flux across the face when calculating the advective rhie-chow term
            # the new way (v0.59 and onwards) is based on the total velocity magnitude, so overwrite the string <<ufmagnitude>> with <u_f_vect_magnitude> which is the total magnitude of <u_f_vect[l=:]>
            
            #--------------
            # initialise variable using the old way, within the applicable block
               #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 2
               #(hash inserted during unwrap)IF 1 # ie, the new way
               # for a transient simulation the previous velocity magnitude is used, consistent with that used in the momentum advection
               # (although this can be overwritten by setting <<ufvectmagnitudeexplicit>> = 0 directly)
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 1
                  # performing index string loops on the following index list pairs:
                  #  <<i>> 1,2
                  FACE_LOCAL <u_f_vect_species1[l=1,r=1]> "faceave[](<u_species1[l=1,r=1]>)" ON <allfaces>
                  FACE_LOCAL <u_f_vect_species1[l=2,r=1]> "faceave[reflect=2](<u_species1[l=2,r=1]>)" ON <allfaces>
                  #     FACE_TRANSIENT <u_f_vect_magnitude[r=1]> "" "sqrt(facemax(dot(<u_f_vect[l=:,r=1]>,<u_f_vect[l=:,r=1]>),<tinyish>))" ON <correctionfaces>
                  FACE_TRANSIENT <u_f_vect_magnitude_species1[r=1]> "" "mag(<u_f_vect_species1[l=:,r=1]>)" ON <correctionfaces>
                  # S or SUBSTITUTE will redefine variable but in old context, ie, outside of IF block
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 3
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)#     FACE_LOCAL <u_f_vect_magnitude> "sqrt(facemax(dot(<u_f_vect[l=:]>,<u_f_vect[l=:]>),<tinyish>))" ON <correctionfaces>
                  #(hash inserted during unwrap)FACE_LOCAL <u_f_vect_magnitude_species1> "mag(<u_f_vect_species1[l=:]>)" ON <correctionfaces>
                  #(hash inserted during unwrap)# S or SUBSTITUTE will redefine variable but in old context, ie, outside of IF block
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)END_IF
            # now calculate <u_f_alpha_{adv}>
            #-------------
            # advective contribution can be either simple or more complex (set by <<ufadvectioncomplex>>)
            # the default behaviour is to use the simple advective contribution
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)# more complex variant, which does not assume generally small correction velocities (and under steady-state conditions is equivalent to what was used pre v0.55) but is more expensive to compute, for what seems like little practical gain.  There is some evidence that the more complex variant can allow steady-state sims to converge more as Re increases, but very very marginal.
               #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_f_{correction}_magnitude_species1> "facemax(abs(<dynamic_force_f_{correction}_species1>),<tinyish>)" ON <correctionfaces>
               #(hash inserted during unwrap)FACE_LOCAL <u_f_alpha_{adv}_species1> "<dynamic_force_f_{correction}_magnitude_species1>/(-<u_f_vect_magnitude_species1[r=1]>+sqrt(<u_f_vect_magnitude_species1[r=1]>^2+<dynamic_force_f_{correction}_magnitude_species1>*<facedx>/<rho_species1>))" ON <correctionfaces>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 2
               #(hash inserted during unwrap)ELSE
               # simple advective contribution (which really assumes that locally |<u_f_{raw}>| >> |<u_f_{correction}>|
               FACE_LOCAL <u_f_alpha_{adv}_species1> "2.d0*<rho_species1>*<u_f_vect_magnitude_species1[r=1]>/<facedx>" ON <correctionfaces>
               #(hash inserted during unwrap)END_IF
            # ---------
            VARIABLE <u_f_alpha_species1> "(<u_f_alpha_species1>)+<u_f_alpha_{adv}_species1>"
            #(hash inserted during unwrap)END_IF
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_coefficients.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1
            FACE_LOCAL <u_f_alpha_{transient}_species1> "<rho_species1>/<dt>" ON <correctionfaces>
            VARIABLE <u_f_alpha_species1> "(<u_f_alpha_species1>)+<u_f_alpha_{transient}_species1>"
            #(hash inserted during unwrap)END_IF
      
      
      # save old correction velocity for transient calculations
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/u_f.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1
         FACE_TRANSIENT <u_f_{correction}_species0[r=1]> '0.d0' '<u_f_{correction}_species0>' ON <correctionfaces>
         FACE_TRANSIENT <u_f_{correction}_species1[r=1]> '0.d0' '<u_f_{correction}_species1>' ON <correctionfaces>
         
         #(hash inserted during unwrap)END_IF
      
      # now calculate the correction velocity 
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/u_f.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1
         # when using the mixture method, the dynamic_force_correction
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/mixture_u_f.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "mixture_u_f"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)Calculate the rhiechow correction velocity for multifluid.
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)In this version we applied a correction to all velocity components based on a mixture equation, and then corrections to each phase based on algebraic slip equations.
            #(hash inserted during unwrap)END_MARKDOWN
            
            #--------------------------
            # use this to debug
            
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/mixture_u_f.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)OVERRIDE_OPTIONS output
               #(hash inserted during unwrap)END_IF
            
            #--------------------------
            # firstly calculate the mixture correction velocity based on phi averaged mixture properties, and total correction pressure
            # calculate alpha and alpha_{transient} mixture coefficients
            # also sum the phase dynamic force corrections to get a total one
            FACE_LOCAL <u_f_alpha_mixture> '0.d0' ON <correctionfaces> output
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/mixture_u_f.arb: sub_block = 1
               #(hash inserted during unwrap)IF 1
               FACE_LOCAL <u_f_alpha_{transient}_mixture> '0.d0' ON <correctionfaces> output
               #(hash inserted during unwrap)END_IF
            FACE_LOCAL <dynamic_force_f_{correction}_total> '0.d0' ON <correctionfaces> output
            VARIABLE <u_f_alpha_mixture> '<u_f_alpha_mixture>+<phi_f_bounded_species0>*<u_f_alpha_species0>'
            VARIABLE <u_f_alpha_{transient}_mixture> '<u_f_alpha_{transient}_mixture>+<phi_f_bounded_species0>*<u_f_alpha_{transient}_species0>'
            VARIABLE <dynamic_force_f_{correction}_total> '<dynamic_force_f_{correction}_total>+(<dynamic_force_f_{correction}_species0>)'
            VARIABLE <u_f_alpha_mixture> '<u_f_alpha_mixture>+<phi_f_bounded_species1>*<u_f_alpha_species1>'
            VARIABLE <u_f_alpha_{transient}_mixture> '<u_f_alpha_{transient}_mixture>+<phi_f_bounded_species1>*<u_f_alpha_{transient}_species1>'
            VARIABLE <dynamic_force_f_{correction}_total> '<dynamic_force_f_{correction}_total>+(<dynamic_force_f_{correction}_species1>)'
            
            
            # calculate mixture correction velocity and save the old one
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/mixture_u_f.arb: sub_block = 1
               #(hash inserted during unwrap)IF 1
               FACE_TRANSIENT <u_f_{correction}_mixture[r=1]> "0.d0" "<u_f_{correction}_mixture>" ON <correctionfaces>
               FACE_DERIVED <u_f_{correction}_mixture> "(<C_{Rhie-Chow}>*<dynamic_force_f_{correction}_total>+<u_f_alpha_{transient}_mixture>*<u_f_{correction}_mixture[r=1]>)/<u_f_alpha_mixture>" ON <correctionfaces> output
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/mixture_u_f.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)FACE_DERIVED <u_f_{correction}_mixture> "(<C_{Rhie-Chow}>*<dynamic_force_f_{correction}_total>)/<u_f_alpha_mixture>" ON <correctionfaces> output
               #(hash inserted during unwrap)END_IF
            
            #--------------------------
            # calculate the slip correction velocities (slip relative to fluid velocities) for all disperse phases
            FACE_DERIVED <u_f_beta^/phi_species1> 'faceave[harmonic](<beta^_species1_species0>/<phi_bounded_species0>)' ON <correctionfaces>
            FACE_DERIVED <phiu_f_slip_{correction}_species1> '<dynamic_force_f_{correction}_species1>/<u_f_beta^/phi_species1>' ON <correctionfaces>
            FACE_DERIVED <u_f_slip_{correction}_species1> '<phiu_f_slip_{correction}_species1>/<phi_f_bounded_harmonic_species1>' ON <correctionfaces>
            
            
            #--------------------------
            # finally calculate the fluid and disperse phase correction velocities
            FACE_DERIVED <u_f_{correction}_species0> "<u_f_{correction}_mixture>" ON <correctionfaces>
            VARIABLE <u_f_{correction}_species0> '(<u_f_{correction}_species0>)-<phiu_f_slip_{correction}_species1>'
            FACE_DERIVED <u_f_{correction}_species1> '(<u_f_{correction}_species0>)+<u_f_slip_{correction}_species1>' ON <correctionfaces>
            
            
            #--------------------------
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/mixture_u_f.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)# for debug output diagnostics and turn off override options
               #(hash inserted during unwrap)INCLUDE "diagnostics" 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)OVERRIDE_OPTIONS
               #(hash inserted during unwrap)END_IF
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/u_f.arb: sub_block = 1
         #(hash inserted during unwrap)ELSE_IF 
         #(hash inserted during unwrap)# species aware fancier method, with species0 having to be done first
         #(hash inserted during unwrap)
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/u_f.arb: sub_block = 1
         #(hash inserted during unwrap)ELSE
         #(hash inserted during unwrap)ERROR "u_f_method not set in u_f.arb in multifluid string = mixture"
         #(hash inserted during unwrap)END_IF
      
      # final face velocity is made from raw and correction components
      FACE_DERIVED <u_f_species0> '<u_f_{raw}_species0>+faceif(facedelta(<domainfaces>),<u_f_{correction}_species0>,0.d0)' ON <allfaces>
      FACE_DERIVED <u_f_species1> '<u_f_{raw}_species1>+faceif(facedelta(<domainfaces>),<u_f_{correction}_species1>,0.d0)' ON <allfaces>
      
      
      # this oddball file is required for implicit timestepping after u_f is calculated
         #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_save_dt.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE_TEMPLATE "navier_stokes/transient_save_dt"
         # this section just re-works the implicit timestepping equation to allow a newtstepmax to be applied to <dt_target>
         # save a derived copy of <dt_target> after <u_f> has been calculated so that we can apply newtstepmax to it
         # this string will already have been set to 1 (as a general replacement) in transient_all_setup if this option is relevant
         # this is the default behaviour when using implicit dynamic timestepping
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_save_dt.arb: sub_block = 1
            #(hash inserted during unwrap)IF 0
            #(hash inserted during unwrap)NONE_DERIVED <dt_target_derived> "<dt_target>" newtstepmax=10
            #(hash inserted during unwrap)NONE_EQUATION <dt implicit equation> "<dt>-<dt_target_derived>"
            #(hash inserted during unwrap)END_IF
   #INCLUDE "buoyancy_dynamic_force" # add a buoyancy component onto the dynamic forces
      #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/conservation.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "conservation" # both mass and momentum conservation equations solved
      #(hash inserted during unwrap)MARKDOWN
      #(hash inserted during unwrap)Conservation equations for both mass and momentum
      #(hash inserted during unwrap)END_MARKDOWN
      
      # uses <<radius_f>> and <<radius_c>> which are either r or 1 already, and simplify in the case of 1 using maxima
      
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/default_replacement_strings.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "default_replacement_strings"
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Set some default equation settings via replacement strings for the multifluid problem
         #(hash inserted during unwrap)END_MARKDOWN
         
         # <<implicitadvection>> modifies both the advection of phi and u, making both implicit (ie, using r=0 values rather than r=1 values).  You need implicit advection to be able to push CFL over 1.
         # default is now implicit advection
         
         #GLOBAL_REPLACEMENTS D "<<stress_method>>" W "version1" # method, with phi inside viscous stress divergence
         # as per jackson98 and zhang97, have phi outside of stress divergence, version2 default = zhang97 = jackson98 = balls
         
         # default hindered settling function is now as defined in masliyah79 = balls
         # version1 gives an equivalent hindered settling function which is / phi_0^2
         
         
         # method used for rhie-chow u_f interpolation
         
         #GLOBAL_REPLACEMENTS D '<<u_f_method>>' W 'species' # default behaviour for v0.60
         
      
      # both of these strings are now set globally in constants, but can be overwritten with local values here
      # <<implicitadvection>> modifies both the advection of phi and u, making both implicit (ie, using r=0 values rather than r=1 values).  You need implicit advection to be able to push CFL over 1.
      # default is now implicit advection
      
      #REPLACEMENTS D "<<stress_method>>" W "version1" # method, with phi inside viscous stress divergence
      # as per jackson98 and zhang97, have phi outside of stress divergence, version2 default = zhang97 = jackson98 = balls
      # now create conservation equations
      
      # mass conservation (actually, volume conservation)
      FACE_DERIVED <phi_f_adv_species0> 'faceave[advection](<phi_bounded_species0>,<u_f_species0>,<adv_limiter>)' ON <allfaces>
      FACE_LOCAL <phiu_f_species0> '<phi_f_adv_species0>*<u_f_species0>' ON <allfaces>
      CELL_EQUATION <continuity_species0> 'celldiv(1.d0*<phiu_f_species0>)*1.d0' ON <domain>
      CELL_EQUATION <continuity_species0> '(<phi_species0>-<phi_species0[r=1]>)/<dt>+<continuity_species0>' ON <domain>
      FACE_DERIVED <phi_f_adv_species1> 'faceave[advection](<phi_bounded_species1>,<u_f_species1>,<adv_limiter>)' ON <allfaces>
      FACE_LOCAL <phiu_f_species1> '<phi_f_adv_species1>*<u_f_species1>' ON <allfaces>
      CELL_EQUATION <continuity_species1> 'celldiv(1.d0*<phiu_f_species1>)*1.d0' ON <domain>
      CELL_EQUATION <continuity_species1> '(<phi_species1>-<phi_species1[r=1]>)/<dt>+<continuity_species1>' ON <domain>
      
      
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/momentum_advection_flux.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE_LOCAL "momentum_advection_flux" # calculate momentum advection flux for all species, only for non-stokes flow, references <<implicitadvection>> = 0 or 1 string
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Calculate the momentum advection flux by modifying the navier_stokes template files
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)Note that if 1 is set to 1, then this will be carried through to the advection_flux template
         #(hash inserted during unwrap)END_MARKDOWN
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/advection_flux' 
            
            # flux of momentum over and in the direction of each face due to advection
            # which one is chosen depends on the comment strings
            # all require navierstokes equations to be current
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 1
               #(hash inserted during unwrap)IF 1 # this will be true for non-stokes (=navier-stokes) simulations
               
               # check default strings are set
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "default_string_replacements"
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
                  #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)Some of these use both comment and flag type variables, which requires three things to be set for each option.  The comment type variables will eventually be phased out, but are still required for many of the template files.
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # the following strings require a flag variable and two comment variables to be set
                  
                  
                  # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
                  
                  
               
               
               # setting <<implicitadvection>> = 1 causes momentum advection to be calculated using implicit velocities and densities, instead of explicit variables, which is relevant for transient simulations only
               # note, if you are setting this here, you may also like to make the velocity used in the calculation of <u_f_alpha_{adv}> within u_f.arb implicit too, although it is not theoretically necessary (and will probably increase computational expense and decrease stability)
               # to do this set REPLACEMENTS R "<<ufvectmagnitudeexplicit>>" W "0" when calling u_f, or anywhere before calling that file
               
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 1
                  # using implicit velocities and densities is only relevant for steady-state simulations, and transient ones with <<implicitadvection>> on
                  # having to respect the old <<uniformdensitycomment>> choice for backwards compatibility with user's vof files - just in this file
                  #   IF <<uniformdensity>>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 3
                     #(hash inserted during unwrap)IF 1 
                     # steady-state (or implicit advection) and uniform density
                     # performing index string loops on the following index list pairs:
                     #  <<i>> 1,2
                     FACE_LOCAL <J_advection_f_species0[l=1]> "<rho_species0>*faceave[advection,](<u_species0[l=1]>,<phiu_f_species0>,<adv_limiter>)*<phiu_f_species0>" ON <allfaces>
                     FACE_LOCAL <J_advection_f_species0[l=2]> "<rho_species0>*faceave[advection,reflect=2](<u_species0[l=2]>,<phiu_f_species0>,<adv_limiter>)*<phiu_f_species0>" ON <allfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)# steady-state (or implicit advection) and varying density
                     #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                     #(hash inserted during unwrap)#  <<i>> 1,2
                     #(hash inserted during unwrap)FACE_LOCAL <J_advection_f_species0[l=1]> "faceave[advection,](<rho_species0>*<u_species0[l=1]>,<phiu_f_species0>,<adv_limiter>)*<phiu_f_species0>" ON <allfaces>
                     #(hash inserted during unwrap)FACE_LOCAL <J_advection_f_species0[l=2]> "faceave[advection,reflect=2](<rho_species0>*<u_species0[l=2]>,<phiu_f_species0>,<adv_limiter>)*<phiu_f_species0>" ON <allfaces>
                     #(hash inserted during unwrap)END_IF
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)# having to respect the old <<uniformdensitycomment>> choice for backwards compatibility with user's vof files - just in this file
                  #(hash inserted during unwrap)#   IF <<uniformdensity>>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 3
                     #(hash inserted during unwrap)IF  
                     #(hash inserted during unwrap)# transient and uniform density
                     #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                     #(hash inserted during unwrap)#  <<i>> 1,2
                     #(hash inserted during unwrap)FACE_LOCAL <J_advection_f_species0[l=1]> "<rho_species0>*faceave[advection,](<u_species0[l=1,r=1]>,<phiu_f_species0>,<adv_limiter>)*<phiu_f_species0>" ON <allfaces>
                     #(hash inserted during unwrap)FACE_LOCAL <J_advection_f_species0[l=2]> "<rho_species0>*faceave[advection,reflect=2](<u_species0[l=2,r=1]>,<phiu_f_species0>,<adv_limiter>)*<phiu_f_species0>" ON <allfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)# transient and varying density
                     #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                     #(hash inserted during unwrap)#  <<i>> 1,2
                     #(hash inserted during unwrap)FACE_LOCAL <J_advection_f_species0[l=1]> "faceave[advection,](<rho[r=1]>*<u_species0[l=1,r=1]>,<phiu_f_species0>,<adv_limiter>)*<phiu_f_species0>" ON <allfaces>
                     #(hash inserted during unwrap)FACE_LOCAL <J_advection_f_species0[l=2]> "faceave[advection,reflect=2](<rho[r=1]>*<u_species0[l=2,r=1]>,<phiu_f_species0>,<adv_limiter>)*<phiu_f_species0>" ON <allfaces>
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)END_IF
            #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/advection_flux' 
            
            # flux of momentum over and in the direction of each face due to advection
            # which one is chosen depends on the comment strings
            # all require navierstokes equations to be current
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 1
               #(hash inserted during unwrap)IF 1 # this will be true for non-stokes (=navier-stokes) simulations
               
               # check default strings are set
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "default_string_replacements"
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
                  #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)Some of these use both comment and flag type variables, which requires three things to be set for each option.  The comment type variables will eventually be phased out, but are still required for many of the template files.
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # the following strings require a flag variable and two comment variables to be set
                  
                  
                  # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
                  
                  
               
               
               # setting <<implicitadvection>> = 1 causes momentum advection to be calculated using implicit velocities and densities, instead of explicit variables, which is relevant for transient simulations only
               # note, if you are setting this here, you may also like to make the velocity used in the calculation of <u_f_alpha_{adv}> within u_f.arb implicit too, although it is not theoretically necessary (and will probably increase computational expense and decrease stability)
               # to do this set REPLACEMENTS R "<<ufvectmagnitudeexplicit>>" W "0" when calling u_f, or anywhere before calling that file
               
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 1
                  # using implicit velocities and densities is only relevant for steady-state simulations, and transient ones with <<implicitadvection>> on
                  # having to respect the old <<uniformdensitycomment>> choice for backwards compatibility with user's vof files - just in this file
                  #   IF <<uniformdensity>>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 3
                     #(hash inserted during unwrap)IF 1 
                     # steady-state (or implicit advection) and uniform density
                     # performing index string loops on the following index list pairs:
                     #  <<i>> 1,2
                     FACE_LOCAL <J_advection_f_species1[l=1]> "<rho_species1>*faceave[advection,](<u_species1[l=1]>,<phiu_f_species1>,<adv_limiter>)*<phiu_f_species1>" ON <allfaces>
                     FACE_LOCAL <J_advection_f_species1[l=2]> "<rho_species1>*faceave[advection,reflect=2](<u_species1[l=2]>,<phiu_f_species1>,<adv_limiter>)*<phiu_f_species1>" ON <allfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)# steady-state (or implicit advection) and varying density
                     #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                     #(hash inserted during unwrap)#  <<i>> 1,2
                     #(hash inserted during unwrap)FACE_LOCAL <J_advection_f_species1[l=1]> "faceave[advection,](<rho_species1>*<u_species1[l=1]>,<phiu_f_species1>,<adv_limiter>)*<phiu_f_species1>" ON <allfaces>
                     #(hash inserted during unwrap)FACE_LOCAL <J_advection_f_species1[l=2]> "faceave[advection,reflect=2](<rho_species1>*<u_species1[l=2]>,<phiu_f_species1>,<adv_limiter>)*<phiu_f_species1>" ON <allfaces>
                     #(hash inserted during unwrap)END_IF
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)# having to respect the old <<uniformdensitycomment>> choice for backwards compatibility with user's vof files - just in this file
                  #(hash inserted during unwrap)#   IF <<uniformdensity>>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 3
                     #(hash inserted during unwrap)IF  
                     #(hash inserted during unwrap)# transient and uniform density
                     #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                     #(hash inserted during unwrap)#  <<i>> 1,2
                     #(hash inserted during unwrap)FACE_LOCAL <J_advection_f_species1[l=1]> "<rho_species1>*faceave[advection,](<u_species1[l=1,r=1]>,<phiu_f_species1>,<adv_limiter>)*<phiu_f_species1>" ON <allfaces>
                     #(hash inserted during unwrap)FACE_LOCAL <J_advection_f_species1[l=2]> "<rho_species1>*faceave[advection,reflect=2](<u_species1[l=2,r=1]>,<phiu_f_species1>,<adv_limiter>)*<phiu_f_species1>" ON <allfaces>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)# transient and varying density
                     #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                     #(hash inserted during unwrap)#  <<i>> 1,2
                     #(hash inserted during unwrap)FACE_LOCAL <J_advection_f_species1[l=1]> "faceave[advection,](<rho[r=1]>*<u_species1[l=1,r=1]>,<phiu_f_species1>,<adv_limiter>)*<phiu_f_species1>" ON <allfaces>
                     #(hash inserted during unwrap)FACE_LOCAL <J_advection_f_species1[l=2]> "faceave[advection,reflect=2](<rho[r=1]>*<u_species1[l=2,r=1]>,<phiu_f_species1>,<adv_limiter>)*<phiu_f_species1>" ON <allfaces>
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)END_IF
         
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/momentum_viscous_flux.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE_LOCAL "momentum_viscous_flux" # calculate momentum advection flux for all species
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Flux of momentum over and in the direction of each face, for each species, due to viscous stresses
         #(hash inserted during unwrap)END_MARKDOWN
         
         # performing index string loops on the following index list pairs:
         #  <<i>> 1,2
         FACE_LOCAL <J_viscous_f_species0[l=1]> 'dot(<facenorm[l=:]>,<tau_species0[l=:,1]>)' ON <allfaces>
         FACE_LOCAL <J_viscous_f_species0[l=2]> 'dot(<facenorm[l=:]>,<tau_species0[l=:,2]>)' ON <allfaces>
         # performing index string loops on the following index list pairs:
         #  <<i>> 1,2
         FACE_LOCAL <J_viscous_f_species1[l=1]> 'dot(<facenorm[l=:]>,<tau_species1[l=:,1]>)' ON <allfaces>
         FACE_LOCAL <J_viscous_f_species1[l=2]> 'dot(<facenorm[l=:]>,<tau_species1[l=:,2]>)' ON <allfaces>
         
      
      # momentum conservation
      CELL_EQUATION <momentum_species0[l=1]> '0.d0' ON <domain>
      CELL_EQUATION <momentum_species0[l=1]> '<momentum_species0[l=1]>+<J_advection_f_species0[l=1]>/(faceave[lastcell](<phi_bounded_species0>))'
      CELL_EQUATION <momentum_species0[l=1]> '<momentum_species0[l=1]>+<J_viscous_f_species0[l=1]>'
      CELL_EQUATION <momentum_species0[l=1]> 'celldiv(1.d0*(<momentum_species0[l=1]>))/1.d0'
      CELL_EQUATION <momentum_species0[l=1]> '<momentum_species0[l=1]>+<rho_species0>*(<u_species0[l=1]>-<phi_pos_species0[r=1]>*<u_species0[l=1,r=1]>/<phi_bounded_species0>)/<dt>'
      CELL_EQUATION <momentum_species0[l=1]> '<momentum_species0[l=1]>-<dynamic_force_c_species0[l=1]>' ON <domain>
      CELL_EQUATION <momentum_species0[l=1]> '<momentum_species0[l=1]>-<extra_force_species0[l=1]>'
      CELL_EQUATION <momentum_species1[l=1]> '0.d0' ON <domain>
      CELL_EQUATION <momentum_species1[l=1]> '<momentum_species1[l=1]>+<J_advection_f_species1[l=1]>/(faceave[lastcell](<phi_bounded_species1>))'
      CELL_EQUATION <momentum_species1[l=1]> '<momentum_species1[l=1]>+<J_viscous_f_species1[l=1]>'
      CELL_EQUATION <momentum_species1[l=1]> 'celldiv(1.d0*(<momentum_species1[l=1]>))/1.d0'
      CELL_EQUATION <momentum_species1[l=1]> '<momentum_species1[l=1]>+<rho_species1>*(<u_species1[l=1]>-<phi_pos_species1[r=1]>*<u_species1[l=1,r=1]>/<phi_bounded_species1>)/<dt>'
      CELL_EQUATION <momentum_species1[l=1]> '<momentum_species1[l=1]>-<dynamic_force_c_species1[l=1]>' ON <domain>
      CELL_EQUATION <momentum_species1[l=1]> '<momentum_species1[l=1]>-<extra_force_species1[l=1]>'
      CELL_EQUATION <momentum_species1[l=1]> '<momentum_species1[l=1]>+<beta^_species1_species0>*(<u_species1[l=1]>-<u_species0[l=1]>)'
      CELL_EQUATION <momentum_species0[l=1]> '<momentum_species0[l=1]>+<beta^_species0_species1>*(<u_species0[l=1]>-<u_species1[l=1]>)'
      CELL_EQUATION <momentum_species0[l=2]> '0.d0' ON <domain>
      CELL_EQUATION <momentum_species0[l=2]> '<momentum_species0[l=2]>+<J_advection_f_species0[l=2]>/(faceave[lastcell](<phi_bounded_species0>))'
      CELL_EQUATION <momentum_species0[l=2]> '<momentum_species0[l=2]>+<J_viscous_f_species0[l=2]>'
      CELL_EQUATION <momentum_species0[l=2]> 'celldiv(1.d0*(<momentum_species0[l=2]>))/1.d0'
      CELL_EQUATION <momentum_species0[l=2]> '<momentum_species0[l=2]>+<rho_species0>*(<u_species0[l=2]>-<phi_pos_species0[r=1]>*<u_species0[l=2,r=1]>/<phi_bounded_species0>)/<dt>'
      CELL_EQUATION <momentum_species0[l=2]> '<momentum_species0[l=2]>-<dynamic_force_c_species0[l=2]>' ON <domain>
      CELL_EQUATION <momentum_species0[l=2]> '<momentum_species0[l=2]>-<extra_force_species0[l=2]>'
      CELL_EQUATION <momentum_species1[l=2]> '0.d0' ON <domain>
      CELL_EQUATION <momentum_species1[l=2]> '<momentum_species1[l=2]>+<J_advection_f_species1[l=2]>/(faceave[lastcell](<phi_bounded_species1>))'
      CELL_EQUATION <momentum_species1[l=2]> '<momentum_species1[l=2]>+<J_viscous_f_species1[l=2]>'
      CELL_EQUATION <momentum_species1[l=2]> 'celldiv(1.d0*(<momentum_species1[l=2]>))/1.d0'
      CELL_EQUATION <momentum_species1[l=2]> '<momentum_species1[l=2]>+<rho_species1>*(<u_species1[l=2]>-<phi_pos_species1[r=1]>*<u_species1[l=2,r=1]>/<phi_bounded_species1>)/<dt>'
      CELL_EQUATION <momentum_species1[l=2]> '<momentum_species1[l=2]>-<dynamic_force_c_species1[l=2]>' ON <domain>
      CELL_EQUATION <momentum_species1[l=2]> '<momentum_species1[l=2]>-<extra_force_species1[l=2]>'
      CELL_EQUATION <momentum_species1[l=2]> '<momentum_species1[l=2]>+<beta^_species1_species0>*(<u_species1[l=2]>-<u_species0[l=2]>)'
      CELL_EQUATION <momentum_species0[l=2]> '<momentum_species0[l=2]>+<beta^_species0_species1>*(<u_species0[l=2]>-<u_species1[l=2]>)'
      
      
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/conservation.arb: sub_block = 1
         #(hash inserted during unwrap)IF 0
         #(hash inserted during unwrap)# add on hoop stress term separately for cylindrical coordinates
         #(hash inserted during unwrap)# first perform a check that <<radialdim>> has been correctly defined
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/conservation.arb: sub_block = 2
            #(hash inserted during unwrap)IF 
            #(hash inserted during unwrap)ERROR 'This is a cylindrical coordinate simulation however the string 0 has not been correctly defined'
            #(hash inserted during unwrap)END_IF
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)#define momentum eqn for azimuthal component
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/conservation.arb: sub_block = 2
            #(hash inserted during unwrap)IF 0#<<azimuthal>>
            #(hash inserted during unwrap)# perform a check that <<azimuthaldim>> has been correctly defined
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/conservation.arb: sub_block = 3
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)ERROR 'This is a cylindrical coordinate simulation with azimuthal flow however the string 0 has not been correctly defined'
               #(hash inserted during unwrap)END_IF
            #(hash inserted during unwrap)# define constant azimuthal velocity divergence modifier terms
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)#VARIABLE <momentum[l=<<azimuthaldim>>]> "celldiv(<<radius_top_azi>><J_f[l=<<azimuthaldim>>]>)<<radius_bottom_azi>>+<rho>*<u_f_vect[l=<<radialdim>>]>*<u_f_vect[l=<<azimuthaldim>>]>/<facex[l=<<radialdim>>]>" ON <domain> # momentum component'
            #(hash inserted during unwrap)#VARIABLE <momentum_$species"."[l=<<azimuthaldim>>]> 'celldiv(<<radius_top_azi>>(<J_viscous_f_$species"."[l=<<azimuthaldim>>]>+<J_advection_f_$species"."[l=<<azimuthaldim>>]>))<<radius_bottom_azi>>+<rho_$species".">*<u_f_vect_$species"."[l=<<radialdim>>]>*<u_f_vect_$species"."[l=<<azimuthaldim>>]>/<facex[l=<<radialdim>>]>'\n
            #(hash inserted during unwrap)#      VARIABLE <momentum[l=<<radialdim>>]> "<momentum[l=<<radialdim>>]>-<rho>*<u_f_vect[l=<<azimuthaldim>>]>**2/<facex[l=<<radialdim>>]>"
            #(hash inserted during unwrap)#VARIABLE <momentum_$species"."[l=<<radialdim>>]> '<momentum_$species"."[l=<<radialdim>>]>-<rho_$species".">*<u_f_vect_$species"."[l=<<azimuthaldim>>]>**2/<facex[l=<<radialdim>>]>'\n
            #(hash inserted during unwrap)END_IF
         #(hash inserted during unwrap)
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/conservation.arb: sub_block = 2
            #(hash inserted during unwrap)IF 0
            #(hash inserted during unwrap)# momentum conservation
            #(hash inserted during unwrap)# perform a check that <<azimuthaldim>> has been correctly defined
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/conservation.arb: sub_block = 3
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)ERROR 'This is a cylindrical coordinate simulation with azimuthal flow however the string 0 has not been correctly defined'
               #(hash inserted during unwrap)END_IF
            #(hash inserted during unwrap)# define constant azimuthal velocity divergence modifier terms
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)END_IF
         #(hash inserted during unwrap)END_IF
      #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/walls.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "walls" # walls BC
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/boundary_equations.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE 'boundary_equations' 
         
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Boundary conditions for an inlet, outlet or walls.  Choose which by setting '<walls' equal to either <inlet, <outlet or <walls.
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)To give the region another (or specific) name, do a secondary subsequent substitution when calling, as in
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)```arb
         #(hash inserted during unwrap)INCLUDE_TEMPLATE "multifluid/boundary_equations 
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)```
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)IE, replace <walls with <inlet first, and then replace <inlet with <inlet1.
         #(hash inserted during unwrap)END_MARKDOWN
         
         # if not otherwise specified, default to inlet boundary conditions
         
         
         # set the default boundary condition methods here for methods that do not change for the boundary type of species being considered
         # otherwise specify the methods individually when calling the navier-stokes boundary_equations template below
         # individual methods can be specified when calling this file to overwrite any of these default (D) methods
         # eg INCLUDE 'boundary_equations' R '<<boundary_method_variable>>' W 'dynamicforce'
         
         # this is the default for p extrapolation at the wall, which can be set specifically for wall boundaries using
         # eg INCLUDE 'boundary_equations' R '<<boundary_normal_wall_method>>' W 'rhiechow'
         #REPLACEMENTS D '<<boundary_normal_wall_method>>' W 'rhiechow'
         # current default for multifluid
         
         
         
         #REPLACEMENTS D '<<boundary_method_variable>>' W 'dynamicforce'
         
         
         # problem is these will break if phi_f_adv is zero as u_f on the boundary is no longer in an equation?
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE 'single_species_boundary_equations' 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)This just generalises the navier-stokes boundary_equations template to a specific species by adding a species0 suffix to all relevant variables
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Now also implements replacements to give phi specific boundaries
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)The species0 string needs to be set before this template file is called
            #(hash inserted during unwrap)END_MARKDOWN
            
            # the 'SUFFIX' replacement type adds a suffix to the variable name.  It doesn't matter what is contained within the [] in the variable name if there are square braces - ie, <u_f_vect[l=1]> will replace all vector components, and also all r indicies of this variable
            # these are variables from the domain
            
            
            
            
            
            
            
            
            
            # these are boundary condition specific variables
            
            
            
            
            
            
            
            
            
            
            
            
            
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)# special case that sets gradient of phi to zero, relevant for outlet boundaries
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)VARIABLE <walls flowrate equation_species0> "facegrad[adjacentcells](<phi_species0>)"
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)# special case that sets a uniform value for phi (equal to <region phi_<<species>>>), relevant for inlet boundaries
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)NONE_CONSTANT <walls phi_species0> "<phi_initial_species0>"
               #(hash inserted during unwrap)VARIABLE <walls flowrate equation_species0> "<phi_f_species0>-<walls phi_species0>"
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               # now include the navier_stokes boundary_equations template file
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations'
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, inlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)This has a few variables that can be set:
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)`zerodynamic` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
                  #(hash inserted during unwrap)`noslip` determines the shear conditions at the boundary
                  #(hash inserted during unwrap)`noflux` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `p`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)The defaults specify a fully developed flow through <walls> with a set flowrate of <walls u_species0> created by varying the uniform <dynamic_force_f_species0> (ie, an inlet).
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # First equation is a constraint on normal velocity gradient normal to the boundary
                  # by default grad{u}:nn = 0
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundary_normal_method>>=rhiechow)
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamic"
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerogradp"
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamiccorrection"
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                     FACE_EQUATION <walls pextrapolation_species0> "<dynamic_force_f_species0>" ON <walls>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <walls pextrapolation_species0> "<dynamic_force_f_{correction}_species0>" ON <walls>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <walls pextrapolation_species0> "facegrad(<p>)" ON <walls>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: zerodynamic"
                     #(hash inserted during unwrap)END_IF
                  
                  # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
                  
                  #REPLACEMENTS D "<<boundary_tangent_method>>" W "slip"
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)INCLUDE "slip" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
                        #(hash inserted during unwrap)INCLUDE "noslip" 
                        
                        FACE_EQUATION <walls noslip1_species0> "dot(<u_f_vect_species0[l=:]>,<facetang1[l=:]>)" ON <walls> # no component tangential to the face
                        #FACE_EQUATION <walls noslip2_species0> "dot(<u_f_vect_species0[l=:]>,<facetang2[l=:]>)" ON <walls> # no component tangential to the face in the second tangential direction
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: noslip"
                     #(hash inserted during unwrap)END_IF
                  
                  # Third equation is a constraint on the velocity or pressure value at the boundary
                  # the first three all specify uniform conditions across the boundary:
                  #REPLACEMENTS D "<<boundary_method>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
                  #REPLACEMENTS D "<<boundary_method>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
                  #REPLACEMENTS D "<<boundary_method>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundary_method>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
                  # all of the remaining methods require a single face within the region to be special cased:
                  #REPLACEMENTS D "<<boundary_method>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
                  # the following two methods set whatever the <<boundary_method_variable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundary_method_variable>>, defaulting to <dynamic_force_f>)
                  # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
                  #REPLACEMENTS D "<<boundary_method>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species0> "<p_f_species0>-<walls p_species0>" ON <walls> # specified pressure
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species0> "<u_f_species0>+<walls u_species0>" ON <walls> # specified velocity
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                     
                     FACE_EQUATION <walls flowrate equation_species0> "<u_f_species0>" ON <walls> # zero velocity
                     
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF  
                     #(hash inserted during unwrap)# all of these boundary methods require the oneface (or centreline) subdomain, so form these first
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)# now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
                     #(hash inserted during unwrap)# by default create the single oneface region here
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)IF <<boundarycreateoneface>>
                        #(hash inserted during unwrap)INCLUDE "oneface_region"
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)IF  
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species0> "<u_f_species0>" ON <walls sans oneface> # zero velocity on most of the region
                        #(hash inserted during unwrap)FACE_EQUATION <walls oneface flowrate equation_species0> "<p_f_species0>" ON <walls oneface>
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 
                           #(hash inserted during unwrap)# for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                           #(hash inserted during unwrap)# to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                           #(hash inserted during unwrap)NONE_DERIVED <walls u_av_calc_species0> "facesum(-<u_f_species0>*<facearea>,<walls>)/facesum(<facearea>,<walls>)" # calculate average velocity directed into the domain
                           #(hash inserted during unwrap)#NONE_DERIVED <walls u_av_calc_species0> "facesum(-<u_f_species0>*<facearea>*1.d0,<walls>)/facesum(<facearea>*1.d0,<walls>)" # calculate average velocity directed into the domain
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)# this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                           #(hash inserted during unwrap)NONE_EQUATION <walls oneface flowrate equation_species0> "<walls u_av_calc_species0>-<walls u_species0>" # set flowrate through region to give required average velocity
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)FACE_EQUATION <walls oneface flowrate equation_species0> "<p_f_species0>-<walls p_species0>" ON <walls oneface> # set pressure at oneface to <region p>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: noflux"
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)# and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "celldivgrad"
                        #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "facegrad"
                        #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "p"
                        #(hash inserted during unwrap)
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 
                           #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                           #(hash inserted during unwrap)#  <<i>> 1,2
                           #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f_species0>)"
                           #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f_species0>)"
                           #(hash inserted during unwrap)#     <<dim1comment>> CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                           #(hash inserted during unwrap)#     <<dim2comment>> CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                           #(hash inserted during unwrap)#     <<dim3comment>> CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                           #(hash inserted during unwrap)NONE_DERIVED <walls oneface gradp_species0> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<walls oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species0> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<walls oneface gradp_species0>" ON <walls sans oneface> # apply specified pressure over inlet
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <walls oneface gradp_species0> "facesum(<dynamic_force_f_species0>,region=<walls oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species0> "<dynamic_force_f_species0>-<walls oneface gradp_species0>" ON <walls sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <walls oneface gradp_species0> "facesum(facegrad(<p>),region=<walls oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species0> "facegrad(<p>)-<walls oneface gradp_species0>" ON <walls sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <walls oneface p_species0> "facesum(<p_f_species0>,region=<walls oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species0> "<p_f_species0>-<walls oneface p_species0>" ON <walls sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: p"
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: noflux"
                     #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)END_IF
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE 'single_species_boundary_equations' 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)This just generalises the navier-stokes boundary_equations template to a specific species by adding a species1 suffix to all relevant variables
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Now also implements replacements to give phi specific boundaries
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)The species1 string needs to be set before this template file is called
            #(hash inserted during unwrap)END_MARKDOWN
            
            # the 'SUFFIX' replacement type adds a suffix to the variable name.  It doesn't matter what is contained within the [] in the variable name if there are square braces - ie, <u_f_vect[l=1]> will replace all vector components, and also all r indicies of this variable
            # these are variables from the domain
            
            
            
            
            
            
            
            
            
            # these are boundary condition specific variables
            
            
            
            
            
            
            
            
            
            
            
            
            
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)# special case that sets gradient of phi to zero, relevant for outlet boundaries
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)VARIABLE <walls flowrate equation_species1> "facegrad[adjacentcells](<phi_species1>)"
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)# special case that sets a uniform value for phi (equal to <region phi_<<species>>>), relevant for inlet boundaries
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)NONE_CONSTANT <walls phi_species1> "<phi_initial_species1>"
               #(hash inserted during unwrap)VARIABLE <walls flowrate equation_species1> "<phi_f_species1>-<walls phi_species1>"
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               # now include the navier_stokes boundary_equations template file
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations'
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, inlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)This has a few variables that can be set:
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)`zerodynamic` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
                  #(hash inserted during unwrap)`noslip` determines the shear conditions at the boundary
                  #(hash inserted during unwrap)`noflux` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `p`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)The defaults specify a fully developed flow through <walls> with a set flowrate of <walls u_species1> created by varying the uniform <dynamic_force_f_species1> (ie, an inlet).
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # First equation is a constraint on normal velocity gradient normal to the boundary
                  # by default grad{u}:nn = 0
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundary_normal_method>>=rhiechow)
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamic"
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerogradp"
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamiccorrection"
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                     FACE_EQUATION <walls pextrapolation_species1> "<dynamic_force_f_species1>" ON <walls>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <walls pextrapolation_species1> "<dynamic_force_f_{correction}_species1>" ON <walls>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <walls pextrapolation_species1> "facegrad(<p>)" ON <walls>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: zerodynamic"
                     #(hash inserted during unwrap)END_IF
                  
                  # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
                  
                  #REPLACEMENTS D "<<boundary_tangent_method>>" W "slip"
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)INCLUDE "slip" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
                        #(hash inserted during unwrap)INCLUDE "noslip" 
                        
                        FACE_EQUATION <walls noslip1_species1> "dot(<u_f_vect_species1[l=:]>,<facetang1[l=:]>)" ON <walls> # no component tangential to the face
                        #FACE_EQUATION <walls noslip2_species1> "dot(<u_f_vect_species1[l=:]>,<facetang2[l=:]>)" ON <walls> # no component tangential to the face in the second tangential direction
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: noslip"
                     #(hash inserted during unwrap)END_IF
                  
                  # Third equation is a constraint on the velocity or pressure value at the boundary
                  # the first three all specify uniform conditions across the boundary:
                  #REPLACEMENTS D "<<boundary_method>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
                  #REPLACEMENTS D "<<boundary_method>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
                  #REPLACEMENTS D "<<boundary_method>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundary_method>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
                  # all of the remaining methods require a single face within the region to be special cased:
                  #REPLACEMENTS D "<<boundary_method>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
                  # the following two methods set whatever the <<boundary_method_variable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundary_method_variable>>, defaulting to <dynamic_force_f>)
                  # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
                  #REPLACEMENTS D "<<boundary_method>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species1> "<p_f_species1>-<walls p_species1>" ON <walls> # specified pressure
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species1> "<u_f_species1>+<walls u_species1>" ON <walls> # specified velocity
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                     
                     FACE_EQUATION <walls flowrate equation_species1> "<u_f_species1>" ON <walls> # zero velocity
                     
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF  
                     #(hash inserted during unwrap)# all of these boundary methods require the oneface (or centreline) subdomain, so form these first
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)# now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
                     #(hash inserted during unwrap)# by default create the single oneface region here
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)IF <<boundarycreateoneface>>
                        #(hash inserted during unwrap)INCLUDE "oneface_region"
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)IF  
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species1> "<u_f_species1>" ON <walls sans oneface> # zero velocity on most of the region
                        #(hash inserted during unwrap)FACE_EQUATION <walls oneface flowrate equation_species1> "<p_f_species1>" ON <walls oneface>
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 
                           #(hash inserted during unwrap)# for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                           #(hash inserted during unwrap)# to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                           #(hash inserted during unwrap)NONE_DERIVED <walls u_av_calc_species1> "facesum(-<u_f_species1>*<facearea>,<walls>)/facesum(<facearea>,<walls>)" # calculate average velocity directed into the domain
                           #(hash inserted during unwrap)#NONE_DERIVED <walls u_av_calc_species1> "facesum(-<u_f_species1>*<facearea>*1.d0,<walls>)/facesum(<facearea>*1.d0,<walls>)" # calculate average velocity directed into the domain
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)# this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                           #(hash inserted during unwrap)NONE_EQUATION <walls oneface flowrate equation_species1> "<walls u_av_calc_species1>-<walls u_species1>" # set flowrate through region to give required average velocity
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)FACE_EQUATION <walls oneface flowrate equation_species1> "<p_f_species1>-<walls p_species1>" ON <walls oneface> # set pressure at oneface to <region p>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: noflux"
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)# and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "celldivgrad"
                        #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "facegrad"
                        #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "p"
                        #(hash inserted during unwrap)
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 
                           #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                           #(hash inserted during unwrap)#  <<i>> 1,2
                           #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f_species1>)"
                           #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f_species1>)"
                           #(hash inserted during unwrap)#     <<dim1comment>> CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                           #(hash inserted during unwrap)#     <<dim2comment>> CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                           #(hash inserted during unwrap)#     <<dim3comment>> CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                           #(hash inserted during unwrap)NONE_DERIVED <walls oneface gradp_species1> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<walls oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species1> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<walls oneface gradp_species1>" ON <walls sans oneface> # apply specified pressure over inlet
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <walls oneface gradp_species1> "facesum(<dynamic_force_f_species1>,region=<walls oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species1> "<dynamic_force_f_species1>-<walls oneface gradp_species1>" ON <walls sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <walls oneface gradp_species1> "facesum(facegrad(<p>),region=<walls oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species1> "facegrad(<p>)-<walls oneface gradp_species1>" ON <walls sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <walls oneface p_species1> "facesum(<p_f_species1>,region=<walls oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation_species1> "<p_f_species1>-<walls oneface p_species1>" ON <walls sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: p"
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: noflux"
                     #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)END_IF
         
      #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/inlet.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "inlet" # inlet BC
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/boundary_equations.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE 'boundary_equations' 
         
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Boundary conditions for an inlet, outlet or walls.  Choose which by setting '<inlet' equal to either <inlet, <outlet or <walls.
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)To give the region another (or specific) name, do a secondary subsequent substitution when calling, as in
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)```arb
         #(hash inserted during unwrap)INCLUDE_TEMPLATE "multifluid/boundary_equations 
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)```
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)IE, replace <inlet with <inlet first, and then replace <inlet with <inlet1.
         #(hash inserted during unwrap)END_MARKDOWN
         
         # if not otherwise specified, default to inlet boundary conditions
         
         
         # set the default boundary condition methods here for methods that do not change for the boundary type of species being considered
         # otherwise specify the methods individually when calling the navier-stokes boundary_equations template below
         # individual methods can be specified when calling this file to overwrite any of these default (D) methods
         # eg INCLUDE 'boundary_equations' R '<<boundary_method_variable>>' W 'dynamicforce'
         
         # this is the default for p extrapolation at the wall, which can be set specifically for wall boundaries using
         # eg INCLUDE 'boundary_equations' R '<<boundary_normal_wall_method>>' W 'rhiechow'
         #REPLACEMENTS D '<<boundary_normal_wall_method>>' W 'rhiechow'
         # current default for multifluid
         
         
         
         #REPLACEMENTS D '<<boundary_method_variable>>' W 'dynamicforce'
         
         
         # problem is these will break if phi_f_adv is zero as u_f on the boundary is no longer in an equation?
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE 'single_species_boundary_equations' 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)This just generalises the navier-stokes boundary_equations template to a specific species by adding a species0 suffix to all relevant variables
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Now also implements replacements to give phi specific boundaries
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)The species0 string needs to be set before this template file is called
            #(hash inserted during unwrap)END_MARKDOWN
            
            # the 'SUFFIX' replacement type adds a suffix to the variable name.  It doesn't matter what is contained within the [] in the variable name if there are square braces - ie, <u_f_vect[l=1]> will replace all vector components, and also all r indicies of this variable
            # these are variables from the domain
            
            
            
            
            
            
            
            
            
            # these are boundary condition specific variables
            
            
            
            
            
            
            
            
            
            
            
            
            
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)# special case that sets gradient of phi to zero, relevant for outlet boundaries
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)VARIABLE <inlet flowrate equation_species0> "facegrad[adjacentcells](<phi_species0>)"
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)# special case that sets a uniform value for phi (equal to <region phi_<<species>>>), relevant for inlet boundaries
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)NONE_CONSTANT <inlet phi_species0> "<phi_initial_species0>"
               #(hash inserted during unwrap)VARIABLE <inlet flowrate equation_species0> "<phi_f_species0>-<inlet phi_species0>"
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               # now include the navier_stokes boundary_equations template file
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations'
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, inlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)This has a few variables that can be set:
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)`zerogradu` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
                  #(hash inserted during unwrap)`noslip` determines the shear conditions at the boundary
                  #(hash inserted during unwrap)`flowrate` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `p`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)The defaults specify a fully developed flow through <inlet> with a set flowrate of <u_av_species0> created by varying the uniform <dynamic_force_f_species0> (ie, an inlet).
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # First equation is a constraint on normal velocity gradient normal to the boundary
                  # by default grad{u}:nn = 0
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundary_normal_method>>=rhiechow)
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamic"
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerogradp"
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamiccorrection"
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <inlet pextrapolation_species0> "<dynamic_force_f_species0>" ON <inlet>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <inlet pextrapolation_species0> "<dynamic_force_f_{correction}_species0>" ON <inlet>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <inlet pextrapolation_species0> "facegrad(<p>)" ON <inlet>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/u_fully_developed.arb: sub_block = 0
                        #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
                        
                        #(hash inserted during unwrap)MARKDOWN
                        #(hash inserted during unwrap)Sets the gradient of the normal component of velocity normal to a region to zero
                        #(hash inserted during unwrap)END_MARKDOWN
                        
                        #FACE_EQUATION <equation> "facegrad(dot(<u[l=:]>,cellave[lastface](<facenorm[l=:]>)))" ON <region> # normal velocity component is fully developed
                        FACE_EQUATION <inlet fully developed_species0> "ddot(<ugrad_f_species0[l=:,:]>,<facenorm[l=:]>*<facenorm[l=:]>)" ON <inlet> # normal velocity component is fully developed
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: zerogradu"
                     #(hash inserted during unwrap)END_IF
                  
                  # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
                  
                  #REPLACEMENTS D "<<boundary_tangent_method>>" W "slip"
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)INCLUDE "slip" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
                        #(hash inserted during unwrap)INCLUDE "noslip" 
                        
                        FACE_EQUATION <inlet noslip1_species0> "dot(<u_f_vect_species0[l=:]>,<facetang1[l=:]>)" ON <inlet> # no component tangential to the face
                        #FACE_EQUATION <inlet noslip2_species0> "dot(<u_f_vect_species0[l=:]>,<facetang2[l=:]>)" ON <inlet> # no component tangential to the face in the second tangential direction
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: noslip"
                     #(hash inserted during unwrap)END_IF
                  
                  # Third equation is a constraint on the velocity or pressure value at the boundary
                  # the first three all specify uniform conditions across the boundary:
                  #REPLACEMENTS D "<<boundary_method>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
                  #REPLACEMENTS D "<<boundary_method>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
                  #REPLACEMENTS D "<<boundary_method>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundary_method>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
                  # all of the remaining methods require a single face within the region to be special cased:
                  #REPLACEMENTS D "<<boundary_method>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
                  # the following two methods set whatever the <<boundary_method_variable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundary_method_variable>>, defaulting to <dynamic_force_f>)
                  # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
                  #REPLACEMENTS D "<<boundary_method>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species0> "<p_f_species0>-<inlet p_species0>" ON <inlet> # specified pressure
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species0> "<u_f_species0>+<u_av_species0>" ON <inlet> # specified velocity
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species0> "<u_f_species0>" ON <inlet> # zero velocity
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF  1
                     # all of these boundary methods require the oneface (or centreline) subdomain, so form these first
                     
                     # now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
                     # by default create the single oneface region here
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 1
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/oneface_region.arb: sub_block = 0
                           #(hash inserted during unwrap)INCLUDE "oneface_region"
                           #(hash inserted during unwrap)MARKDOWN
                           #(hash inserted during unwrap)Here we define two subregions of <inlet>, one being a single face (<inlet oneface>) and the remainder as <inlet sand oneface>, mainly for the use in setting inidividual equations on boundaries
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)Call with a replacement to '<inlet' to specify where it is applied, as in '<inlet', '<outlet' or '<wall'.  Also can call with 'oneface' replaced by 'centreline' for inlet and outlet ports.
                           #(hash inserted during unwrap)END_MARKDOWN
                           
                           FACE_REGION <inlet oneface> "at(0.d0,0.d0,0.d0)" ON <inlet> # default single cell is chosen closest to the origin
                           FACE_REGION <inlet sans oneface> "compound(<inlet>-<inlet oneface>)" ON <inlet>
                        #(hash inserted during unwrap)END_IF
                     
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 0 
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species0> "<u_f_species0>" ON <inlet sans oneface> # zero velocity on most of the region
                        #(hash inserted during unwrap)FACE_EQUATION <inlet oneface flowrate equation_species0> "<p_f_species0>" ON <inlet oneface>
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 1
                           # for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                           # to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                           NONE_DERIVED <inlet u_av_calc_species0> "facesum(-<u_f_species0>*<facearea>,<inlet>)/facesum(<facearea>,<inlet>)" # calculate average velocity directed into the domain
                           #NONE_DERIVED <inlet u_av_calc_species0> "facesum(-<u_f_species0>*<facearea>*1.d0,<inlet>)/facesum(<facearea>*1.d0,<inlet>)" # calculate average velocity directed into the domain
                           
                           # this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                           NONE_EQUATION <inlet oneface flowrate equation_species0> "<inlet u_av_calc_species0>-<u_av_species0>" # set flowrate through region to give required average velocity
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)FACE_EQUATION <inlet oneface flowrate equation_species0> "<p_f_species0>-<inlet p_species0>" ON <inlet oneface> # set pressure at oneface to <region p>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: flowrate"
                           #(hash inserted during unwrap)END_IF
                        
                        # and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                        
                        # REPLACEMENTS D "<<boundary_method_variable>>" W "celldivgrad"
                        # REPLACEMENTS D "<<boundary_method_variable>>" W "facegrad"
                        # REPLACEMENTS D "<<boundary_method_variable>>" W "p"
                        
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 
                           #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                           #(hash inserted during unwrap)#  <<i>> 1,2
                           #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f_species0>)"
                           #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f_species0>)"
                           #(hash inserted during unwrap)#     <<dim1comment>> CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                           #(hash inserted during unwrap)#     <<dim2comment>> CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                           #(hash inserted during unwrap)#     <<dim3comment>> CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                           #(hash inserted during unwrap)NONE_DERIVED <inlet oneface gradp_species0> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<inlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species0> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<inlet oneface gradp_species0>" ON <inlet sans oneface> # apply specified pressure over inlet
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <inlet oneface gradp_species0> "facesum(<dynamic_force_f_species0>,region=<inlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species0> "<dynamic_force_f_species0>-<inlet oneface gradp_species0>" ON <inlet sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <inlet oneface gradp_species0> "facesum(facegrad(<p>),region=<inlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species0> "facegrad(<p>)-<inlet oneface gradp_species0>" ON <inlet sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 1
                           NONE_DERIVED <inlet oneface p_species0> "facesum(<p_f_species0>,region=<inlet oneface>)"
                           FACE_EQUATION <inlet flowrate equation_species0> "<p_f_species0>-<inlet oneface p_species0>" ON <inlet sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: p"
                           #(hash inserted during unwrap)END_IF
                        
                        #(hash inserted during unwrap)END_IF
                     
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: flowrate"
                     #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)END_IF
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE 'single_species_boundary_equations' 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)This just generalises the navier-stokes boundary_equations template to a specific species by adding a species1 suffix to all relevant variables
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Now also implements replacements to give phi specific boundaries
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)The species1 string needs to be set before this template file is called
            #(hash inserted during unwrap)END_MARKDOWN
            
            # the 'SUFFIX' replacement type adds a suffix to the variable name.  It doesn't matter what is contained within the [] in the variable name if there are square braces - ie, <u_f_vect[l=1]> will replace all vector components, and also all r indicies of this variable
            # these are variables from the domain
            
            
            
            
            
            
            
            
            
            # these are boundary condition specific variables
            
            
            
            
            
            
            
            
            
            
            
            
            
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)# special case that sets gradient of phi to zero, relevant for outlet boundaries
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)VARIABLE <inlet flowrate equation_species1> "facegrad[adjacentcells](<phi_species1>)"
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 1
               # special case that sets a uniform value for phi (equal to <region phi_<<species>>>), relevant for inlet boundaries
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
                  
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, inlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)This has a few variables that can be set:
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)`zerogradu` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
                  #(hash inserted during unwrap)`noslip` determines the shear conditions at the boundary
                  #(hash inserted during unwrap)`pressure` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `p`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)The defaults specify a fully developed flow through <inlet> with a set flowrate of <inlet u_species1> created by varying the uniform <dynamic_force_f_species1> (ie, an inlet).
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # First equation is a constraint on normal velocity gradient normal to the boundary
                  # by default grad{u}:nn = 0
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundary_normal_method>>=rhiechow)
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamic"
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerogradp"
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamiccorrection"
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <inlet pextrapolation_species1> "<dynamic_force_f_species1>" ON <inlet>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <inlet pextrapolation_species1> "<dynamic_force_f_{correction}_species1>" ON <inlet>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <inlet pextrapolation_species1> "facegrad(<p>)" ON <inlet>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/u_fully_developed.arb: sub_block = 0
                        #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
                        
                        #(hash inserted during unwrap)MARKDOWN
                        #(hash inserted during unwrap)Sets the gradient of the normal component of velocity normal to a region to zero
                        #(hash inserted during unwrap)END_MARKDOWN
                        
                        #FACE_EQUATION <equation> "facegrad(dot(<u[l=:]>,cellave[lastface](<facenorm[l=:]>)))" ON <region> # normal velocity component is fully developed
                        FACE_EQUATION <inlet fully developed_species1> "ddot(<ugrad_f_species1[l=:,:]>,<facenorm[l=:]>*<facenorm[l=:]>)" ON <inlet> # normal velocity component is fully developed
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: zerogradu"
                     #(hash inserted during unwrap)END_IF
                  
                  # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
                  
                  #REPLACEMENTS D "<<boundary_tangent_method>>" W "slip"
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)INCLUDE "slip" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
                        #(hash inserted during unwrap)INCLUDE "noslip" 
                        
                        FACE_EQUATION <inlet noslip1_species1> "dot(<u_f_vect_species1[l=:]>,<facetang1[l=:]>)" ON <inlet> # no component tangential to the face
                        #FACE_EQUATION <inlet noslip2_species1> "dot(<u_f_vect_species1[l=:]>,<facetang2[l=:]>)" ON <inlet> # no component tangential to the face in the second tangential direction
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: noslip"
                     #(hash inserted during unwrap)END_IF
                  
                  # Third equation is a constraint on the velocity or pressure value at the boundary
                  # the first three all specify uniform conditions across the boundary:
                  #REPLACEMENTS D "<<boundary_method>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
                  #REPLACEMENTS D "<<boundary_method>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
                  #REPLACEMENTS D "<<boundary_method>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundary_method>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
                  # all of the remaining methods require a single face within the region to be special cased:
                  #REPLACEMENTS D "<<boundary_method>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
                  # the following two methods set whatever the <<boundary_method_variable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundary_method_variable>>, defaulting to <dynamic_force_f>)
                  # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
                  #REPLACEMENTS D "<<boundary_method>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 1
                     
                     FACE_EQUATION <inlet flowrate equation_species1> "<p_f_species1>-<inlet p_species1>" ON <inlet> # specified pressure
                     
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species1> "<u_f_species1>+<inlet u_species1>" ON <inlet> # specified velocity
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species1> "<u_f_species1>" ON <inlet> # zero velocity
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF  
                     #(hash inserted during unwrap)# all of these boundary methods require the oneface (or centreline) subdomain, so form these first
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)# now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
                     #(hash inserted during unwrap)# by default create the single oneface region here
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)IF <<boundarycreateoneface>>
                        #(hash inserted during unwrap)INCLUDE "oneface_region"
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)IF  
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species1> "<u_f_species1>" ON <inlet sans oneface> # zero velocity on most of the region
                        #(hash inserted during unwrap)FACE_EQUATION <inlet oneface flowrate equation_species1> "<p_f_species1>" ON <inlet oneface>
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 
                           #(hash inserted during unwrap)# for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                           #(hash inserted during unwrap)# to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                           #(hash inserted during unwrap)NONE_DERIVED <inlet u_av_calc_species1> "facesum(-<u_f_species1>*<facearea>,<inlet>)/facesum(<facearea>,<inlet>)" # calculate average velocity directed into the domain
                           #(hash inserted during unwrap)#NONE_DERIVED <inlet u_av_calc_species1> "facesum(-<u_f_species1>*<facearea>*1.d0,<inlet>)/facesum(<facearea>*1.d0,<inlet>)" # calculate average velocity directed into the domain
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)# this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                           #(hash inserted during unwrap)NONE_EQUATION <inlet oneface flowrate equation_species1> "<inlet u_av_calc_species1>-<inlet u_species1>" # set flowrate through region to give required average velocity
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)FACE_EQUATION <inlet oneface flowrate equation_species1> "<p_f_species1>-<inlet p_species1>" ON <inlet oneface> # set pressure at oneface to <region p>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: pressure"
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)# and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "celldivgrad"
                        #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "facegrad"
                        #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "p"
                        #(hash inserted during unwrap)
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 
                           #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                           #(hash inserted during unwrap)#  <<i>> 1,2
                           #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f_species1>)"
                           #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f_species1>)"
                           #(hash inserted during unwrap)#     <<dim1comment>> CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                           #(hash inserted during unwrap)#     <<dim2comment>> CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                           #(hash inserted during unwrap)#     <<dim3comment>> CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                           #(hash inserted during unwrap)NONE_DERIVED <inlet oneface gradp_species1> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<inlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species1> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<inlet oneface gradp_species1>" ON <inlet sans oneface> # apply specified pressure over inlet
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <inlet oneface gradp_species1> "facesum(<dynamic_force_f_species1>,region=<inlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species1> "<dynamic_force_f_species1>-<inlet oneface gradp_species1>" ON <inlet sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <inlet oneface gradp_species1> "facesum(facegrad(<p>),region=<inlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species1> "facegrad(<p>)-<inlet oneface gradp_species1>" ON <inlet sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <inlet oneface p_species1> "facesum(<p_f_species1>,region=<inlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation_species1> "<p_f_species1>-<inlet oneface p_species1>" ON <inlet sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: p"
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: pressure"
                     #(hash inserted during unwrap)END_IF
               NONE_CONSTANT <inlet phi_species1> "<phi_initial_species1>"
               VARIABLE <inlet flowrate equation_species1> "<phi_f_species1>-<inlet phi_species1>"
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)# now include the navier_stokes boundary_equations template file
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations'
               #(hash inserted during unwrap)END_IF
         
      #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/outlet.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "outlet" # outlet BC
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/boundary_equations.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE 'boundary_equations' 
         
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Boundary conditions for an inlet, outlet or walls.  Choose which by setting '<outlet' equal to either <inlet, <outlet or <walls.
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)To give the region another (or specific) name, do a secondary subsequent substitution when calling, as in
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)```arb
         #(hash inserted during unwrap)INCLUDE_TEMPLATE "multifluid/boundary_equations 
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)```
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)IE, replace <outlet with <inlet first, and then replace <inlet with <inlet1.
         #(hash inserted during unwrap)END_MARKDOWN
         
         # if not otherwise specified, default to inlet boundary conditions
         
         
         # set the default boundary condition methods here for methods that do not change for the boundary type of species being considered
         # otherwise specify the methods individually when calling the navier-stokes boundary_equations template below
         # individual methods can be specified when calling this file to overwrite any of these default (D) methods
         # eg INCLUDE 'boundary_equations' R '<<boundary_method_variable>>' W 'dynamicforce'
         
         # this is the default for p extrapolation at the wall, which can be set specifically for wall boundaries using
         # eg INCLUDE 'boundary_equations' R '<<boundary_normal_wall_method>>' W 'rhiechow'
         #REPLACEMENTS D '<<boundary_normal_wall_method>>' W 'rhiechow'
         # current default for multifluid
         
         
         
         #REPLACEMENTS D '<<boundary_method_variable>>' W 'dynamicforce'
         
         
         # problem is these will break if phi_f_adv is zero as u_f on the boundary is no longer in an equation?
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE 'single_species_boundary_equations' 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)This just generalises the navier-stokes boundary_equations template to a specific species by adding a species0 suffix to all relevant variables
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Now also implements replacements to give phi specific boundaries
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)The species0 string needs to be set before this template file is called
            #(hash inserted during unwrap)END_MARKDOWN
            
            # the 'SUFFIX' replacement type adds a suffix to the variable name.  It doesn't matter what is contained within the [] in the variable name if there are square braces - ie, <u_f_vect[l=1]> will replace all vector components, and also all r indicies of this variable
            # these are variables from the domain
            
            
            
            
            
            
            
            
            
            # these are boundary condition specific variables
            
            
            
            
            
            
            
            
            
            
            
            
            
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 
               #(hash inserted during unwrap)# special case that sets gradient of phi to zero, relevant for outlet boundaries
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)VARIABLE <outlet flowrate equation_species0> "facegrad[adjacentcells](<phi_species0>)"
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)# special case that sets a uniform value for phi (equal to <region phi_<<species>>>), relevant for inlet boundaries
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)NONE_CONSTANT <outlet phi_species0> "<phi_initial_species0>"
               #(hash inserted during unwrap)VARIABLE <outlet flowrate equation_species0> "<phi_f_species0>-<outlet phi_species0>"
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               # now include the navier_stokes boundary_equations template file
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations'
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, inlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)This has a few variables that can be set:
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)`zerogradu` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
                  #(hash inserted during unwrap)`noslip` determines the shear conditions at the boundary
                  #(hash inserted during unwrap)`onefacepressure` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `p`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)The defaults specify a fully developed flow through <outlet> with a set flowrate of <outlet u_species0> created by varying the uniform <dynamic_force_f_species0> (ie, an inlet).
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # First equation is a constraint on normal velocity gradient normal to the boundary
                  # by default grad{u}:nn = 0
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundary_normal_method>>=rhiechow)
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamic"
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerogradp"
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamiccorrection"
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <outlet pextrapolation_species0> "<dynamic_force_f_species0>" ON <outlet>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <outlet pextrapolation_species0> "<dynamic_force_f_{correction}_species0>" ON <outlet>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <outlet pextrapolation_species0> "facegrad(<p>)" ON <outlet>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/u_fully_developed.arb: sub_block = 0
                        #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
                        
                        #(hash inserted during unwrap)MARKDOWN
                        #(hash inserted during unwrap)Sets the gradient of the normal component of velocity normal to a region to zero
                        #(hash inserted during unwrap)END_MARKDOWN
                        
                        #FACE_EQUATION <equation> "facegrad(dot(<u[l=:]>,cellave[lastface](<facenorm[l=:]>)))" ON <region> # normal velocity component is fully developed
                        FACE_EQUATION <outlet fully developed_species0> "ddot(<ugrad_f_species0[l=:,:]>,<facenorm[l=:]>*<facenorm[l=:]>)" ON <outlet> # normal velocity component is fully developed
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: zerogradu"
                     #(hash inserted during unwrap)END_IF
                  
                  # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
                  
                  #REPLACEMENTS D "<<boundary_tangent_method>>" W "slip"
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)INCLUDE "slip" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
                        #(hash inserted during unwrap)INCLUDE "noslip" 
                        
                        FACE_EQUATION <outlet noslip1_species0> "dot(<u_f_vect_species0[l=:]>,<facetang1[l=:]>)" ON <outlet> # no component tangential to the face
                        #FACE_EQUATION <outlet noslip2_species0> "dot(<u_f_vect_species0[l=:]>,<facetang2[l=:]>)" ON <outlet> # no component tangential to the face in the second tangential direction
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: noslip"
                     #(hash inserted during unwrap)END_IF
                  
                  # Third equation is a constraint on the velocity or pressure value at the boundary
                  # the first three all specify uniform conditions across the boundary:
                  #REPLACEMENTS D "<<boundary_method>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
                  #REPLACEMENTS D "<<boundary_method>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
                  #REPLACEMENTS D "<<boundary_method>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundary_method>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
                  # all of the remaining methods require a single face within the region to be special cased:
                  #REPLACEMENTS D "<<boundary_method>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
                  # the following two methods set whatever the <<boundary_method_variable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundary_method_variable>>, defaulting to <dynamic_force_f>)
                  # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
                  #REPLACEMENTS D "<<boundary_method>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species0> "<p_f_species0>-0" ON <outlet> # specified pressure
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species0> "<u_f_species0>+<outlet u_species0>" ON <outlet> # specified velocity
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species0> "<u_f_species0>" ON <outlet> # zero velocity
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF  1
                     # all of these boundary methods require the oneface (or centreline) subdomain, so form these first
                     
                     # now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
                     # by default create the single oneface region here
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 1
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/oneface_region.arb: sub_block = 0
                           #(hash inserted during unwrap)INCLUDE "oneface_region"
                           #(hash inserted during unwrap)MARKDOWN
                           #(hash inserted during unwrap)Here we define two subregions of <outlet>, one being a single face (<outlet oneface>) and the remainder as <outlet sand oneface>, mainly for the use in setting inidividual equations on boundaries
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)Call with a replacement to '<outlet' to specify where it is applied, as in '<inlet', '<outlet' or '<wall'.  Also can call with 'oneface' replaced by 'centreline' for inlet and outlet ports.
                           #(hash inserted during unwrap)END_MARKDOWN
                           
                           FACE_REGION <outlet oneface> "at(0.d0,0.d0,0.d0)" ON <outlet> # default single cell is chosen closest to the origin
                           FACE_REGION <outlet sans oneface> "compound(<outlet>-<outlet oneface>)" ON <outlet>
                        #(hash inserted during unwrap)END_IF
                     
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 0 
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species0> "<u_f_species0>" ON <outlet sans oneface> # zero velocity on most of the region
                        #(hash inserted during unwrap)FACE_EQUATION <outlet oneface flowrate equation_species0> "<p_f_species0>" ON <outlet oneface>
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 
                           #(hash inserted during unwrap)# for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                           #(hash inserted during unwrap)# to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                           #(hash inserted during unwrap)NONE_DERIVED <outlet u_av_calc_species0> "facesum(-<u_f_species0>*<facearea>,<outlet>)/facesum(<facearea>,<outlet>)" # calculate average velocity directed into the domain
                           #(hash inserted during unwrap)#NONE_DERIVED <outlet u_av_calc_species0> "facesum(-<u_f_species0>*<facearea>*1.d0,<outlet>)/facesum(<facearea>*1.d0,<outlet>)" # calculate average velocity directed into the domain
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)# this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                           #(hash inserted during unwrap)NONE_EQUATION <outlet oneface flowrate equation_species0> "<outlet u_av_calc_species0>-<outlet u_species0>" # set flowrate through region to give required average velocity
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 1
                           FACE_EQUATION <outlet oneface flowrate equation_species0> "<p_f_species0>-0" ON <outlet oneface> # set pressure at oneface to <region p>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: onefacepressure"
                           #(hash inserted during unwrap)END_IF
                        
                        # and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                        
                        # REPLACEMENTS D "<<boundary_method_variable>>" W "celldivgrad"
                        # REPLACEMENTS D "<<boundary_method_variable>>" W "facegrad"
                        # REPLACEMENTS D "<<boundary_method_variable>>" W "p"
                        
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 
                           #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                           #(hash inserted during unwrap)#  <<i>> 1,2
                           #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f_species0>)"
                           #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f_species0>)"
                           #(hash inserted during unwrap)#     <<dim1comment>> CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                           #(hash inserted during unwrap)#     <<dim2comment>> CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                           #(hash inserted during unwrap)#     <<dim3comment>> CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                           #(hash inserted during unwrap)NONE_DERIVED <outlet oneface gradp_species0> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<outlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species0> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<outlet oneface gradp_species0>" ON <outlet sans oneface> # apply specified pressure over inlet
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <outlet oneface gradp_species0> "facesum(<dynamic_force_f_species0>,region=<outlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species0> "<dynamic_force_f_species0>-<outlet oneface gradp_species0>" ON <outlet sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <outlet oneface gradp_species0> "facesum(facegrad(<p>),region=<outlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species0> "facegrad(<p>)-<outlet oneface gradp_species0>" ON <outlet sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 1
                           NONE_DERIVED <outlet oneface p_species0> "facesum(<p_f_species0>,region=<outlet oneface>)"
                           FACE_EQUATION <outlet flowrate equation_species0> "<p_f_species0>-<outlet oneface p_species0>" ON <outlet sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: p"
                           #(hash inserted during unwrap)END_IF
                        
                        #(hash inserted during unwrap)END_IF
                     
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: onefacepressure"
                     #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)END_IF
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE 'single_species_boundary_equations' 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)This just generalises the navier-stokes boundary_equations template to a specific species by adding a species1 suffix to all relevant variables
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Now also implements replacements to give phi specific boundaries
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)The species1 string needs to be set before this template file is called
            #(hash inserted during unwrap)END_MARKDOWN
            
            # the 'SUFFIX' replacement type adds a suffix to the variable name.  It doesn't matter what is contained within the [] in the variable name if there are square braces - ie, <u_f_vect[l=1]> will replace all vector components, and also all r indicies of this variable
            # these are variables from the domain
            
            
            
            
            
            
            
            
            
            # these are boundary condition specific variables
            
            
            
            
            
            
            
            
            
            
            
            
            
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 1
               # special case that sets gradient of phi to zero, relevant for outlet boundaries
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
                  
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, inlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)This has a few variables that can be set:
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)`zerogradu` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
                  #(hash inserted during unwrap)`noslip` determines the shear conditions at the boundary
                  #(hash inserted during unwrap)`pressure` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `p`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)The defaults specify a fully developed flow through <outlet> with a set flowrate of <outlet u_species1> created by varying the uniform <dynamic_force_f_species1> (ie, an inlet).
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # First equation is a constraint on normal velocity gradient normal to the boundary
                  # by default grad{u}:nn = 0
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundary_normal_method>>=rhiechow)
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamic"
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerogradp"
                  #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamiccorrection"
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <outlet pextrapolation_species1> "<dynamic_force_f_species1>" ON <outlet>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <outlet pextrapolation_species1> "<dynamic_force_f_{correction}_species1>" ON <outlet>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <outlet pextrapolation_species1> "facegrad(<p>)" ON <outlet>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/u_fully_developed.arb: sub_block = 0
                        #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
                        
                        #(hash inserted during unwrap)MARKDOWN
                        #(hash inserted during unwrap)Sets the gradient of the normal component of velocity normal to a region to zero
                        #(hash inserted during unwrap)END_MARKDOWN
                        
                        #FACE_EQUATION <equation> "facegrad(dot(<u[l=:]>,cellave[lastface](<facenorm[l=:]>)))" ON <region> # normal velocity component is fully developed
                        FACE_EQUATION <outlet fully developed_species1> "ddot(<ugrad_f_species1[l=:,:]>,<facenorm[l=:]>*<facenorm[l=:]>)" ON <outlet> # normal velocity component is fully developed
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: zerogradu"
                     #(hash inserted during unwrap)END_IF
                  
                  # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
                  
                  #REPLACEMENTS D "<<boundary_tangent_method>>" W "slip"
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)INCLUDE "slip" 
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 1
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
                        #(hash inserted during unwrap)INCLUDE "noslip" 
                        
                        FACE_EQUATION <outlet noslip1_species1> "dot(<u_f_vect_species1[l=:]>,<facetang1[l=:]>)" ON <outlet> # no component tangential to the face
                        #FACE_EQUATION <outlet noslip2_species1> "dot(<u_f_vect_species1[l=:]>,<facetang2[l=:]>)" ON <outlet> # no component tangential to the face in the second tangential direction
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: noslip"
                     #(hash inserted during unwrap)END_IF
                  
                  # Third equation is a constraint on the velocity or pressure value at the boundary
                  # the first three all specify uniform conditions across the boundary:
                  #REPLACEMENTS D "<<boundary_method>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
                  #REPLACEMENTS D "<<boundary_method>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
                  #REPLACEMENTS D "<<boundary_method>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundary_method>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
                  # all of the remaining methods require a single face within the region to be special cased:
                  #REPLACEMENTS D "<<boundary_method>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
                  # the following two methods set whatever the <<boundary_method_variable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundary_method_variable>>, defaulting to <dynamic_force_f>)
                  # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
                  #REPLACEMENTS D "<<boundary_method>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 1
                     
                     FACE_EQUATION <outlet flowrate equation_species1> "<p_f_species1>-<outlet p_species1>" ON <outlet> # specified pressure
                     
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species1> "<u_f_species1>+<outlet u_species1>" ON <outlet> # specified velocity
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species1> "<u_f_species1>" ON <outlet> # zero velocity
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF  
                     #(hash inserted during unwrap)# all of these boundary methods require the oneface (or centreline) subdomain, so form these first
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)# now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
                     #(hash inserted during unwrap)# by default create the single oneface region here
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)IF <<boundarycreateoneface>>
                        #(hash inserted during unwrap)INCLUDE "oneface_region"
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)IF  
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species1> "<u_f_species1>" ON <outlet sans oneface> # zero velocity on most of the region
                        #(hash inserted during unwrap)FACE_EQUATION <outlet oneface flowrate equation_species1> "<p_f_species1>" ON <outlet oneface>
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 
                           #(hash inserted during unwrap)# for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                           #(hash inserted during unwrap)# to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                           #(hash inserted during unwrap)NONE_DERIVED <outlet u_av_calc_species1> "facesum(-<u_f_species1>*<facearea>,<outlet>)/facesum(<facearea>,<outlet>)" # calculate average velocity directed into the domain
                           #(hash inserted during unwrap)#NONE_DERIVED <outlet u_av_calc_species1> "facesum(-<u_f_species1>*<facearea>*1.d0,<outlet>)/facesum(<facearea>*1.d0,<outlet>)" # calculate average velocity directed into the domain
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)# this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                           #(hash inserted during unwrap)NONE_EQUATION <outlet oneface flowrate equation_species1> "<outlet u_av_calc_species1>-<outlet u_species1>" # set flowrate through region to give required average velocity
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)FACE_EQUATION <outlet oneface flowrate equation_species1> "<p_f_species1>-<outlet p_species1>" ON <outlet oneface> # set pressure at oneface to <region p>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: pressure"
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)# and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "celldivgrad"
                        #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "facegrad"
                        #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "p"
                        #(hash inserted during unwrap)
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 
                           #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                           #(hash inserted during unwrap)#  <<i>> 1,2
                           #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f_species1>)"
                           #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f_species1>)"
                           #(hash inserted during unwrap)#     <<dim1comment>> CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                           #(hash inserted during unwrap)#     <<dim2comment>> CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                           #(hash inserted during unwrap)#     <<dim3comment>> CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                           #(hash inserted during unwrap)NONE_DERIVED <outlet oneface gradp_species1> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<outlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species1> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<outlet oneface gradp_species1>" ON <outlet sans oneface> # apply specified pressure over inlet
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <outlet oneface gradp_species1> "facesum(<dynamic_force_f_species1>,region=<outlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species1> "<dynamic_force_f_species1>-<outlet oneface gradp_species1>" ON <outlet sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <outlet oneface gradp_species1> "facesum(facegrad(<p>),region=<outlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species1> "facegrad(<p>)-<outlet oneface gradp_species1>" ON <outlet sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE_IF 
                           #(hash inserted during unwrap)NONE_DERIVED <outlet oneface p_species1> "facesum(<p_f_species1>,region=<outlet oneface>)"
                           #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation_species1> "<p_f_species1>-<outlet oneface p_species1>" ON <outlet sans oneface>
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                           #(hash inserted during unwrap)ELSE
                           #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: p"
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: pressure"
                     #(hash inserted during unwrap)END_IF
               VARIABLE <outlet flowrate equation_species1> "facegrad[adjacentcells](<phi_species1>)"
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)# special case that sets a uniform value for phi (equal to <region phi_<<species>>>), relevant for inlet boundaries
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)NONE_CONSTANT <outlet phi_species1> "<phi_initial_species1>"
               #(hash inserted during unwrap)VARIABLE <outlet flowrate equation_species1> "<phi_f_species1>-<outlet phi_species1>"
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)# now include the navier_stokes boundary_equations template file
               #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations'
               #(hash inserted during unwrap)END_IF
         
   
      #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 1
      #(hash inserted during unwrap)IF 1
      # rewrite inlet BCs so that we actually set the flow through the outlet
      # NONE_LOCAL <outlet u_av_calc_species0> [1] "facesum(<u_f_species0>*<facearea>,region=<outlet>)/facesum(<facearea>,region=<outlet>)"
      # NONE_DERIVED <inlet u_av_calc_species0> CANCEL
      # NONE_EQUATION <inlet oneface flowrate equation_species0> [1] "<outlet u_av_calc_species0>-<u_av_species0>" # other information: region = empty: deriv = 1: newtstepmax = empty: newtstepmin = empty: filename = ../../../development/current/templates/navier_stokes/boundary_equations.arb: absfilename = /Users/daltonh/codes/arb/development/current/templates/navier_stokes/boundary_equations.arb: comments = # set flowrate through region to give required average velocity
      NONE_CONSTANT <trans_membrane_pressure> [Pa] 1.d5 # trans membrane pressure, which sets the gauge pressure at the outlet
      # NONE_CONSTANT <trans_membrane_pressure> [Pa] 1.d4 # trans membrane pressure, which sets the gauge pressure at the outlet
      # NONE_CONSTANT <trans_membrane_pressure> [Pa] 1.d3 # trans membrane pressure, which sets the gauge pressure at the outlet
         #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 2
         #(hash inserted during unwrap)IF 0
         #(hash inserted during unwrap)# ramp up TMP with time
         #(hash inserted during unwrap)NONE_CONSTANT <trans_membrane_pressure_ramp_time> [s] 1.0d0 #
         #(hash inserted during unwrap)NONE_TRANSIENT <trans_membrane_pressure_variation> "<trans_membrane_pressure>*nonemin(<t>/<trans_membrane_pressure_ramp_time>,1.d0)" stepoutput
         #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 2
         #(hash inserted during unwrap)ELSE
         # no ramp
         NONE_TRANSIENT <trans_membrane_pressure_variation> "<trans_membrane_pressure>" stepoutput
         #(hash inserted during unwrap)END_IF
      NONE_CONSTANT <membrane_resistance> [1/m] 4.77d12 # resistance of membrane
      # NONE_CONSTANT <membrane_resistance> [1/m] 4.77d32 # resistance of membrane
      # make an artifically lower resistance to up the flux
      # NONE_CONSTANT <membrane_resistance> [1/m] 4.77d9 # resistance of membrane
      # INCLUDE "boundary_equations" R '<walls' W '<membrane' R '<region' W '<walls' # walls BC
         #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/walls.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "walls" 
         
            #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/boundary_equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE 'boundary_equations' 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)Boundary conditions for an inlet, outlet or walls.  Choose which by setting '<membrane' equal to either <inlet, <outlet or <membrane.
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)To give the region another (or specific) name, do a secondary subsequent substitution when calling, as in
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)```arb
            #(hash inserted during unwrap)INCLUDE_TEMPLATE "multifluid/boundary_equations 
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)```
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)IE, replace <membrane with <inlet first, and then replace <inlet with <inlet1.
            #(hash inserted during unwrap)END_MARKDOWN
            
            # if not otherwise specified, default to inlet boundary conditions
            
            
            # set the default boundary condition methods here for methods that do not change for the boundary type of species being considered
            # otherwise specify the methods individually when calling the navier-stokes boundary_equations template below
            # individual methods can be specified when calling this file to overwrite any of these default (D) methods
            # eg INCLUDE 'boundary_equations' R '<<boundary_method_variable>>' W 'dynamicforce'
            
            # this is the default for p extrapolation at the wall, which can be set specifically for wall boundaries using
            # eg INCLUDE 'boundary_equations' R '<<boundary_normal_wall_method>>' W 'rhiechow'
            #REPLACEMENTS D '<<boundary_normal_wall_method>>' W 'rhiechow'
            # current default for multifluid
            
            
            
            #REPLACEMENTS D '<<boundary_method_variable>>' W 'dynamicforce'
            
            
            # problem is these will break if phi_f_adv is zero as u_f on the boundary is no longer in an equation?
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE 'single_species_boundary_equations' 
               
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)This just generalises the navier-stokes boundary_equations template to a specific species by adding a species0 suffix to all relevant variables
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)Now also implements replacements to give phi specific boundaries
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)The species0 string needs to be set before this template file is called
               #(hash inserted during unwrap)END_MARKDOWN
               
               # the 'SUFFIX' replacement type adds a suffix to the variable name.  It doesn't matter what is contained within the [] in the variable name if there are square braces - ie, <u_f_vect[l=1]> will replace all vector components, and also all r indicies of this variable
               # these are variables from the domain
               
               
               
               
               
               
               
               
               
               # these are boundary condition specific variables
               
               
               
               
               
               
               
               
               
               
               
               
               
               
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)# special case that sets gradient of phi to zero, relevant for outlet boundaries
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)VARIABLE <membrane flowrate equation_species0> "facegrad[adjacentcells](<phi_species0>)"
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)# special case that sets a uniform value for phi (equal to <region phi_<<species>>>), relevant for inlet boundaries
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)NONE_CONSTANT <membrane phi_species0> "<phi_initial_species0>"
                  #(hash inserted during unwrap)VARIABLE <membrane flowrate equation_species0> "<phi_f_species0>-<membrane phi_species0>"
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE
                  # now include the navier_stokes boundary_equations template file
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
                     #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations'
                     #(hash inserted during unwrap)MARKDOWN
                     #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, inlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)This has a few variables that can be set:
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)`zerodynamic` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
                     #(hash inserted during unwrap)`noslip` determines the shear conditions at the boundary
                     #(hash inserted during unwrap)`noflux` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `p`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)The defaults specify a fully developed flow through <membrane> with a set flowrate of <membrane u_species0> created by varying the uniform <dynamic_force_f_species0> (ie, an inlet).
                     #(hash inserted during unwrap)END_MARKDOWN
                     
                     # First equation is a constraint on normal velocity gradient normal to the boundary
                     # by default grad{u}:nn = 0
                     #REPLACEMENTS D "<<boundary_normal_method>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundary_normal_method>>=rhiechow)
                     #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamic"
                     #REPLACEMENTS D "<<boundary_normal_method>>" W "zerogradp"
                     #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamiccorrection"
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)IF 
                        #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 1
                        FACE_EQUATION <membrane pextrapolation_species0> "<dynamic_force_f_species0>" ON <membrane>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 
                        #(hash inserted during unwrap)FACE_EQUATION <membrane pextrapolation_species0> "<dynamic_force_f_{correction}_species0>" ON <membrane>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 
                        #(hash inserted during unwrap)FACE_EQUATION <membrane pextrapolation_species0> "facegrad(<p>)" ON <membrane>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 
                        #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: zerodynamic"
                        #(hash inserted during unwrap)END_IF
                     
                     # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
                     
                     #REPLACEMENTS D "<<boundary_tangent_method>>" W "slip"
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)IF 
                        #(hash inserted during unwrap)INCLUDE "slip" 
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 1
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
                           #(hash inserted during unwrap)INCLUDE "noslip" 
                           
                           FACE_EQUATION <membrane noslip1_species0> "dot(<u_f_vect_species0[l=:]>,<facetang1[l=:]>)" ON <membrane> # no component tangential to the face
                           #FACE_EQUATION <membrane noslip2_species0> "dot(<u_f_vect_species0[l=:]>,<facetang2[l=:]>)" ON <membrane> # no component tangential to the face in the second tangential direction
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: noslip"
                        #(hash inserted during unwrap)END_IF
                     
                     # Third equation is a constraint on the velocity or pressure value at the boundary
                     # the first three all specify uniform conditions across the boundary:
                     #REPLACEMENTS D "<<boundary_method>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
                     #REPLACEMENTS D "<<boundary_method>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
                     #REPLACEMENTS D "<<boundary_method>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundary_method>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
                     # all of the remaining methods require a single face within the region to be special cased:
                     #REPLACEMENTS D "<<boundary_method>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
                     # the following two methods set whatever the <<boundary_method_variable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundary_method_variable>>, defaulting to <dynamic_force_f>)
                     # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
                     #REPLACEMENTS D "<<boundary_method>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
                     
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)IF 
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species0> "<p_f_species0>-<membrane p_species0>" ON <membrane> # specified pressure
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species0> "<u_f_species0>+<membrane u_species0>" ON <membrane> # specified velocity
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 1
                        
                        FACE_EQUATION <membrane flowrate equation_species0> "<u_f_species0>" ON <membrane> # zero velocity
                        
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF  
                        #(hash inserted during unwrap)# all of these boundary methods require the oneface (or centreline) subdomain, so form these first
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)# now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
                        #(hash inserted during unwrap)# by default create the single oneface region here
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                           #(hash inserted during unwrap)IF <<boundarycreateoneface>>
                           #(hash inserted during unwrap)INCLUDE "oneface_region"
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                           #(hash inserted during unwrap)IF  
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species0> "<u_f_species0>" ON <membrane sans oneface> # zero velocity on most of the region
                           #(hash inserted during unwrap)FACE_EQUATION <membrane oneface flowrate equation_species0> "<p_f_species0>" ON <membrane oneface>
                           #(hash inserted during unwrap)
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                           #(hash inserted during unwrap)ELSE
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)IF 
                              #(hash inserted during unwrap)# for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                              #(hash inserted during unwrap)# to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                              #(hash inserted during unwrap)NONE_DERIVED <membrane u_av_calc_species0> "facesum(-<u_f_species0>*<facearea>,<membrane>)/facesum(<facearea>,<membrane>)" # calculate average velocity directed into the domain
                              #(hash inserted during unwrap)#NONE_DERIVED <membrane u_av_calc_species0> "facesum(-<u_f_species0>*<facearea>*1.d0,<membrane>)/facesum(<facearea>*1.d0,<membrane>)" # calculate average velocity directed into the domain
                              #(hash inserted during unwrap)
                              #(hash inserted during unwrap)# this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                              #(hash inserted during unwrap)NONE_EQUATION <membrane oneface flowrate equation_species0> "<membrane u_av_calc_species0>-<membrane u_species0>" # set flowrate through region to give required average velocity
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)ELSE_IF 
                              #(hash inserted during unwrap)FACE_EQUATION <membrane oneface flowrate equation_species0> "<p_f_species0>-<membrane p_species0>" ON <membrane oneface> # set pressure at oneface to <region p>
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)ELSE
                              #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: noflux"
                              #(hash inserted during unwrap)END_IF
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)# and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "celldivgrad"
                           #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "facegrad"
                           #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "p"
                           #(hash inserted during unwrap)
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)IF 
                              #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                              #(hash inserted during unwrap)#  <<i>> 1,2
                              #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f_species0>)"
                              #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f_species0>)"
                              #(hash inserted during unwrap)#     <<dim1comment>> CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                              #(hash inserted during unwrap)#     <<dim2comment>> CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                              #(hash inserted during unwrap)#     <<dim3comment>> CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                              #(hash inserted during unwrap)NONE_DERIVED <membrane oneface gradp_species0> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<membrane oneface>)"
                              #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species0> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<membrane oneface gradp_species0>" ON <membrane sans oneface> # apply specified pressure over inlet
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)ELSE_IF 
                              #(hash inserted during unwrap)NONE_DERIVED <membrane oneface gradp_species0> "facesum(<dynamic_force_f_species0>,region=<membrane oneface>)"
                              #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species0> "<dynamic_force_f_species0>-<membrane oneface gradp_species0>" ON <membrane sans oneface>
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)ELSE_IF 
                              #(hash inserted during unwrap)NONE_DERIVED <membrane oneface gradp_species0> "facesum(facegrad(<p>),region=<membrane oneface>)"
                              #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species0> "facegrad(<p>)-<membrane oneface gradp_species0>" ON <membrane sans oneface>
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)ELSE_IF 
                              #(hash inserted during unwrap)NONE_DERIVED <membrane oneface p_species0> "facesum(<p_f_species0>,region=<membrane oneface>)"
                              #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species0> "<p_f_species0>-<membrane oneface p_species0>" ON <membrane sans oneface>
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)ELSE
                              #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: p"
                              #(hash inserted during unwrap)END_IF
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: noflux"
                        #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)END_IF
            
               #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE 'single_species_boundary_equations' 
               
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)This just generalises the navier-stokes boundary_equations template to a specific species by adding a species1 suffix to all relevant variables
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)Now also implements replacements to give phi specific boundaries
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)The species1 string needs to be set before this template file is called
               #(hash inserted during unwrap)END_MARKDOWN
               
               # the 'SUFFIX' replacement type adds a suffix to the variable name.  It doesn't matter what is contained within the [] in the variable name if there are square braces - ie, <u_f_vect[l=1]> will replace all vector components, and also all r indicies of this variable
               # these are variables from the domain
               
               
               
               
               
               
               
               
               
               # these are boundary condition specific variables
               
               
               
               
               
               
               
               
               
               
               
               
               
               
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)# special case that sets gradient of phi to zero, relevant for outlet boundaries
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)VARIABLE <membrane flowrate equation_species1> "facegrad[adjacentcells](<phi_species1>)"
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)# special case that sets a uniform value for phi (equal to <region phi_<<species>>>), relevant for inlet boundaries
                  #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations' 
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)NONE_CONSTANT <membrane phi_species1> "<phi_initial_species1>"
                  #(hash inserted during unwrap)VARIABLE <membrane flowrate equation_species1> "<phi_f_species1>-<membrane phi_species1>"
                  #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/single_species_boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE
                  # now include the navier_stokes boundary_equations template file
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
                     #(hash inserted during unwrap)INCLUDE_TEMPLATE 'navier_stokes/boundary_equations'
                     #(hash inserted during unwrap)MARKDOWN
                     #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, inlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)This has a few variables that can be set:
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)`zerodynamic` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
                     #(hash inserted during unwrap)`noslip` determines the shear conditions at the boundary
                     #(hash inserted during unwrap)`noflux` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `p`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)The defaults specify a fully developed flow through <membrane> with a set flowrate of <membrane u_species1> created by varying the uniform <dynamic_force_f_species1> (ie, an inlet).
                     #(hash inserted during unwrap)END_MARKDOWN
                     
                     # First equation is a constraint on normal velocity gradient normal to the boundary
                     # by default grad{u}:nn = 0
                     #REPLACEMENTS D "<<boundary_normal_method>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundary_normal_method>>=rhiechow)
                     #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamic"
                     #REPLACEMENTS D "<<boundary_normal_method>>" W "zerogradp"
                     #REPLACEMENTS D "<<boundary_normal_method>>" W "zerodynamiccorrection"
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)IF 
                        #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 1
                        FACE_EQUATION <membrane pextrapolation_species1> "<dynamic_force_f_species1>" ON <membrane>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 
                        #(hash inserted during unwrap)FACE_EQUATION <membrane pextrapolation_species1> "<dynamic_force_f_{correction}_species1>" ON <membrane>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 
                        #(hash inserted during unwrap)FACE_EQUATION <membrane pextrapolation_species1> "facegrad(<p>)" ON <membrane>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 
                        #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: zerodynamic"
                        #(hash inserted during unwrap)END_IF
                     
                     # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
                     
                     #REPLACEMENTS D "<<boundary_tangent_method>>" W "slip"
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)IF 
                        #(hash inserted during unwrap)INCLUDE "slip" 
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 1
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
                           #(hash inserted during unwrap)INCLUDE "noslip" 
                           
                           FACE_EQUATION <membrane noslip1_species1> "dot(<u_f_vect_species1[l=:]>,<facetang1[l=:]>)" ON <membrane> # no component tangential to the face
                           #FACE_EQUATION <membrane noslip2_species1> "dot(<u_f_vect_species1[l=:]>,<facetang2[l=:]>)" ON <membrane> # no component tangential to the face in the second tangential direction
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: noslip"
                        #(hash inserted during unwrap)END_IF
                     
                     # Third equation is a constraint on the velocity or pressure value at the boundary
                     # the first three all specify uniform conditions across the boundary:
                     #REPLACEMENTS D "<<boundary_method>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
                     #REPLACEMENTS D "<<boundary_method>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
                     #REPLACEMENTS D "<<boundary_method>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundary_method>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
                     # all of the remaining methods require a single face within the region to be special cased:
                     #REPLACEMENTS D "<<boundary_method>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
                     # the following two methods set whatever the <<boundary_method_variable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundary_method_variable>>, defaulting to <dynamic_force_f>)
                     # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
                     #REPLACEMENTS D "<<boundary_method>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
                     
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)IF 
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species1> "<p_f_species1>-<membrane p_species1>" ON <membrane> # specified pressure
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species1> "<u_f_species1>+<membrane u_species1>" ON <membrane> # specified velocity
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF 1
                        
                        FACE_EQUATION <membrane flowrate equation_species1> "<u_f_species1>" ON <membrane> # zero velocity
                        
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE_IF  
                        #(hash inserted during unwrap)# all of these boundary methods require the oneface (or centreline) subdomain, so form these first
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)# now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
                        #(hash inserted during unwrap)# by default create the single oneface region here
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                           #(hash inserted during unwrap)IF <<boundarycreateoneface>>
                           #(hash inserted during unwrap)INCLUDE "oneface_region"
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                           #(hash inserted during unwrap)IF  
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species1> "<u_f_species1>" ON <membrane sans oneface> # zero velocity on most of the region
                           #(hash inserted during unwrap)FACE_EQUATION <membrane oneface flowrate equation_species1> "<p_f_species1>" ON <membrane oneface>
                           #(hash inserted during unwrap)
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                           #(hash inserted during unwrap)ELSE
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)IF 
                              #(hash inserted during unwrap)# for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                              #(hash inserted during unwrap)# to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                              #(hash inserted during unwrap)NONE_DERIVED <membrane u_av_calc_species1> "facesum(-<u_f_species1>*<facearea>,<membrane>)/facesum(<facearea>,<membrane>)" # calculate average velocity directed into the domain
                              #(hash inserted during unwrap)#NONE_DERIVED <membrane u_av_calc_species1> "facesum(-<u_f_species1>*<facearea>*1.d0,<membrane>)/facesum(<facearea>*1.d0,<membrane>)" # calculate average velocity directed into the domain
                              #(hash inserted during unwrap)
                              #(hash inserted during unwrap)# this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                              #(hash inserted during unwrap)NONE_EQUATION <membrane oneface flowrate equation_species1> "<membrane u_av_calc_species1>-<membrane u_species1>" # set flowrate through region to give required average velocity
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)ELSE_IF 
                              #(hash inserted during unwrap)FACE_EQUATION <membrane oneface flowrate equation_species1> "<p_f_species1>-<membrane p_species1>" ON <membrane oneface> # set pressure at oneface to <region p>
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)ELSE
                              #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: noflux"
                              #(hash inserted during unwrap)END_IF
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)# and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "celldivgrad"
                           #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "facegrad"
                           #(hash inserted during unwrap)# REPLACEMENTS D "<<boundary_method_variable>>" W "p"
                           #(hash inserted during unwrap)
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)IF 
                              #(hash inserted during unwrap)# performing index string loops on the following index list pairs:
                              #(hash inserted during unwrap)#  <<i>> 1,2
                              #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f_species1>)"
                              #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f_species1>)"
                              #(hash inserted during unwrap)#     <<dim1comment>> CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                              #(hash inserted during unwrap)#     <<dim2comment>> CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                              #(hash inserted during unwrap)#     <<dim3comment>> CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                              #(hash inserted during unwrap)NONE_DERIVED <membrane oneface gradp_species1> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<membrane oneface>)"
                              #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species1> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<membrane oneface gradp_species1>" ON <membrane sans oneface> # apply specified pressure over inlet
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)ELSE_IF 
                              #(hash inserted during unwrap)NONE_DERIVED <membrane oneface gradp_species1> "facesum(<dynamic_force_f_species1>,region=<membrane oneface>)"
                              #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species1> "<dynamic_force_f_species1>-<membrane oneface gradp_species1>" ON <membrane sans oneface>
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)ELSE_IF 
                              #(hash inserted during unwrap)NONE_DERIVED <membrane oneface gradp_species1> "facesum(facegrad(<p>),region=<membrane oneface>)"
                              #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species1> "facegrad(<p>)-<membrane oneface gradp_species1>" ON <membrane sans oneface>
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)ELSE_IF 
                              #(hash inserted during unwrap)NONE_DERIVED <membrane oneface p_species1> "facesum(<p_f_species1>,region=<membrane oneface>)"
                              #(hash inserted during unwrap)FACE_EQUATION <membrane flowrate equation_species1> "<p_f_species1>-<membrane oneface p_species1>" ON <membrane sans oneface>
                              #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                              #(hash inserted during unwrap)ELSE
                              #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: p"
                              #(hash inserted during unwrap)END_IF
                           #(hash inserted during unwrap)
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: noflux"
                        #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)END_IF
            
      # FACE_EQUATION <membrane flowrate equation_species0> "<u_f_species0>-(<p_f_species0>+<trans_membrane_pressure>)/(<mu_species0>*<membrane_resistance>)"
      FACE_EQUATION <membrane flowrate equation_species0> "<u_f_species0>-(<p_f_species0>+<trans_membrane_pressure_variation>)/(<mu_species0>*<membrane_resistance>)"
      # performing index string loops on the following index list pairs:
      #  <<i>> 1,2
      FACE_OUTPUT <membrane_flux_vect[l=1]> "<u_f_species0>*<facenorm[l=1]>" ON <membrane>
      FACE_OUTPUT <membrane_flux_vect[l=2]> "<u_f_species0>*<facenorm[l=2]>" ON <membrane>
      #(hash inserted during unwrap)END_IF
   
      #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 1
      #(hash inserted during unwrap)IF 0
      #(hash inserted during unwrap)INCLUDE "diagnostics"
      #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 1
      #(hash inserted during unwrap)ELSE_IF 0
      #(hash inserted during unwrap)INCLUDE "visualise_forces" # included in diagnostics, so if diagnostics is on, not required
      #(hash inserted during unwrap)END_IF
   
   
   #NONE_UNKNOWN <p_in> "100.d0"
   #NONE_DERIVED <u_av_calc_species0> "facesum(-<u_f_species0>*<facearea>,region=<inlet>)/facesum(<facearea>,region=<inlet>)"
   #NONE_EQUATION <u_av_equation> "<u_av_species0>-<u_av_calc_species0>"
   #<<transientnavierstokescomment>>VARIABLE <dt_initial> 1.d-5
   VARIABLE <u_av_species0> [m/s] 1.d-2
   VARIABLE <u_av_species1> [m/s] "<u_av_species0>"
   VARIABLE <mu_species0> [Pa.s] 1.d-3
   # Re = u*rho*inletscale/mu
   # Re = 1.d-1*1.d3*1.d-1/1.d-3 = 1.d+4 -> too high
   # Re = 1.d-2*1.d3*1.d-1/1.d-3 = 1.d+3 -> too high
   # Re = 1.d-2*1.d3*1.d-2/1.d-3 = 1.d+2 -> good - steady?
   # Re = 1.d-1*1.d3*1.d-2/1.d-3 = 1.d+3 -> maybe transient?
   
   VARIABLE <inlet phi_species1> 0.1d0
   VARIABLE <rho_species0> 1.d3
   VARIABLE <rho_species1> 1.d3
   VARIABLE <a_species1> 1.d-7
      #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 1
      #(hash inserted during unwrap)IF 
      #(hash inserted during unwrap)VARIABLE <rho_species2> 1400.d0
      #(hash inserted during unwrap)VARIABLE <inlet phi_species2> 0.15d0
      #(hash inserted during unwrap)VARIABLE <a_species2> 1.d-5
      #(hash inserted during unwrap)END_IF
   
   VARIABLE <CFL_initial> 1.d-1
   VARIABLE <CFL_max> 0.5d5
   #VARIABLE <CFL_max> 1.0d0
   VARIABLE <adv_limiter> 0.d0
   VARIABLE <phi_tol> 1.d-3
   #VARIABLE <dt_out> 1.d-3
   #VARIABLE <dt_out> 1.d-5
   VARIABLE <dt_out> 1.d-1
   VARIABLE <t_end> 1.d+1
   #VARIABLE <dt_initial> 
   #GENERAL_OPTIONS timestepout=1
   #GENERAL_OPTIONS timestepout=5
   #GENERAL_OPTIONS timestepmax=5
   #GENERAL_OPTIONS newtstepout=1,newtstepmax=2
   #GENERAL_OPTIONS newtstepmax=40
   
   VARIABLE <u_species0[l=1]> "<u_av_species0>" magnitude=<u_av_species0>
   VARIABLE <u_species1[l=1]> "<u_av_species1>" magnitude=<u_av_species1>
   
   #SOLVER_OPTIONS lambdalimitcautiously=.true.
   #KERNEL_OPTIONS averagestabilitycorrections=.true.
   #KERNEL_OPTIONS gradientstabilitycorrections=.true.
   #INCLUDE_TEMPLATE "general/element_information"
   
   # some output variables
      #(comment created during unwrap): new block = ../../templates/multiphase/multifluid/species_information.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "species_information"
      #(hash inserted during unwrap)MARKDOWN
      #(hash inserted during unwrap)Just some summary information about each species present, such as average, minimum and maximum phi and p
      #(hash inserted during unwrap)END_MARKDOWN
      
      NONE_OUTPUT <u_average_species0[l=1]> 'cellsum(<u_species0[l=1]>*<cellvol>,region=<allcells>)/cellsum(<cellvol>,region=<allcells>)'
      NONE_OUTPUT <u_average_species0[l=2]> 'cellsum(<u_species0[l=2]>*<cellvol>,region=<allcells>)/cellsum(<cellvol>,region=<allcells>)'
      NONE_OUTPUT <phi_average_species0> 'cellsum(<phi_species0>*<cellvol>,region=<allcells>)/cellsum(<cellvol>,region=<allcells>)'
      NONE_OUTPUT <p_average_species0> 'cellsum(<p_species0>*<cellvol>,region=<allcells>)/cellsum(<cellvol>,region=<allcells>)'
      NONE_OUTPUT <phi_domainmin_species0> 'cellmin(<phi_species0>,region=<domain>)'
      NONE_OUTPUT <phi_domainmax_species0> 'cellmax(<phi_species0>,region=<domain>)'
      NONE_OUTPUT <phi_allcellsmin_species0> 'cellmin(<phi_species0>,region=<allcells>)'
      NONE_OUTPUT <phi_allcellsmax_species0> 'cellmax(<phi_species0>,region=<allcells>)'
      NONE_OUTPUT <p_domainmin_species0> 'cellmin(<p_species0>,region=<domain>)'
      NONE_OUTPUT <p_domainmax_species0> 'cellmax(<p_species0>,region=<domain>)'
      NONE_OUTPUT <p_allcellsmin_species0> 'cellmin(<p_species0>,region=<allcells>)'
      NONE_OUTPUT <p_allcellsmax_species0> 'cellmax(<p_species0>,region=<allcells>)'
      NONE_OUTPUT <u_average_species1[l=1]> 'cellsum(<u_species1[l=1]>*<cellvol>,region=<allcells>)/cellsum(<cellvol>,region=<allcells>)'
      NONE_OUTPUT <u_average_species1[l=2]> 'cellsum(<u_species1[l=2]>*<cellvol>,region=<allcells>)/cellsum(<cellvol>,region=<allcells>)'
      NONE_OUTPUT <phi_average_species1> 'cellsum(<phi_species1>*<cellvol>,region=<allcells>)/cellsum(<cellvol>,region=<allcells>)'
      NONE_OUTPUT <p_average_species1> 'cellsum(<p_species1>*<cellvol>,region=<allcells>)/cellsum(<cellvol>,region=<allcells>)'
      NONE_OUTPUT <phi_domainmin_species1> 'cellmin(<phi_species1>,region=<domain>)'
      NONE_OUTPUT <phi_domainmax_species1> 'cellmax(<phi_species1>,region=<domain>)'
      NONE_OUTPUT <phi_allcellsmin_species1> 'cellmin(<phi_species1>,region=<allcells>)'
      NONE_OUTPUT <phi_allcellsmax_species1> 'cellmax(<phi_species1>,region=<allcells>)'
      NONE_OUTPUT <p_domainmin_species1> 'cellmin(<p_species1>,region=<domain>)'
      NONE_OUTPUT <p_domainmax_species1> 'cellmax(<p_species1>,region=<domain>)'
      NONE_OUTPUT <p_allcellsmin_species1> 'cellmin(<p_species1>,region=<allcells>)'
      NONE_OUTPUT <p_allcellsmax_species1> 'cellmax(<p_species1>,region=<allcells>)'
      
   
   # rate of change of unknowns
      #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 1
      #(hash inserted during unwrap)IF 0
      #(hash inserted during unwrap)
      #(hash inserted during unwrap)END_IF
   ####################################################
   
      #(comment created during unwrap): new block = multifluid_filtration.arb: sub_block = 1
      #(hash inserted during unwrap)IF 1
      GENERAL_OPTIONS timesteprewind=3,newtstepmaxiftimesteprewind=10,timesteprewindmax=6
      VARIABLE <dt> timesteprewindmultiplier=0.5d0
      NONE_CONDITION <newtsteprewind> "1.d0-<newtstepconverged>" timesteprewindcondition
      #(hash inserted during unwrap)END_IF
   #GENERAL_OPTIONS notimesteprewind
   GENERAL_OPTIONS newtstepmax=15
   #GENERAL_OPTIONS newtstepout=1
   
   ####################################################
   
   #SOLVER_OPTIONS linearsolver=suitesparse
   #GENERAL_OPTIONS timestepmax=1
   #GENERAL_OPTIONS timestepout=1
   #NONE_CONSTANT <C_{Rhie-Chow}> 1.d-3
   VARIABLE <u_f_vect_species0[l=1]> output
   VARIABLE <u_f_vect_species1[l=1]> output
   VARIABLE <phi_species0[r=1]> output
   VARIABLE <phi_species1[r=1]> output
   #GENERAL_OPTIONS timestepadditional=1
   
   # this combination of options prints out whatever data is contained in the file after setup has occurred
   #GENERAL_OPTIONS timestepstart=0
   #GENERAL_OPTIONS timestepmax=0
   
   #GENERAL_OPTIONS newtstepmax=15,newtstepout=1
   GENERAL_OPTIONS timestepmax=4,timestepout=2
##################################################################################
