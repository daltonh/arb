ReadInputFiles.pm:our @code_blocks; # this will become a stack of recursively called arb code blocks (which could correspond to a new input file), starting with the root_input.arb file created by the arb script that contains INPUT_WORKING links to the arb files called by the user from the arb script
ReadInputFiles.pm:# push the first [0] code block (from the root_input.arb) onto the code_blocks array and prep for reading (open)
ReadInputFiles.pm:  while (@code_blocks) { # we keep forming the buffer and parsing the code until all code blocks are destroyed, noting that new files, block, if statements each create new code_blocks
ReadInputFiles.pm:      print ::DEBUG "++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nINFO: start of code_blocks loop:\n #code_blocks = $#code_blocks:\n solver_code = $solver_code:\n buffer = $buffer:\n buffer_offset = $buffer_offset:\n code_type = $code_type:\n skip = $code_blocks[$#code_blocks]{skip}:\n comments = $comments\n filelinelocator = $filelinelocator\n++++++\n";
ReadInputFiles.pm:      print ::DEBUG "INFO: start of code_blocks loop: solver_code = $solver_code: buffer = $buffer: $filelinelocator\n";
ReadInputFiles.pm:      if ($code_blocks[$#code_blocks]{"skip"} || $code_blocks[$#code_blocks]{"if"} < 0) {
ReadInputFiles.pm:        if ($debug) { print ::DEBUG "  INFO: skipping parsing string code due to skip or if status:\n   skip = $code_blocks[$#code_blocks]{skip}: if = $code_blocks[$#code_blocks]{if}\n"; }
ReadInputFiles.pm:        $code_blocks[$#code_blocks]{"raw_buffer"} = $string_code.$buffer.$code_blocks[$#code_blocks]{"raw_buffer"};
ReadInputFiles.pm:        if ($debug) { print ::DEBUG "  INFO: placing string code into raw_buffer and emptying buffer\n:   raw_buffer = $code_blocks[$#code_blocks]{raw_buffer}\n"; }
ReadInputFiles.pm:#         ( $buffer, $code_blocks[$#code_blocks]{'buffer'} ) = $buffer =~ /(.*\}\})(.*)/;
ReadInputFiles.pm:      if (@code_blocks) {
ReadInputFiles.pm:        print ::DEBUG "------\nINFO: end of code_blocks loop:\n #code_blocks = $#code_blocks:\n solver_code = $solver_code:\n buffer = $buffer:\n buffer_offset = $buffer_offset:\n code_type = $code_type:\n skip = $code_blocks[$#code_blocks]{skip}:\n comments = $comments\n filelinelocator = $filelinelocator\n".
ReadInputFiles.pm:        print ::DEBUG "INFO: code_blocks loop finished\n";
ReadInputFiles.pm:#      ::newtient_simulation, ::transient_simulation, ::asread_variable, ::region, ::simulation_info, code_blocks
ReadInputFiles.pm:  my $file = $code_blocks[$#code_blocks]{"name"}; # and grab filename for messaging purposes
ReadInputFiles.pm:  my $unwrapped_indents = $#code_blocks; # save the number of code blocks to get the correct output statement indentation
ReadInputFiles.pm:  if ($code_blocks[$#code_blocks]{"skip"} && $line =~ /^(END_(SKIP|MARKDOWN))$/i) { print ::DEBUG "INFO: found \U$1\E statement in $file\n"; $code_blocks[$#code_blocks]{"skip"}=0; $unwrapped_ignore = 1; }
ReadInputFiles.pm:  elsif ($code_blocks[$#code_blocks]{"skip"}) { $unwrapped_ignore = 1; }
ReadInputFiles.pm:    print ::DEBUG "INFO: found $ifkeyword statement in $file with condition = $condition: #code_blocks = $#code_blocks: if (status before) = $code_blocks[$#code_blocks]{if}\n";
ReadInputFiles.pm:    my $if_old = $code_blocks[$#code_blocks]{if}; # holds previously active block
ReadInputFiles.pm:            $code_blocks[$#code_blocks]{"if"} = 1 # 1 signifies that we are in a true section within an if block
ReadInputFiles.pm:            $code_blocks[$#code_blocks]{"if"} = -1 # -1 signifies that we are in if block that could still become true at this level
ReadInputFiles.pm:          $code_blocks[$#code_blocks]{"if"} = -2 # -2 signifies that we are in if block that can no longer become true
ReadInputFiles.pm:            $code_blocks[$#code_blocks]{"if"} = 1 # 1 signifies that we are in a true section within an if block
ReadInputFiles.pm:            $code_blocks[$#code_blocks]{"if"} = -1 # -1 signifies that we are in if block that could still become true at this level
ReadInputFiles.pm:          $code_blocks[$#code_blocks]{"if"} = 1 # 1 signifies that we are in a true section within an if block
ReadInputFiles.pm:          $code_blocks[$#code_blocks]{"if"} = -2 # -2 signifies that we are in if block that can no longer become true
ReadInputFiles.pm:    print ::DEBUG "INFO: finishing $ifkeyword statement in $file with: #code_blocks = $#code_blocks: if (status after) = $code_blocks[$#code_blocks]{if}\n";
ReadInputFiles.pm:  elsif ($code_blocks[$#code_blocks]{"if"} < 0) { $unwrapped_ignore = 1; }
ReadInputFiles.pm:  elsif ($line =~ /^(SKIP|MARKDOWN)$/i) { print ::DEBUG "INFO: found \U$1\E statement in $file\n"; $code_blocks[$#code_blocks]{"skip"}=1; $unwrapped_ignore = 1; }
ReadInputFiles.pm:# END statement means to completely stop processing the input files, which is accomplished by destroying all code_blocks
ReadInputFiles.pm:  elsif ($line =~ /^(END)$/i) { print ::DEBUG "INFO: found \U$1\E statement in $file\n"; while (@code_blocks) { pop_code_block(); }; $unwrapped_ignore = 1; }
ReadInputFiles.pm:      if ($#{$code_blocks[$#code_blocks]{"include_path"}} > 0) {
ReadInputFiles.pm:        pop(@{$code_blocks[$#code_blocks]{"include_path"}});
ReadInputFiles.pm:        print ::DEBUG "INFO: an INCLUDE statement is removing (popping) an include_path from the stack, leaving: include_path = $code_blocks[$#code_blocks]{include_path}[0]: $filelinelocator\n";
ReadInputFiles.pm:        syntax_problem("an INCLUDE statement is attempting to remove an include_path from the stack, but there is only the local path left which cannot be removed: include_path = $code_blocks[$#code_blocks]{include_path}[0]","an INCLUDE statement is attempting to remove an include_path from the stack, but there is only the local path left which cannot be removed: include_path = $code_blocks[$#code_blocks]{include_path}[0]: $filelinelocator","warning");
ReadInputFiles.pm:# possible TODO: make include path search also recursive through code_blocks
ReadInputFiles.pm:        for my $search_path ( reverse( @{$code_blocks[$#code_blocks]{"include_path"}} ) ) {
ReadInputFiles.pm:          ($found_name,$found_type) = check_for_arbfile_or_dir($code_blocks[$#code_blocks]{"include_path"}[0].'/'.$new_file);
ReadInputFiles.pm:          ($found_name,$found_type) = check_for_arbfile_or_dir($code_blocks[$#code_blocks]{"include_path"}[$#{$code_blocks[$#code_blocks]{"include_path"}}].'/'.$new_file);
ReadInputFiles.pm:        if ($found_dir ne $code_blocks[$#code_blocks]{"include_path"}[$#{$code_blocks[$#code_blocks]{"include_path"}}]) {
ReadInputFiles.pm:          push(@{$code_blocks[$#code_blocks]{"include_path"}},$found_dir);
ReadInputFiles.pm:          print ::DEBUG "INFO: adding new path $found_dir to the include_path stack, making: include_path = @{$code_blocks[$#code_blocks]{include_path}}\n";
ReadInputFiles.pm:          print ::DEBUG "INFO: not adding new path $found_dir to the include_path stack as it is already on the top of the stack: include_path = @{$code_blocks[$#code_blocks]{include_path}}\n";
ReadInputFiles.pm:        $::asread_variable[$masread]{"absfilename"}=$::asread_variable[$masread]{"absfilename"}." ".$code_blocks[$#code_blocks]{"abs_name"};
ReadInputFiles.pm:        $::asread_variable[$masread]{"absfilename"}=$code_blocks[$#code_blocks]{"abs_name"};
ReadInputFiles.pm:        $::region[$masread]{"absfilename"}=$::region[$masread]{"absfilename"}." ".$code_blocks[$#code_blocks]{"abs_name"};
ReadInputFiles.pm:        $::region[$masread]{"absfilename"}=$code_blocks[$#code_blocks]{"abs_name"};
ReadInputFiles.pm:# converts an rxn file to an arb file using the rxntoarb script (held in $rxntoarb_bin), changing appropriate code_blocks elements
ReadInputFiles.pm:  $code_blocks[$rxn_block]{"abs_rxn_name"} = $code_blocks[$rxn_block]{"abs_name"};
ReadInputFiles.pm:  $code_blocks[$rxn_block]{"rxn_name"} = $code_blocks[$rxn_block]{"name"};
ReadInputFiles.pm:  $code_blocks[$rxn_block]{"abs_name"} =~ s/\.rxn$/.arb/;
ReadInputFiles.pm:  $code_blocks[$rxn_block]{"name"} =~ s/\.rxn$/.arb/;
ReadInputFiles.pm:  $code_blocks[$rxn_block]{"file_type"} = 'rxn';
ReadInputFiles.pm:  print "INFO: attempting to create arb file $code_blocks[$rxn_block]{abs_name} from rxn file $code_blocks[$rxn_block]{abs_rxn_name}\n";
ReadInputFiles.pm:  print ::DEBUG "INFO: attempting to create arb file $code_blocks[$rxn_block]{abs_name} from rxn file $code_blocks[$rxn_block]{abs_rxn_name}\n";
ReadInputFiles.pm:  if (-e $code_blocks[$rxn_block]{"abs_name"}) {
ReadInputFiles.pm:    unlink($code_blocks[$rxn_block]{"abs_name"}) or error_stop("could not remove existing $code_blocks[$rxn_block]{abs_name} when running attempting to run rxntoarb on $code_blocks[$rxn_block]{abs_rxn_name}");  
ReadInputFiles.pm:  my $systemcall="$::rxntoarb_bin -o $code_blocks[$rxn_block]{abs_name} $code_blocks[$rxn_block]{abs_rxn_name}";
ReadInputFiles.pm:  (!(system("$systemcall"))) or error_stop("problem running rxntoarb: file = $code_blocks[$rxn_block]{abs_rxn_name}: systemcall = $systemcall");
ReadInputFiles.pm:# adds a code block to the top of the code_blocks array
ReadInputFiles.pm:    $code_blocks[$#code_blocks+1]{"sub_block"}=0; # sub_block indicates the number of blocks that have been opened (and not closed) since the file was opened
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"name"} = File::Spec->abs2rel($abs_name,$::working_dir); # name is path to the file from the working_dir, useful for messaging and identifying this file
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"abs_name"} = $abs_name; # abs_name is always the absolute path to the file
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"handle"} = FileHandle->new(); # make a new filehandle for the file (taken from http://docstore.mik.ua/orelly/perl/cookbook/ch07_17.htm)
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"line_number"} = 0; # signals line has not yet been read
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"raw_line"} = ''; # signals line has not yet been read
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"file_type"} = 'arb'; # by default new file is assumed to contain arb code
ReadInputFiles.pm:    if ($abs_name =~ /\.rxn$/) { convert_rxn_to_arb_file($#code_blocks); }
ReadInputFiles.pm:    my $handle = $code_blocks[$#code_blocks]{"handle"};
ReadInputFiles.pm:    open($handle, "<$code_blocks[$#code_blocks]{abs_name}") or error_stop("problem opening arb input file $code_blocks[$#code_blocks]{name}");
ReadInputFiles.pm:    if ($#code_blocks < 1) { error_stop("internal problem with push_code_block"); }
ReadInputFiles.pm:    $code_blocks[$#code_blocks+1]{"sub_block"}=0;
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"sub_block"}=$code_blocks[$#code_blocks-1]{"sub_block"}+1;
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"name"}=$code_blocks[$#code_blocks-1]{"name"};
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"abs_name"}=$code_blocks[$#code_blocks-1]{"abs_name"};
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"handle"}=$code_blocks[$#code_blocks-1]{"handle"};
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"line_number"}=$code_blocks[$#code_blocks-1]{"line_number"};
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"raw_line"}=$code_blocks[$#code_blocks-1]{"raw_line"};
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"raw_line"}='';
ReadInputFiles.pm:  if ($#code_blocks) {
ReadInputFiles.pm:      $code_blocks[$#code_blocks]{"include_path"}[0] = $code_blocks[$#code_blocks-1]{"include_path"}[$#{$code_blocks[$#code_blocks-1]{"include_path"}}];
ReadInputFiles.pm:#       $code_blocks[$#code_blocks]{"include_path"}[0] = $code_blocks[$#code_blocks-1]{"include_path"}[$#{$code_blocks[$#code_blocks-1]{"include_path"}}];
ReadInputFiles.pm:        @{$code_blocks[$#code_blocks]{"include_path"}} = @{$code_blocks[$#code_blocks-1]{"include_path"}};
ReadInputFiles.pm:        $code_blocks[$#code_blocks]{"include_path"}[0] = $code_blocks[$#code_blocks-1]{"include_path"}[0];
ReadInputFiles.pm:    $code_blocks[$#code_blocks]{"include_path"}[0] = $::working_dir;
ReadInputFiles.pm:  $code_blocks[$#code_blocks]{"raw_buffer"} = ''; # this will contain any lines read in from file that need to be processed (specifically these are lines that are saved prior to another file being included)
ReadInputFiles.pm:  $code_blocks[$#code_blocks]{"skip"} = 0; # flag to indicate whether we are in a comments section or not
ReadInputFiles.pm:  $code_blocks[$#code_blocks]{"if"} = 0; # flag to indicate whether we are in an if section or not
ReadInputFiles.pm:# print UNWRAPPED_INPUT $unwrapped_indent x $#code_blocks,$unwrapped_created_hash."++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n",
ReadInputFiles.pm:  print UNWRAPPED_INPUT $unwrapped_indent x $#code_blocks,$unwrapped_created_hash.": new block = $code_blocks[$#code_blocks]{name}: sub_block = $code_blocks[$#code_blocks]{sub_block}\n";
ReadInputFiles.pm:  if (empty($::simulation_info{"filename"}) && $#code_blocks) {
ReadInputFiles.pm:    $::simulation_info{"filename"} = $code_blocks[$#code_blocks]{"name"};
ReadInputFiles.pm:    $::simulation_info{"absfilename"} = $code_blocks[$#code_blocks]{"abs_name"};
ReadInputFiles.pm:# removes a code block from the top of the code_blocks array, and closes file if required
ReadInputFiles.pm:# print UNWRAPPED_INPUT $unwrapped_indent x $#code_blocks,$unwrapped_created_hash."--------------------------------------------------------\n";
ReadInputFiles.pm:  if (!($code_blocks[$#code_blocks]{"sub_block"})) {
ReadInputFiles.pm:    my $handle = $code_blocks[$#code_blocks]{"handle"};
ReadInputFiles.pm:    print ::DEBUG "INFO: closing file $code_blocks[$#code_blocks]{name}\n";
ReadInputFiles.pm:  pop(@code_blocks);
ReadInputFiles.pm:  foreach my $n1 ( reverse( 0 .. $#code_blocks ) ) {
ReadInputFiles.pm:#   foreach my $n2 ( 0 .. $#{$code_blocks[$n1]{"string_variables"}} ) {
ReadInputFiles.pm:    foreach my $n2 ( reverse( 0 .. $#{$code_blocks[$n1]{"string_variables"}} ) ) {
ReadInputFiles.pm:      if ($code_blocks[$n1]{"string_variables"}[$n2]{"replace"}) {
ReadInputFiles.pm:        replace_substring($string,$code_blocks[$n1]{"string_variables"}[$n2]{"name"},$code_blocks[$n1]{"string_variables"}[$n2]{"value"});
ReadInputFiles.pm:# gets one file line of arb code from $#code_blocks and places it in $_[0], and return whether the get was successful or not
ReadInputFiles.pm:  if ($code_blocks[$#code_blocks]{"raw_buffer"}) {
ReadInputFiles.pm:    if ($code_blocks[$#code_blocks]{"raw_buffer"} =~ /\n/) {
ReadInputFiles.pm:      $code_blocks[$#code_blocks]{"raw_buffer"} = $';
ReadInputFiles.pm:      $raw_buffer = $code_blocks[$#code_blocks]{"raw_buffer"};
ReadInputFiles.pm:      $code_blocks[$#code_blocks]{"raw_buffer"} = '';
ReadInputFiles.pm:    my $handle = $code_blocks[$#code_blocks]{"handle"};
ReadInputFiles.pm:      $code_blocks[$#code_blocks]{"line_number"} = $.;
ReadInputFiles.pm:      $code_blocks[$#code_blocks]{"raw_line"} = $raw_buffer;
ReadInputFiles.pm:      $code_blocks[$#code_blocks]{"raw_line"} =~ s/\n//g; # remove line feeds too for raw_line
ReadInputFiles.pm:  if ($success) {$filelinelocator = "file = $code_blocks[$#code_blocks]{name}: linenumber = $code_blocks[$#code_blocks]{line_number}: line = \'$code_blocks[$#code_blocks]{raw_line}\': raw_buffer = \'$code_blocks[$#code_blocks]{raw_buffer}\'";}
StringCode.pm:  alias my @code_blocks = @ReadInputFiles::code_blocks;
StringCode.pm:            $code_blocks[$code_block_found]{"string_variables"}[$string_variable_found]{"replace"} = 1;
StringCode.pm:            $code_blocks[$code_block_found]{"string_variables"}[$string_variable_found]{"replace"} = 0;
StringCode.pm:  alias my @code_blocks = @ReadInputFiles::code_blocks;
StringCode.pm:      splice(@{$code_blocks[$code_block_found]{"string_variables"}},$string_variable_found,1);
StringCode.pm:  alias my @code_blocks = @ReadInputFiles::code_blocks;
StringCode.pm:      return split(/,/,$code_blocks[$code_block_found]{"string_variables"}[$string_variable_found]{"value"});
StringCode.pm:      return $code_blocks[$code_block_found]{"string_variables"}[$string_variable_found]{"value"};
StringCode.pm:  alias my @code_blocks = @ReadInputFiles::code_blocks;
StringCode.pm:  if ($code_blocks[$code_block_found]{"string_variables"}[$string_variable_found]{"value"} eq $_[1]) { return '1'; } else { return '0'; }
StringCode.pm:#    - global: set the string in the root code_blocks ($code_blocks[0]) so that it is available even after the current block has closed - ie, globally
StringCode.pm:  alias my @code_blocks = @ReadInputFiles::code_blocks;
StringCode.pm:# see if string already exists, either in all code_blocks, or in code_blocks[0] for global
StringCode.pm:        $code_block_set = $#code_blocks; # otherwise use current block
StringCode.pm:      $string_variable_set = $#{$code_blocks[$code_block_set]{"string_variables"}}+1; # increment index in the relevant block
StringCode.pm:    $code_blocks[$code_block_set]{"string_variables"}[$string_variable_set]{"name"} = shift(@name_value_pairs);
StringCode.pm:    $code_blocks[$code_block_set]{"string_variables"}[$string_variable_set]{"value"} = shift(@name_value_pairs);
StringCode.pm:    $code_blocks[$code_block_set]{"string_variables"}[$string_variable_set]{"replace"} = 1; # default value
StringCode.pm:        $code_blocks[$code_block_set]{"string_variables"}[$string_variable_set]{"replace"} = 0;
StringCode.pm:    } elsif ($code_blocks[$code_block_set]{"string_variables"}[$string_variable_set]{"name"} =~ /^$/) {
StringCode.pm:      $code_blocks[$code_block_set]{"string_variables"}[$string_variable_set]{"replace"} = 0;
StringCode.pm:  print ::DEBUG "INFO: initial string_variables = ".Dumper(@{$ReadInputFiles::code_blocks[0]{"string_variables"}})."\n";
StringCode.pm:#    - local: only in $#code_blocks local block
StringCode.pm:  alias my @code_blocks = @ReadInputFiles::code_blocks;
StringCode.pm:  my ($code_block_lower,$code_block_upper) = (0,$#code_blocks);
StringCode.pm:    $code_block_lower = $#code_blocks;
StringCode.pm:  my $code_block_found = -1; # on output returns -1 if not found, or code_blocks index if found
StringCode.pm:    for my $n ( reverse( 0 .. $#{$code_blocks[$m]{"string_variables"}} ) ) {
StringCode.pm:      if ($name eq $code_blocks[$m]{"string_variables"}[$n]{"name"}) { # found existing general replacements
StringCode.pm:  alias my @code_blocks = @ReadInputFiles::code_blocks;
StringCode.pm:  alias my @code_blocks = @ReadInputFiles::code_blocks;
StringCode.pm:  my ($code_block_lower,$code_block_upper) = (0,$#code_blocks);
StringCode.pm:    $code_block_lower = $#code_blocks;
StringCode.pm:  my $code_block_found = -1; # on output returns -1 if not found, or code_blocks index if found
StringCode.pm:    if ($m eq $#code_blocks) { $debug_output = $debug_output."Local "; }
StringCode.pm:    for my $n ( reverse( 0 .. $#{$code_blocks[$m]{"string_variables"}} ) ) {
StringCode.pm:      $debug_output .= "  String Variable $n: name = $code_blocks[$m]{string_variables}[$n]{name}: value = $code_blocks[$m]{string_variables}[$n]{value}: replace = $code_blocks[$m]{string_variables}[$n]{replace}\n";
