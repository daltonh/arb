#!/bin/bash
#
# file arb
#
# Copyright 2009-2014 Dalton Harvie (daltonh@unimelb.edu.au)
# 
# This file is part of arb finite volume solver, referred to as `arb'.
# 
# arb is a software package designed to solve arbitrary partial
# differential equations on unstructured meshes using the finite volume
# method.  Primarily it consists of fortran source code, perl source
# code and shell scripts.  arb replies on certain third party software
# to run, most notably the computer algebra system maxima
# <http://maxima.sourceforge.net/> which is released under the GNU GPL.
# 
# The copyright of arb is held by Dalton Harvie.
# 
# arb is released under the GNU GPL.  arb is free software: you can
# redistribute it and/or modify it under the terms of the GNU General
# Public License (version 3) as published by the Free Software Foundation.
# You should have received a copy of the GNU General Public Licence
# along with arb (see file licence/gpl.txt after unpacking).  If not,
# see <http://www.gnu.org/licences/>.
# 
# arb is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public Licence
# for more details.
# 
# For full details of arb's licence see the licence directory.
# 
# The current homepage for the arb finite volume solver project is
# <http://people.eng.unimelb.edu.au/daltonh/downloads/arb>.
#
#-------------------------------------------------------------------------
#
# a wrapper script to compile and run arb
# daltonh, 9/10/10 (modified from a much older script though)
#
# possible options:
# -q or --quiet: save screen output of run
# --compile: compile before running
# -c or --continue: continue on from previous run by not deleting output files
# -d or --debug: compile with debug option and run using debugger
# NB: don't -mix options, ie do -q -b rather than -qb
# NB: many more options now - see below
#
# examples:
# ./arb --quiet --no-compile: runs arb without compiling and sends output to output/output.scr
# ./arb --continue : creates fortran, compiles arb, runs arb continuing from previous run
#
# exit status:
# 0: successful
# 1: failed
# 
#-------------------------------------------------------------------------------
# usage function
usage () {
  echo
  echo "HELP/USAGE: ./arb [options] [input_file1.arb [input_file2.arb]]";
  echo
  echo "If no input files are specified on the command line, then any .arb files, and failing that, any .in files,";
  echo "    in the working directory are used";
  echo
  echo "Possible options:";
  echo "  --clean: remove previous meta-programming and object files";
  echo "  --clean-compile: remove previous object files";
  echo "  --clean-setup: remove previous meta-programming files";
  echo "  --setup: perform meta-programming (default)";
  echo "  --no-setup: don't perform meta-programming despite changes to the arb input files";
  echo "              (ie, reuse previous equation_module.f90)";
  echo "  --compile: compile fortran executable (default)";
  echo "  --no-compile: don't compile fortran executable";
  echo "  --run: run the program (default)";
  echo "  --no-run: don't run the program";
  echo "  -q|--quiet: send arb screen output to output/output.scr";
  echo "  -c|--continue: do not delete previous output files (used when continuing on from a previous run)";
  echo "  -d|--debug: compile fortran using debug options and start executable within the specified (or default) debugging environment";
  echo "  --no-debug: do not compile fortran using debug options, only useful to overwrite debug option that is applied when a debugger is specified";
  echo "  --omp: compile fortran using open mp, and use default (maximum) number of processors";
  echo "  --ompN: compile fortran using open mp and specify N processors to use";
  echo "  -pl|-plN|--process-logging|--process-loggingN: log some process including amount of memory being used to output/output_process_log.csv, using an interval of N seconds (defaults to 1s if not specified).  Shows resident set size (see rss in ps manual) in 1024 byte units, and also %mem, cputime and %cpu";
  echo "  --no-process-logging: turn process logging off (default)";
  echo "  --ilp|--long-integer: compile with long integer support (ifort only)";
  echo "  -O|--opt: turn on compiler optimsation level 2";
  echo "  -O0|--no-opt: turn off compiler optimsation";
  echo "  -ON|--optN: turn on compiler optimsation level N";
  echo "  --compiler-gnu: use the gnu gfortran compiler (default if ifort isn't available)";
  echo "  --compiler-intel: use the intel ifort compiler (default if ifort is available)";
  echo "  --debugger|--debugger-default: run within a debugging environment, whichever is the default based on the compiler";
  echo "  --debugger-gnu: use the gnu debugger (default for ifort)";
  echo "  --debugger-intel: use the intel debugger (default for gfortran)";
  echo "  --debugger-valgrind: run within valgrind";
  echo "  --debugger-none: do not run within a debugger environment (relevant for debug runs)";
  echo "          all debugger options turn debug on, but that can be overwritten using the --no-debug option given after";
  echo "  --no-pardiso: do not link in the native pardiso routines, allowing the intel pardiso routines to be used instead";
  echo "  --no-suitesparse: do not download the fortran 90 suitesparse interface or link in the packaged suitesparse routines";
# echo "  --externals|-e: incorporate the following user fortran external file into the equation_module";
  echo "  --help|-h: display this HELP INFO";
  echo;
  exit 1;
}
#-------------------------------------------------------------------------------
# function to log process statistics via pid, with basics of idea taken from http://stackoverflow.com/questions/774556/peak-memory-usage-of-a-linux-unix-process
function logprocess {
  pid=$1; interval=$2; file=$3; mempeak=0; memcurrent=0; walltime=0;
# echo '# "approximate walltime (s)", "peak memory usage (rss, 1024 byte units)", "memory usage (rss, 1024 byte units)", "memory usage (%)", "cputime", "cpu load (%)"' >$PROCESSLOGFILE;
# print out column labels to be consistent with output_step.csv file, allowing existing plotting functions to be used
  echo '"<approximate walltime>","<peak rss memory usage>","<rss memory usage>","<relative memory usage>","<cputime>","<relative cpu load>"' >>$PROCESSLOGFILE;
  echo '"[s]","[1024 byte units]","[1024 byte units]","[%]","[h:m:s]","[%]"' >>$PROCESSLOGFILE;
  echo "0,0,0,0,0,0" >>$PROCESSLOGFILE;
  while true; do
    sleep $interval;
    psstats="$(ps -o rss=,%mem=,cputime=,%cpu= $pid 2> /dev/null)" || break;
    walltime=$(($walltime+$interval)); # arithmetic algebra
    psstatsarray=($psstats); # convert to an array to remove unnecessary spaces and to pull out first element
    memcurrent=${psstatsarray[0]}; # first element will be rss memory
    let mempeak='memcurrent > mempeak ? memcurrent : mempeak'; # find peak memory
    echo "$walltime,$mempeak,${psstatsarray[0]},${psstatsarray[1]},${psstatsarray[2]},${psstatsarray[3]}" >>$PROCESSLOGFILE; # output comman delimited values for css file
  done
  echo "INFO: peak memory usage for arb (rss) was $mempeak";
}
#-------------------------------------------------------------------------------
# main script:

#---------------------------
# default variable setup
# define some commands to avoid path problems
RM='rm -f';
MV='mv';
CP='cp -p';
CAT='cat';
AOUT=build/arb;
DEBUGGER=none;
VALGRIND=valgrind;
FILE_SEPARATOR="##################################################################################"

# location of ooc temp files for out of core intel pardiso solver
MKL_PARDISO_OOC_DIR=tmp/intel_pardiso_ooc
MKL_PARDISO_OOC_PATH=$MKL_PARDISO_OOC_DIR/intel_pardiso_ooc

# environment variables that specify the location of files for the native pardiso solver
PARDISO_LIC_PATH=src/contributed/pardiso
LD_LIBRARY_PATH="$LD_LIBRARY_PATH:src/contributed/pardiso"
DYLD_LIBRARY_PATH="$DYLD_LIBRARY_PATH:src/contributed/pardiso"

# location where previously run output files will be stored
PREVIOUS_RUN=output/previous

# memory log file
PROCESSLOGFILE="output/output_process_log.csv";

# quiet output file
SCROUTPUT="output/output.scr";

# stacksize for OMP runs, not properly tested but probably necessary as recursion grows under ifort
#OMP_STACKSIZE="100000000"; # not sure whether it is KMP or OMP...., so set both to very large numbers
KMP_STACKSIZE="97660k"; # http://wiki.seas.harvard.edu/geos-chem/index.php/Intel_Fortran_Compiler#Resetting_stacksize_for_Linux
ulimit -s 65000; # set stacksize using ulimit, up to apparently hard limit that exists on osx

#---------------------------
# loop through options and set flags to say what has to be done

OCLEAN=0;
OCLEANCOMPILE=0;
OCLEANSETUP=0;
OSETUP=1;
OCOMPILE=1;
ORUN=1;
OQUIET=0;
OCONTINUE=0;
ODEBUG=0;
OOMP=0; # 0 means no omp, 1 means compile with omp support
OOPT=1; # default is optimsation level 1
OILP="off";
OPARDISO="present";
OSUITESPARSE="present";
OPROCESSLOGGING=0; # a value greater than 0 means that process statistics will be logged at this interval (s)
COMPILER="default";
unset ARBFILES; # the input files that will be passed to setup_equations.pl - unset array first
unset EXTERNALS; # a list of external fortran files that will be included in equation_module.f90
EXTERNALS=( `ls src/*_functions.f90 2> /dev/null` ); # all functions files within the src directory get included by default

for i in $*
do
  case $i in
    "-q"|"--quiet") OQUIET=1;; # this is `actioned' below after output directory has been readied for writing
    "--quiet-make") echo "quiet-make option now depreciated, just use quiet instead which now captures make output too";;
    "--clean") OCLEAN=1;;
    "--clean-compile") OCLEANCOMPILE=1;;
    "--clean-setup") OCLEANSETUP=1;;
    "--setup") OSETUP=1;;
    "--no-setup") OSETUP=0;;
    "--compile") OCOMPILE=1;;
    "--no-compile") OCOMPILE=0;;
    "--run") ORUN=1;;
    "--no-run") ORUN=0;;
    "-c"|"--continue") OCONTINUE=1;;
    "-d"|"--debug") ODEBUG=1; DEBUGGER="default";; # ODEBUG specifies whether code is compiled with debugging options (including -g) - valgrind is now considered as a type of debugger
    "--no-debug") ODEBUG=0;;
    "--compiler-gnu") COMPILER="gnu";;
    "--compiler-intel") COMPILER="intel";;
    "--debugger"|"--debugger-default") DEBUGGER="default"; ODEBUG=1;;
    "--debugger-gnu") DEBUGGER="gdb"; ODEBUG=1;;
    "--debugger-intel") DEBUGGER="idb"; ODEBUG=1;;
    "--debugger-valgrind") DEBUGGER=${VALGRIND}; ODEBUG=1;;
    "--debugger-none") DEBUGGER="none"; ODEBUG=1;;
    "--no-pardiso") OPARDISO="not present";;
    "--no-suitesparse") OSUITESPARSE="not present";;
    "--omp") OOMP=1; unset OMP_NUM_THREADS;;
#   "--omp") OOMP=1;;
#   "--omp"*) OOMP=1; export OMP_NUM_THREADS=${i:5};; # this extracts from character position 6 and onwards (NB ${i:6:10} would extract characters 7 -> 10 or thereabouts)
    "--omp"*) OOMP=1; export OMP_NUM_THREADS=${i:5}; export MKL_NUM_THREADS=${i:5};; # this extracts from character position 6 and onwards (NB ${i:6:10} would extract characters 7 -> 10 or thereabouts)
    "-pl"|"--process-logging") OPROCESSLOGGING="1";; # note, this is the interval in seconds (integer only) for logging of process statistics
    "--process-logging"*) OPROCESSLOGGING=${i:16};;
    "-pl"*) OPROCESSLOGGING=${i:3};;
    "--no-process-logging") OPROCESSLOGGING=0;;
    "-O"|"--opt") OOPT=2;; # if requested with no level, optimisation level is 2
    "--ilp"|"--long-integer") OILP="on";;
    "--no-opt") OOPT=0;; # this is optimisation turned off
    "-O"?) OOPT=${i:2};;
    "--opt"?) OOPT=${i:5};;
    "--help"|"-h") usage;;
# TODO - additional external
#   "--externals*".") echo "INFO: found arb input file $i"; ARBFILES[${#ARBFILES[@]}]=$i;;
    "--"*|"-"*) echo "ERROR: unknown option $i passed to arb"; usage;;
    *".arb"|*".in") ARBFILES[${#ARBFILES[@]}]=$i;;
    *) echo "ERROR: unknown command line entry $i"; usage;;
  esac
done ;

#---------------------------
# ready output directory for writing

# create it if it doesn't already exist
if [ ! -d output ] ; then mkdir output ; fi ;
# always keep copy of previous output
if [ ! -d $PREVIOUS_RUN ] ; then mkdir -p $PREVIOUS_RUN ; fi ;
$RM $PREVIOUS_RUN/* >/dev/null 2>/dev/null ;
# delete other output, debug and communication files always, quietly
for i in fort.* output/debug*.msh output/*_warnings.txt output/*_details.txt kill stop stopback stopnewt stoptime halt dump dumpnewt dumptime
do
  $RM $i >/dev/null 2>/dev/null ;
done ;
# place old output and gmsh files in previous_run directory that are needed to restart the run
for i in output/output*.txt output/output*.csv output/output*.scr output/output*.stat output/*.msh output/*.vtk output/*.dat       
do
  if [ $OCONTINUE -eq 0 ] ; then
    $MV $i $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  else
    $CP -R $i $PREVIOUS_RUN/ >/dev/null 2>/dev/null ;
  fi ;
done ;

#---------------------------
# now that output directory is ready for writing redirect stdout and stderr to output.scr
if [ $OQUIET -eq 1 ] ; then
  exec > $SCROUTPUT 2>&1;
fi

# now that quiet option has been dealt with, announce our arrival and list options etc
echo "arb finite volume solver wrapper script, Copyright Dalton Harvie (see licence directory)"
echo
echo "INFO: for usage options, try ./arb --help"
echo "INFO: script run with options: clean=$OCLEAN, clean-setup=$OCLEANSETUP, clean-compile=$OCLEANCOMPILE, setup=$OSETUP, compile=$OCOMPILE, run=$ORUN, quiet=$OQUIET, continue=$OCONTINUE, debug=$ODEBUG, compiler=$COMPILER, debugger=$DEBUGGER, omp=$OOMP, opt=$OOPT, process-logging=$OPROCESSLOGGING";

# check for input files.  If none have been set, then use any *.arb files that exist in the working directory, and failing that, any *.in files
if [ -z "${ARBFILES[0]}" ] ; then ARBFILES=( `ls *.arb 2> /dev/null` ); fi ;
if [ -z "${ARBFILES[0]}" ] ; then ARBFILES=( `ls *.in 2> /dev/null` ); fi ;
echo "INFO: arb input files to be used: ${ARBFILES[@]}" ;
# construct root_input.arb file which consists of include statements to the user's input files, in the order that they are given to this script
$RM build/root_input.arb >/dev/null 2>/dev/null ;
echo "# root_input.arb file created by the arb script" >build/root_input.arb ;
echo $FILE_SEPARATOR >>build/root_input.arb ;
# cycle through each external file including them in the root_input, so that setup_equations can decide whether they are required, and if so, whether they have changed since previously
echo "# the following external fortran files were found by the arb script and are available for inclusion: ${EXTERNALS[@]}" >>build/root_input.arb;
for FILE in "${EXTERNALS[@]}" ; do
  if [ ! -e "$FILE" ] ; then echo "ERROR: the external fortran file $FILE does not exist"; exit 1; fi;
  echo "EXTERNALS \"$FILE\"" >>build/root_input.arb ;
done
echo $FILE_SEPARATOR >>build/root_input.arb ;
echo "# the following working directory files found by the arb script: ${ARBFILES[@]}" >>build/root_input.arb ;
for FILE in "${ARBFILES[@]}" ; do
  if [[ $FILE == *'.in' ]]; then echo "WARNING: the 'in' suffix on arb input files has been depreciated.  For future compatibility replace the suffix on $FILE with 'arb'."; fi
  echo "INCLUDE_WORKING \"$FILE\"" >>build/root_input.arb ;
  echo $FILE_SEPARATOR >>build/root_input.arb ;
done
echo "INFO: the file build/root_input.arb has been created" ;

# create intel pardiso ooc temp directory and clear its contents
if [ ! -d $MKL_PARDISO_OOC_DIR ] ; then mkdir -p $MKL_PARDISO_OOC_DIR ; fi ;
$RM $MKL_PARDISO_OOC_DIR/* >/dev/null 2>/dev/null ;

# export any variables that are required upstream, just in case they haven't been before
# OSTYPE and MACHTYPE are now set directly within make using uname output
export MKL_PARDISO_OOC_PATH
export MKL_HOME
export MKLROOT
export PARDISO_LIC_PATH
export LD_LIBRARY_PATH
export DYLD_LIBRARY_PATH
export OMP_STACKSIZE
export KMP_STACKSIZE
echo "INFO: environment variable DYLD_LIBRARY_PATH = $DYLD_LIBRARY_PATH"
echo "INFO: environment variable OMP_NUM_THREADS = $OMP_NUM_THREADS"

if [ -n "${OMP_NUM_THREADS}" ] ; then echo "INFO: arb running with $OMP_NUM_THREADS omp threads" ; fi ;

# move to build directory
echo "INFO: moving to build directory"
cd build

# do clean operations first
if [ $OCLEAN -eq 1 ] ; then
# do a complete clean if requested
  make compiler=$COMPILER clean;
  if [ "$?" -ne 0 ] ; then
    echo "ERROR: problem cleaning files from the build directory" ;
    cd ..
    exit 1 ;
  fi ;
else
  if [ $OCLEANSETUP -eq 1 ] ; then
    make compiler=$COMPILER clean_setup;
    if [ "$?" -ne 0 ] ; then
      echo "ERROR: problem cleaning setup files from the build directory" ;
      cd ..
      exit 1 ;
    fi ;
  fi ;
  if [ $OCLEANCOMPILE -eq 1 ] ; then
    make compiler=$COMPILER clean_compile;
    if [ "$?" -ne 0 ] ; then
      echo "ERROR: problem cleaning compilation files from the build directory" ;
      cd ..
      exit 1 ;
    fi ;
  fi
fi


# compile if necessary, checking that options used last time are consistent with this time
if [ $OCOMPILE -eq 1 -o $OSETUP -eq 1 ] ; then

  echo "INFO: compiling or setting up the arb executable"

# if compilation is required then need to find compiler
  if [ $OCOMPILE -eq 1 ] ; then
  # try intel compiler first
    if [ $COMPILER = "intel" -o $COMPILER = "default" ] ; then
      if which ifort >/dev/null 2>/dev/null ; then
        echo "INFO: found intel compiler at `which ifort`";
        COMPILER="intel";
  # find version of intel compiler
        INTEL_VERSION=`ifort -v 2>&1`; # this should give us the version as 'ifort version 12.1.2' say - NB, this is output to stderr, so we redirect this to stdout
        INTEL_VERSION=${INTEL_VERSION#ifort version }; # remove shortest string from the front giving '12.1.2'
        INTEL_VERSION=${INTEL_VERSION#Version }; # format for version 11 was slightly different to versions 12 and 13 (thanks intel!)
        INTEL_VERSION=${INTEL_VERSION%%.*}; # remove longest string from the back giving '12' or '11' or '13'
        if [ "${#INTEL_VERSION}" -gt 2 -o "${#INTEL_VERSION}" -lt 1 ] ; then
          echo "INFO: intel compiler version incorrectly identified as |$INTEL_VERSION|";
          echo "INFO: length of intel compiler ${#INTEL_VERSION}";
          echo "WARNING: set the variable intel_version manually in the makefile to be consistent with the output of 'ifort -v'";
          unset INTEL_VERSION
        else
          echo "INFO: intel compiler version identified as $INTEL_VERSION";
        fi
      else
        if [ $COMPILER = "intel" ] ; then
          echo "ERROR: requested intel compiler is not in the path" ;
          cd ..;
          exit 1;
        fi
      fi
    fi
  # try gnu compiler second
    if [ $COMPILER = "gnu" -o $COMPILER = "default" ] ; then
      if which gfortran >/dev/null 2>/dev/null; then
        echo "INFO: found gfortran compiler at `which gfortran`";
        COMPILER="gnu";
      else
        if [ $COMPILER = "gnu" ] ; then
          echo "ERROR: requested gnu compiler is not in the path" ;
          cd ..;
          exit 1;
        fi
      fi
    fi
  # if nothing is found 
    if [ $COMPILER = "default" ] ; then
      echo "ERROR: no compiler is present";
      cd ..;
      exit 1;
    elif [ ! $COMPILER = "intel" -a ! $COMPILER = "gnu" ] ; then
      echo "ERROR: unknown requested compiler $COMPILER";
      cd ..;
      exit 1;
    fi

    if [ ! $COMPILER = "intel" ] ; then
      OILP="off"; # long integers only implemented for ifort right now
    fi

  # check to see what compiler was used last time, and if different, make clean
  # check to see whether debugging was used last time, and if different, make clean
  # check to see whether open mp was used last time, and if different, make clean
    if [ ! -e last_compiler_was_$COMPILER -o ! -e last_compile_had_debugging_$ODEBUG -o ! -e last_compile_had_omp_$OOMP -o ! -e last_compile_had_opt_$OOPT -o ! -e last_compile_had_ilp_$OILP ] ; then
      echo "INFO: cleaning of compilation files required as compile options different from previous run";
      make compiler=$COMPILER clean_compile;
      if [ "$?" -ne 0 ] ; then
        echo "ERROR: problem cleaning compilation files from the build directory due to different compilation options" ;
        cd ..
        exit 1 ;
      fi ;
    fi

  # record options used this time
    touch last_compiler_was_$COMPILER ;
    touch last_compile_had_debugging_$ODEBUG ;
    touch last_compile_had_omp_$OOMP ;
    touch last_compile_had_opt_$OOPT ;
    touch last_compile_had_ilp_$OILP ;

  fi

# assemble makeline and make
  MAKELINE="make opt=$OOPT ilp=$OILP pardiso_from_arb=\"$OPARDISO\" suitesparse_from_arb=\"$OSUITESPARSE\"";
  if [ $OSETUP -eq 0 ] ; then
    MAKELINE="$MAKELINE compile_only" ;
  else
    if which maxima >/dev/null ; then
      echo "INFO: found maxima at `which maxima`";
    else
      echo "ERROR: maxima is not in the path - is it installed?" ;
      cd ..;
      exit 1;
    fi
    if [ $OCOMPILE -eq 0 ] ; then
      MAKELINE="$MAKELINE setup_only" ;
    fi ;
  fi ;
  if [ $ODEBUG -eq 1 ] ; then MAKELINE="$MAKELINE debug=on" ; fi ;
  if [ $OOMP -eq 1 ] ; then MAKELINE="$MAKELINE omp=on" ; fi ; # if omp is greater than 1 then use open mp
  if [ -n "${INTEL_VERSION}" ] ; then MAKELINE="$MAKELINE intel_version=$INTEL_VERSION" ; fi ;

# echo "MAKELINE = $MAKELINE";

  MAKELINE="$MAKELINE compiler=$COMPILER";
  echo "INFO: running make using commands: $MAKELINE"; echo
  eval $MAKELINE;
  echo "INFO: finished running make"; echo

  if [ "$?" -ne 0 ] ; then
    echo "ERROR: problem compiling/settting up arb" ;
    cd ..
    exit 1 ;
  else
    echo "INFO: arb make/setup successful" ;
  fi ;
fi ;

# move back to working directory
echo "INFO: moving back to working directory"
cd ..

# finally run program
if [ $ORUN -eq 1 ] ; then

  echo "INFO: running arb executable"; echo

  if [ ! -e $AOUT ] ; then
    echo "ERROR: arb executable does not exist" ;
    exit 1 ;
  fi

  if [ ! $DEBUGGER = "none" ] ; then # DEBUGGER specifies purely what environment code is to run, and is now strictly separate to ODEBUG
    if [ $DEBUGGER = "default" ]; then
      if [ $COMPILER = "gnu" ] ; then # if DEBUGGER is not explicitly set, set it to be consistent with the compiler
        DEBUGGER="gdb";
      else
        DEBUGGER="idb";
      fi;
    fi
    if which $DEBUGGER >/dev/null ; then
      echo "INFO: found $DEBUGGER at `which $DEBUGGER`";
    else
      echo "ERROR: $DEBUGGER is not in the path - is it installed?" ;
      exit 1;
    fi
    if [ $DEBUGGER = "valgrind" ]; then
      $DEBUGGER $AOUT --track-origins=yes --leak-check=full -v;
    else
      $DEBUGGER $AOUT;
    fi
  else
    if [ $OPROCESSLOGGING -eq 0 ] ; then
      $AOUT; # standard invocation
    else # invocation of job while logging process statistics
      set -m; # need to enable job control within bash to allow backgrounding and foregrounding of arb process
      $AOUT & # initially placing arb in the background, so that we can get pid and use it to start memory logger
      ARBPID=$!; # $! reports pid of the last backgrounded job, in this case the build/arb process
      echo "INFO: arb pid is $ARBPID";
      logprocess $ARBPID $OPROCESSLOGGING $PROCESSLOGFILE &
      fg 1 >/dev/null; # now pull job back into the foreground so that killing the script also kills the subprocess (arb)
      sleep $(($OPROCESSLOGGING+1)); # have to wait for a logging interval after the job has finished so that output.scr is still there when logging command writes to it (batcher may move it immediately when arb script ends)
    fi;
  fi ;
  echo "INFO: finishing running arb";
fi ;

exit 0 ;
# done
#-------------------------------------------------------------------------------
