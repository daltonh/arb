#(comment created during unwrap): new block = resources/test_suite_results/intel/output/build/root_input.arb: sub_block = 0
# root_input.arb file created by the arb script
##################################################################################
# the following external fortran files were found by the arb script and are available for inclusion: /home/daltonh/arb/testsuite/arb_master/src/free_surface_functions.f90
EXTERNALS "/home/daltonh/arb/testsuite/arb_master/src/free_surface_functions.f90"
##################################################################################
# the following working directory files found by the arb script: transient_explicit_stokes_channel_flow_with_cylinder.arb
   #(comment created during unwrap): new block = transient_explicit_stokes_channel_flow_with_cylinder.arb: sub_block = 0
   #(hash inserted during unwrap)INCLUDE_WORKING "transient_explicit_stokes_channel_flow_with_cylinder.arb"
   # arb finite volume solver
   # Copyright 2009,2010 Dalton Harvie (daltonh@unimelb.edu.au)
   #
   # arb is released under the GNU GPL.  For full details see the license directory.
   #
   #-------------------------------------------------------------------
   VERSION 0.55 # the version of syntax used in this file
   
   # the following strings describe the simulation and are passed to the output files
   INFO_TITLE "Transient Stokes flow around an offset cylinder within a channel"
   INFO_DESCRIPTION "Here the transient Stokes equations are solved in 2D, using an unstructured mesh.  A uniform pressure is set along the upstream boundary (which is still very close to the cylinder BTW), which is a bit different to the set flowrate condition used in tutorial_3.  The viscous stress terms are treated explicitly, which means less memory is used, but the timestep is limited.  The convergence tolerance is set lower so that matrix inversion is often avoided, but this comes at a cost of transient accuracy."
   INFO_AUTHOR "Dalton Harvie"
   INFO_DATE "15/1/16" # interpreted as the last modification date
   
   #-------------------------------------------------------------------
   # system constants
   
   #KERNEL_OPTIONS polynomialorder=1,polynomialaverageorder=1 # setting order of kernel function for face derivatives
   #KERNEL_OPTIONS checkminw=.true.,minimumminw=0.5d0 # reducing the minw a bit which will decrease the size of the kernels
   
   #-------------------------------------------------------------------
   # geometry
   
   # CELL_REGION/FACE_REGION specified by: <name> "location string" # comments
   # where location string could be: "at(x1,x2,x3)" for a single point closest to these coordinates
   # where location string could be: "withinbox(x1_min,x2_min,x3_min,x1_max,x2_max,x3_max)" for all elements within a box defined by the minimum and maximum coordinate values
   # where location string could be: "compound(+<a region>-<another region>)" for a + and - compound region list
   # where location string could be: "boundaryof(<a region>)" - boundary faces/cells contained within or surrounding <a region>
   # where location string could be: "domainof(<a region>)" - domain faces/cells contained within <a region>
   # where location string could be: "associatedwith( <a region>)" - faces/cells both contained within and surrounding <a region>
   
   FACE_REGION <walls> "compound(<boundaries>-<inlet>-<outlet>)"
   
   # MSH_FILE instructs arb to read or write a gmsh file (location is read location - write location will always be within the output directory)
   # output options are: output,centringoutput,meshoutput,centringmeshoutput,nooutput
   # input options are: input,centringinput,meshinput,centringmeshinput,noinput
   # data output format options for CELL centred data (which overwrite individual variable options if specified): elementdata,elementnodedata,elementnodelimiteddata
   # vtk file output options are: vtkoutput,centringvtkoutput,meshvtkoutput,centringmeshvtkoutput,novtkoutput (novtkoutput is the default)
   # dat file output options are: datoutput,centringdatoutput,meshdatoutput,centringmeshdatoutput,nodatoutput (nodatoutput is the default)
   MSH_FILE "steady_state_channel_flow_with_cylinder.msh"
   
   #-------------------------------------------------------------------
   # variable definition reference:
   # REGION_LIST <region_1> <region_2> ... <region_n> # comments: line has the ordered names of any regions
   # (CELL_|FACE_)REGION_CONSTANT <name> [multiplier*units] numerical_value_for_region_1 .. value_for_region_n options # comments: sets a constant that varies with region
   # (CELL_|FACE_|NONE_|)CONSTANT <name> [multiplier*units] numerical_value ON <region> options # comments: sets a constant specific to one region or no regions and has the form
   # (CELL_|FACE_|NONE|)CONSTANT <name> [units] "expression (involving only constants)" ON <region> options # comments
   # (CELL_|FACE_|NONE|)TRANSIENT <name> [units] "expression (initial value, optional, evaluated in descending relstep order)" "expression (evaluated in ascending relstep order)" ON <region> options # comments
   # (CELL_|FACE_|NONE|)NEWTIENT <name> [units] "expression (initial value, optional, evaluated in descending relstep order)" "expression (evaluated in ascending relstep order)" ON <region> options # comments
   # (CELL_|FACE_|NONE|)DERIVED <name> [units] "expression" ON <region> options # comments
   # (CELL_|FACE_|NONE|)UNKNOWN <name> [units] "expression (initial value, optional)" ON <region> options # comments
   # (CELL_|FACE_|NONE|)EQUATION <name> [units] "expression (equation equaling zero)" ON <region> options # comments
   # (CELL_|FACE_|NONE|)OUTPUT <name> [units] "expression" ON <region> options # comments
   # (CELL_|FACE_|NONE|)CONDITION <name> [units] "expression" ON <region> options # comments
   # (CELL_|FACE_|NONE|)LOCAL <name> [units] "expression" ON <region> options # comments
   
   # options include (with p=perl and f=fortran indicating which piece of code needs to know the option):
   #p  derivative/noderivative - for DERIVED, EQUATION, LOCAL : do or do not calculate Jacobian derivatives for this variable
   #p  positive/negative/nocheck - for DERIVED, UNKNOWN, EQUATION, LOCAL : check at each iteration that variable is positive/negative
   #f  output/nooutput - for ALL : output compound to msh files
   #f  componentoutput/nocomponentoutput - for ALL : output just this component to msh files
   #f  stepoutput/stepoutputnoupdate/nostepoutput - for ALL : output compound to step file.  The noupdate one does not update the variable when the step file is written (needed for recording when output occurred for example).
   #f  componentstepoutput/componentstepoutputnoupdate/nocomponentstepoutput - for ALL : output just this component to step files
   #f  input/noinput - for CONSTANT, TRANSIENT, UNKNOWN : read in compound from msh files - only these 3 variable types can be read in
   #f  componentinput/nocomponentinput - for CONSTANT, TRANSIENT, UNKNOWN : read in just this component from msh files - only these 3 variable types can be read in
   #f  elementdata,elementnodedata,elementnodelimiteddata - for CELL centred var : data type when writing this compound (unless gmesh overide is specified) (also same for components with prefix component)
   #p  outputcondition,stopcondition,convergencecondition,bellcondition - for CONDITION, type of condition, can have multiple conditions for the one variable
   #f  magnitude=value - for EQUATION, UNKNOWN specifies the initial variable magnitude to be used (rather than being based on the initial variable values) - a negative number will cause the magnitude to be set based upon the initial values (which is the default)
   #f  dynamicmagnitude/staticmagnitude - for EQUATION, UNKNOWN, adjust magnitude of variable dynamically as the simulation progresses, or keep it constant at the initial magnitude
   #f  dynamicmagnitudemultiplier=value - for EQUATION, UNKNOWN, multiplier to use when adjusting magnitude of variable dynamically (=>1.d0, with 1.d0 equivalent to static magnitudes, and large values placing no restriction on the change in magnitude from one newton iteration to the next)
   #   clearoptions - remove all previously (to the left and above the clearoptions word) user-specified options for this variable
   
   # comment out any references to the third dimension in any included files
   
   # variables etc
   
   # use templates from the navier_stokes directory to build up problem
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "navier_stokes" # this is the base directory that will be appended to the following files
      #(comment created during unwrap): new block = ../../templates/navier_stokes/stokes.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "stokes"
      # call this file before constants to specify the stokes equations
      
      #(comment created during unwrap): new block = ../../templates/navier_stokes/constants.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "constants" # specify physical and numerical constants
      # physical data
      CONSTANT <mu> [Pa.s] 1.d-3 # viscosity of liquid
      CONSTANT <rho> [kg/m^3] 1.d0 # density
      CONSTANT <u_av> [m/s] 1.d0 # required average inlet velocity (if used, sets flowrate through inlet)
      
      #-------------
      # set default strings using the following template file, which sets up a steady-state solution to the navier-stokes equations, with uniform viscosity and density
      # see below for appropriate statements to change these decisions
      # strings can also be set when calling the template files using per-file replacements
         #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "default_string_replacements"
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
         #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
         #(hash inserted during unwrap)END_MARKDOWN
         
         
         
         
         
      
      # use the following to setup a transient simulation
      #GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "" R "<<steadystatenavierstokescomment>>" W "#"
      
      # could set the transient status based on what type of arb simulation it is, but inadvisable really
      #<<transientcomment>>GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "" R "<<steadystatenavierstokescomment>>" W "#"
      #<<steadystatecomment>>GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "#" R "<<steadystatenavierstokescomment>>" W ""
      
      # use the following to specify the stokes equations
      #GENERAL_REPLACEMENTS R "<<stokescomment>>" W "" R "<<navierstokescomment>>" W "#"
      
      # use the following to specify nonuniform viscosity
      #GENERAL_REPLACEMENTS R "<<uniformviscositycomment>>" W "#" R "<<nonuniformviscositycomment>>" W ""
      
      # use the following to specify nonuniform density
      #GENERAL_REPLACEMENTS R "<<uniformdensitycomment>>" W "#" R "<<nonuniformdensitycomment>>" W ""
      #-------------
      
      # replace any references to the face centred fluid properties with the constant values if they don't vary
      # get rid of these replacements and define alternative statements for the face centred fluid properties if they do vary
      
      
      
      # numerical data
      CONSTANT <C_{Rhie-Chow}> [] 1.0d+0 # multiplier for Rhie-Chow-type velocity interpolation
      CONSTANT <adv_limiter> [] 1.d0 # multiplier used to limit gradients when calculating advection fluxes
      
      # find an estimate of the domain size using general template
      #(hash inserted during unwrap)INCLUDE_TEMPLATE "general"
         #(comment created during unwrap): new block = ../../templates/general/domain_lengthscale.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "domain_lengthscale" # this will find the none constant <a_lengthscale>
         # find an estimate of the domain size
         # here we use the maximum domain length in each dimension
         # previously used a more accurate but expensive formulation (see minimum_face_boundary_distance)
            #(comment created during unwrap): new block = ../../templates/general/domain_lengths.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "domain_lengths" # this will find a constant vector domain length in each dimension
            # based on node locations, here we calculate the maximum length of the domain in each dimension
            # these loops could be conducted over <boundarynodes>, but although cheaper, this will break if the domain has no boundaries (ie, fully periodic)
            # as this is only a single loop through each node this isn't an expensive calculation anyway (unlike the levelset-based minimum boundary distance)
            NONE_CONSTANT <nodexmax[l=1]> "nodemax(<nodex[l=1]>,region=<allnodes>)"
            NONE_CONSTANT <nodexmax[l=2]> "nodemax(<nodex[l=2]>,region=<allnodes>)"
            #NONE_CONSTANT <nodexmax[l=3]> "nodemax(<nodex[l=3]>,region=<allnodes>)"
            NONE_CONSTANT <nodexmin[l=1]> "nodemin(<nodex[l=1]>,region=<allnodes>)"
            NONE_CONSTANT <nodexmin[l=2]> "nodemin(<nodex[l=2]>,region=<allnodes>)"
            #NONE_CONSTANT <nodexmin[l=3]> "nodemin(<nodex[l=3]>,region=<allnodes>)"
            NONE_CONSTANT <domain_length[l=1]> "<nodexmax[l=1]>-<nodexmin[l=1]>"
            NONE_CONSTANT <domain_length[l=2]> "<nodexmax[l=2]>-<nodexmin[l=2]>"
            #NONE_CONSTANT <domain_length[l=3]> "<nodexmax[l=3]>-<nodexmin[l=3]>"
         # this is based on a vector from the minimum to the maximum coordinates
         #NONE_CONSTANT <a_lengthscale> "sqrt(nonemax(dot(<domain_length[l=:]>,<domain_length[l=:]>),0.d0))"
         # this is based on the maximum domain length over the three dimensions
         NONE_CONSTANT <a_lengthscale> "nonemax(<domain_length[l=1]>,nonemax(<domain_length[l=2]>,<domain_length[l=3]>))"
      
      # for reference calculate some nondimensional quantities
      # these should be overwritten by real nondimensional quantities if this is a nondimensional problem
      CONSTANT <Re> "<u_av>*<rho>*<a_lengthscale>/<mu>" # Reynolds number
      #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_constant_setup.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "transient_constant_setup" # sets up timestep and time variables, and saves previous timestep velocities
      # use this file to initial a transient Navier-Stokes simulation using constant timestepping
      
         #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_all_setup.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "transient_all_setup"
         # setup things needed for transient flow
         # this file works for either dynamic or constant timestepping
         # designed to be called by either transient_constant_setup (linked to transient_setup) or transient_dynamic_setup
         # string replacements default to constant timestepping, or if dynamic timestepping is specified, explicit dynamic timestepping
         # choice should be made by general replacements set from the calling files
         
         # <dt_initial> is used to set the intial timestep during dynamic timestepping or constant timestep otherwise
         
         CONSTANT <t_end> [] 1.d2 # time for simulation to stop
         CONSTANT <celldxave> "cellsum(<celldxmax>,region=<domain>)/cellsum(1.d0,region=<domain>)" # average cell dimension
         CONSTANT <CFL_initial> 1.d-2 # enter a CFL number to set the initial timestep (roughly) - depending on the geometry of cells and non-uniformity of mesh, this may significantly underestimate the actual CFL that results - ie, you may need to choose a smaller number 
         CONSTANT <dt_initial> [] "<CFL_initial>*<celldxave>/<u_av>" # initial timestep based on cell dimension, expecting a velocity of magnitude <u_av>
         CONSTANT <CFL_out> 10.d0 # one way of entering the time between output is based on how many times a cell should be flushed between output, based on the average inlet velocity
         CONSTANT <dt_out> [] "<CFL_out>*<celldxave>/<u_av>" # initial timestep based on cell dimension, expecting a velocity of magnitude <u_av>
         #CONSTANT <dt_out> [] "<t_end>/50.d0" # time between output
         
         # transient bits
         TRANSIENT_SIMULATION
         
         
         # the default is for constant as opposed to dynamic timestepping
         
         
         #---------------------------------------------------------------------------------------------------------
         # dynamic timestepping
         
         # by default there is a explicit newtstep timestep limitation - to remove it reverse the following string replacement
         
         
         # dynamic timestep constants
         #CONSTANT <dt_increase> 1.2d0
         #CONSTANT <dt_decrease> 0.7d0
         #CONSTANT <dt_max> "<dt_initial>*1.d4"
         #CONSTANT <dt_min> "<dt_initial>*1.d-3"
         #CONSTANT <CFL_max> 0.25d0
         #CONSTANT <newtstepdtlimiterlow> 4.d0 # explicitly calculated timestep is only increased if <newtstep[r=1]> is <= than this value
         #CONSTANT <newtstepdtlimiterhigh> 8.d0 # explicitly calculated timestep is decreased if <newtstep[r=1]> is > than this value
         #NONE_TRANSIENT <newtstep[r=1]> "0.d0" "<newtstep>" # we save the previous timestep <newtstep> for the above explicit timestep calculation
         #NONE_TRANSIENT <dt_newtstep_increase[r=1]> "1.d0" "noneif(<newtstep[r=1]>-<newtstepdtlimiterhigh>,<dt_decrease>,noneif(<newtstep[r=1]>-<newtstepdtlimiterlow>,1.d0,<dt_increase>))" # apply this to the previous timestep to keep newtstep roughly between high/low ranges
         ##NONE_LOCAL <dt_newtstep_increase[r=1]> "<dt_increase>" # placeholder for nonnewtsteplimited timestepping
         
         # the default is for explicit timestepping, but implicit can also be enabled by reversing the following strings
         
         
         #NONE_TRANSIENT <dt[r=1]> "<dt_initial>" "<dt>" stepoutput
         #FACE_TRANSIENT <u_f[r=1]> "0.d0" "<u_f>" ON <allfaces> # don't actually need this for implicit timestepping, but it is used in input files for some of the problems for output, so in the interests of not breaking things...
         
         # explicit
         # use CFL_number template, but make the calculation explicit - ie, based on r=1 values
         #INCLUDE "CFL_number" R "<CFL local/dt>" W "<CFL local/dt[r=1]>" R "<u_f>" W "<u_f[r=1]>" R "<CFL local>" W "<CFL local[r=1]>" R "<dt>" W "<dt[r=1]>" R "NONE_OUTPUT <CFL>" W 'NONE_TRANSIENT <CFL[r=1]> ""'
         #<<dynamictimestepcomment>><<explicittimestepcomment>>NONE_TRANSIENT <CFL[r=1]> "" "cellmax(<CFL local[r=1]>,region=<domain>)" output,stepoutput
         #NONE_TRANSIENT <CFL[r=1]> output,stepoutput
         #NONE_TRANSIENT <dt[r=0]> "<dt_initial>" "nonemax(nonemin(nonemin(<dt_newtstep_increase[r=1]>,<CFL_max>/nonemax(<CFL[r=1]>,<tiny>))*<dt[r=1]>,<dt_max>),<dt_min>)" stepoutput,input
         
         # implicit
         # note, a newtstepmax may be applied to <dt_target> within u_f.arb (unfortunately this must be done after <u_f> derived has been calculated, hence, newtstepmax can't be applied here)
         ##INCLUDE "CFL_number"
         ##NONE_UNKNOWN <dt[r=0]> "<dt_initial>" stepoutput,input
         # straight minimum
         # advantage of straight minimum is that provided convergence is achieved the CFL constraint will be rigorously obeyed
         ##NONE_LOCAL <dt_target> "nonemax(nonemin(nonemin(<dt_newtstep_increase[r=1]>*<dt[r=1]>,<CFL_max>/cellmax(<CFL local/dt>,default=<tiny>,region=<domain>)),<dt_max>),<dt_min>)"
         # harmonically averaged, for smoother convergence than the straight minimum which can bounce around
         # disadvantage of the particular harmonic function used is for a factor of two (see below) the dt could be up to twice what the CFL criterion dictates, but using a factor of one can unreasonably decrease timestep below the CFL limit for many timestep combinations
         #<<dynamictimestepcomment>><<implicittimestepcomment>>NONE_LOCAL <dt_explicit_target> "nonemax(nonemin(<dt_newtstep_increase[r=1]>*<dt[r=1]>,<dt_max>),<dt_min>)" stepoutput
         #<<dynamictimestepcomment>><<implicittimestepcomment>>NONE_LOCAL <dt_CFL_target> "nonemax(<CFL_max>/cellmax(<CFL local/dt>,default=<tiny>,region=<domain>),<dt_min>)" stepoutput
         # using two factor here which really doesn't respect dt_increase and CFL_max values correctly, but performs best when both timescales are about the same - ie, more thought required
         #<<dynamictimestepcomment>><<implicittimestepcomment>>NONE_LOCAL <dt_target> "2.d0/(1.d0/<dt_explicit_target>+1.d0/<dt_CFL_target>)" stepoutput
         ##NONE_EQUATION <dt implicit equation> "<dt>-<dt_target>"
         
         #---------------------------------------------------------------------------------------------------------
         # constant timestep, next 1 line
         NONE_CONSTANT <dt> "<dt_initial>"
         #---------------------------------------------------------------------------------------------------------
         
         NONE_TRANSIENT <t[r=0]> "0.d0" "<t[r=1]>+<dt[r=0]>" # time
         NONE_TRANSIENT <t[r=1]> "<t>-<dt[r=0]>" "<t>" # time at last step
         NONE_CONDITION <output test> "<t>-<t_out>-<dt_out>+<dt>*1.d-10" outputcondition # this will be true (>0.) whenever we are <dt_out> from last output
         NONE_OUTPUT <t_out> "<t>" stepoutputnoupdate # this will record the time of the last output
         NONE_CONDITION <stop test> "<t>-<t_end>" stopcondition # when this becomes true (>0.) the simulation stops
         
         # the initial values are blank, which means they will be set equal to the r=0 components, which when updated will mean that they will be set to the initial values for the r=0 components
         CELL_TRANSIENT <u[l=1,r=1]> "" "<u[l=1]>" ON <allcells>
         CELL_TRANSIENT <u[l=2,r=1]> "" "<u[l=2]>" ON <allcells>
         #CELL_TRANSIENT <u[l=3,r=1]> "" "<u[l=3]>" ON <allcells>
         
   
   # the change to get the explicit formulation is to include the appropriate domain template file
      #(comment created during unwrap): new block = ../../templates/navier_stokes/domain_explicit.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "domain_explicit" # equations to be solved within the domain
      # this is the stokes equations equivalent of the domain file
      
      # as <u[l=:]> is now a derived, the initial velocity must be explicitly set for <u[r=1,l=:]>
      VARIABLE <u[r=1,l=1]> "0.d0" ""
      VARIABLE <u[r=1,l=2]> "0.d0" "" 
      #VARIABLE <u[r=1,l=3]> "0.d0" "" 
      
      # include only the pressure variable as an unknown, with the velocity calculated later
         #(comment created during unwrap): new block = ../../templates/navier_stokes/unknowns.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "unknowns"
         # unknown variables used for flow problems
         CELL_UNKNOWN <u[l=1]> [] "0.d0" ON <allcells> magnitude=1.d0 # velocity component
         CELL_UNKNOWN <u[l=2]> [] "0.d0" ON <allcells> magnitude=1.d0 # velocity component
         #CELL_UNKNOWN <u[l=3]> [] "0.d0" ON <allcells> magnitude=1.d0 # velocity component
         CELL_UNKNOWN <p> [] "1.d0" ON <allcells> # pressure
      VARIABLE <u[l=1]> CANCEL # these are now deriveds
      VARIABLE <u[l=2]> CANCEL 
      #VARIABLE <u[l=3]> CANCEL 
      
      # the stress is calculated completely explicitly
         #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "total_stress" 
         
         # total stress tensor
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_gradient_tensor.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "u_gradient_tensor"
            # a tensor of face centred gradients that respects any reflections
            # used in the total stress and boundary conditions now
            # as per conventional tensor notation, the first index is the derivative direction, and the second is the velocity direction
            FACE_TRANSIENT <ugrad_f[r=1,l=1,1]> "facegrad[l=1,](<u[r=1,l=1]>)" ON <allfaces>
            FACE_TRANSIENT <ugrad_f[r=1,l=1,2]> "facegrad[l=1,](<u[r=1,l=2]>)" ON <allfaces>
            #FACE_TRANSIENT <ugrad_f[r=1,l=1,3]> "facegrad[l=1,](<u[r=1,l=3]>)" ON <allfaces>
            FACE_TRANSIENT <ugrad_f[r=1,l=2,1]> "facegrad[l=2,](<u[r=1,l=1]>)" ON <allfaces>
            FACE_TRANSIENT <ugrad_f[r=1,l=2,2]> "facegrad[l=2,](<u[r=1,l=2]>)" ON <allfaces>
            #FACE_TRANSIENT <ugrad_f[r=1,l=2,3]> "facegrad[l=2,](<u[r=1,l=3]>)" ON <allfaces>
            #FACE_TRANSIENT <ugrad_f[r=1,l=3,1]> "facegrad[l=3,](<u[r=1,l=1]>)" ON <allfaces>
            #FACE_TRANSIENT <ugrad_f[r=1,l=3,2]> "facegrad[l=3,](<u[r=1,l=2]>)" ON <allfaces>
            #               FACE_TRANSIENT <ugrad_f[r=1,l=3,3]> "facegrad[l=3,](<u[r=1,l=3]>)" ON <allfaces>
         
         # if the numerical velocity divergence is to be included in the stress calculation replace this string with an empty character prior to calling this template
         
         # calculate the velocity divergence (numerical) on each face
         #FACE_TRANSIENT <udiv_f> "<ugrad_f[r=1,l=1,1]>+<ugrad_f[r=1,l=2,2]>+<ugrad_f[r=1,l=3,3]>" ON <allfaces>
         
         # no both cartesian and cylindrical stresses don't include pressure
         # without the numerical velocity divergence
         FACE_LOCAL <tau[r=1,l=1,1]> "-<mu>*2.d0*<ugrad_f[r=1,l=1,1]>" ON <allfaces>
         FACE_LOCAL <tau[r=1,l=2,2]> "-<mu>*2.d0*<ugrad_f[r=1,l=2,2]>" ON <allfaces>
         #FACE_LOCAL <tau[r=1,l=3,3]> "-<mu>*2.d0*<ugrad_f[r=1,l=3,3]>" ON <allfaces>
         # overwrite theses if the numerical velocity divergence is to be included, see <<udivfcomment>> string replacement above
         # Note: "<udiv_f>/3.d0" is specifically replaced in strain_rate_magnitude template
         #FACE_LOCAL <tau[r=1,l=1,1]> "-<mu>*2.d0*(<ugrad_f[r=1,l=1,1]>-<udiv_f>/3.d0)" ON <allfaces>
         #FACE_LOCAL <tau[r=1,l=2,2]> "-<mu>*2.d0*(<ugrad_f[r=1,l=2,2]>-<udiv_f>/3.d0)" ON <allfaces>
         ##FACE_LOCAL <tau[r=1,l=3,3]> "-<mu>*2.d0*(<ugrad_f[r=1,l=3,3]>-<udiv_f>/3.d0)" ON <allfaces>
         FACE_LOCAL <tau[r=1,l=1,2]> "-<mu>*(<ugrad_f[r=1,l=1,2]>+<ugrad_f[r=1,l=2,1]>)" ON <allfaces>
         #FACE_LOCAL <tau[r=1,l=1,3]> "-<mu>*(<ugrad_f[r=1,l=1,3]>+<ugrad_f[r=1,l=3,1]>)" ON <allfaces>
         #FACE_LOCAL <tau[r=1,l=2,3]> "-<mu>*(<ugrad_f[r=1,l=2,3]>+<ugrad_f[r=1,l=3,2]>)" ON <allfaces>
         FACE_LOCAL <tau[r=1,l=2,1]> "<tau[r=1,l=1,2]>" ON <allfaces>
         #FACE_LOCAL <tau[r=1,l=3,1]> "<tau[r=1,l=1,3]>" ON <allfaces>
         #FACE_LOCAL <tau[r=1,l=3,2]> "<tau[r=1,l=2,3]>" ON <allfaces>
      # the last fancy replacement targets setting just the initial values of the velocity gradient to zero - actually not necessary or a good idea if initial velocity field is nonzero
      #INCLUDE "total_stress" R "<u[l" W "<u[r=1,l" R "DERIVED" W "TRANSIENT" R "<ugrad_f[l" W "<ugrad_f[r=1,l" R "<tau[" W "<tau[r=1," R ']> "facegrad' W ']> "0.d0" "facegrad'
      
      # calculate p_error and dynamic_forces
         #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "p_error"
         # a Rhie-Chow-type velocity interpolation is applied to the face flux velocities
         # pressure gradient calculated via a divergence (consistent with momentum conservation) (on boundary cells values from the adjacent domain cells will be used)
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "dynamic_force" # cell centred dynamic force
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)dynamic force is the pressure force that could cause fluid movement
            #(hash inserted during unwrap)it is added directly to the momentum equations, and used in calculating p_error used in the face velocity interpolation
            #(hash inserted during unwrap)dynamic force now has the physically correct sign!
            #(hash inserted during unwrap)<dynamic_force_f> is calculated within <p_error>, which this file is called from
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Other dynamic_force templates (eg, vof, electrokinetics) increment <dynamic_force_c[l=:]> set in this file, as well as <dynamic_force_f>
            #(hash inserted during unwrap)END_MARKDOWN
            
            #FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "p_f"
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)Here we average the cell centred pressure <p> to the faces producing <p_f>.  The standard method is to use arithmetic averaging, as in
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)```arb
               #(hash inserted during unwrap)FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
               #(hash inserted during unwrap)```
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)Low order averaging adjacentcell averaging use a distance weighted average of the adjacent cell values.  Select this by setting
               #(hash inserted during unwrap)```arb
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)```
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)High order adjacentcell averaging is as per low order adjacentcell averaging, except that the gradient within each cell is used to get a better estimate of the pressure on each side of the interface.  The amount of gradient used is set by `<p_f_grad_limiter>` which should be between 0.d0 (low order) and 1.d0 after the file is included.  To use this high order averaging set
               #(hash inserted during unwrap)```arb
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter> 1.d0 # keep this between 0.d0 and 1.d0
               #(hash inserted during unwrap)```
               #(hash inserted during unwrap)END_MARKDOWN
               
               # this is the default pressure interpolation
               FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
               
               # the following are based on averaging from the adjacentcells only, but possibly using high order averaging
               
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 0
                  #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcells](<p>)" output
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 0
                  #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter> 1.d0 # ranging from 1.d0 (highest order) to 0.d0 which will give same as <<pfadjacentcells>> above
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                     #(hash inserted during unwrap)IF 1
                     #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcells](cellave[lastface](faceave[advection](<p>,<facefromcelldirection>,<p_f_gradient_limiter>)))" output
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                     #(hash inserted during unwrap)ELSE_IF 0
                     #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcellsevenweighting](cellave[lastface](faceave[advection](<p>,<facefromcelldirection>,<p_f_gradient_limiter>)))" output
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)VARIABLE <p_f> "0.5d0*(faceave[advection](<p>,1.d0,<p_f_gradient_limiter>)+faceave[advection](<p>,-1.d0,<p_f_gradient_limiter>))" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 3
                        #(hash inserted during unwrap)IF 1
                        #(hash inserted during unwrap)VARIABLE <p_f> "faceif(facedelta(<boundaries>),<p>,<p_f>)" # special case boundary face pressure value to be equal to boundary cell value.  Without this the boundary pressure will be equally weighted.
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)END_IF
            CELL_DERIVED <dynamic_force_c[l=1]> "-celldivgrad[l=1](<p_f>)" ON <allcells>
            CELL_DERIVED <dynamic_force_c[l=2]> "-celldivgrad[l=2](<p_f>)" ON <allcells>
            #CELL_DERIVED <dynamic_force_c[l=3]> "-celldivgrad[l=3](<p_f>)" ON <allcells>
         
         # seems that using <dynamic_force_c_f[l=:]> usually consumes more memory and takes more time to compute, so remove it by default by including the following
         # in the far off future if nobody complains <dynamic_force_c_f[l=:]> may just disappear into the night
         # to bring back <dynamic_force_c_f[l=:]> set this string to empty using a general replacement or on calling
         # nodynamicforcecf should work with reflections, but not tested like heaps and heaps and heaps yet
         
         # set the opposite automatically
         
         #GENERAL_REPLACEMENTS R "" W "#"
         
         # for evaluating the face centred dynamic force there are three options: dxunit, facegrad and adjacentcells
         # uncomment the comment string corresponding to the one you want
         # default is dxunit
         # remember to set all of these strings on entry if changing from the default, with only the requested one uncommented
         
         
         # calculate <dynamic_force_c_f[l=:]> if requested
         # interpolation to face centres (for velocity correction) could be done using normal, adjacentcells or adjacentcellsevenweighting, but they're all about the same so choose the computationally simplest
         #FACE_LOCAL <dynamic_force_c_f[l=1]> "faceave[,adjacentcells](<dynamic_force_c[l=1]>)"
         #FACE_LOCAL <dynamic_force_c_f[l=2]> "faceave[,adjacentcells](<dynamic_force_c[l=2]>)"
         ##FACE_LOCAL <dynamic_force_c_f[l=3]> "faceave[,adjacentcells](<dynamic_force_c[l=3]>)"
         
         # dxunit method
         FACE_LOCAL <dynamic_force_f> "-facegrad[dxunit](<p>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
         FACE_CONSTANT <dot_facenorm_facedxunit> "dot(<facenorm[l=:]>,<facedxunit[l=:]>)" ON <domainfaces>
         # dxunit + dynamicforcecf
         #FACE_DERIVED <p_error> "(-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facedxunit[l=:]>))*<dot_facenorm_facedxunit>" ON <domainfaces>
         # dxunit - dynamicforcecf
         # lastfacenoglue is required when averaging the normal when we have periodic gluing, as we require the normal to be orientated relative to the original face, rather than its glued counterpart
         # for reflect gluing, <p_error> is zero anyway
         FACE_DERIVED <p_error> "faceif(<facereflectnorm>,(-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastfacenoglue](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <domainfaces>
         
         # facegrad method
         #FACE_LOCAL <dynamic_force_f> "-facegrad(<p>)" ON <allfaces>
         # facegrad + dynamicforcecf
         ##FACE_DERIVED <p_error> "-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facenorm[l=:]>)" ON <domainfaces>
         # facegrad - dynamicforcecf
         #FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastfacenoglue](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
         
         # adjacentcells method
         #FACE_LOCAL <dynamic_force_f> "-facegrad[adjacentcells](<p>)" ON <allfaces>
         # adjacentcells + dynamicforcecf
         ##FACE_DERIVED <p_error> "-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facenorm[l=:]>)" ON <domainfaces>
         # adjacentcells - dynamicforcecf
         #FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastfacenoglue](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
         
         # the following are two template lines for setting the strings prior to entering this file
         #GENERAL_REPLACEMENTS R "<<dynamicforcecfcomment>>" W "#"
         #GENERAL_REPLACEMENTS R "<<dynamicforcefdxunitcomment>>" W "#" R "<<dynamicforceffacegradcomment>>" W "#" R "<<dynamicforcefadjacentcellscomment>>" W "#"
         
      
      # calculate the momentum fluxes as transients
      # TODO: this file will be able to also handle the navier-stokes equations once an explicit <u_f> is saved
      #ERROR "the template file domain_explicit cannot handle the navier-stokes equations yet"
      #INCLUDE "advection_flux"
         #(comment created during unwrap): new block = ../../templates/navier_stokes/momentum_flux.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "momentum_flux" 
         
         # flux of momentum over and in the direction of each face
         
         # check default strings are set
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            
            
         
         # start by placing in viscous momentum transport, applicable to both the stokes and navier-stokes equations
         FACE_TRANSIENT <J_f[r=1,l=1]> "dot(<facenorm[l=:]>,<tau[r=1,l=:,1]>)" ON <allfaces>
         FACE_TRANSIENT <J_f[r=1,l=2]> "dot(<facenorm[l=:]>,<tau[r=1,l=:,2]>)" ON <allfaces>
         #FACE_TRANSIENT <J_f[r=1,l=3]> "dot(<facenorm[l=:]>,<tau[r=1,l=:,3]>)" ON <allfaces>
         
         # and now add advection momentum transport for just the navier-stokes equations using self-referencing
         #VARIABLE <J_f[r=1,l=1]> "<J_f[r=1,l=1]>+<J_advection_f[l=1]>"
         #VARIABLE <J_f[r=1,l=2]> "<J_f[r=1,l=2]>+<J_advection_f[l=2]>"
         ##VARIABLE <J_f[r=1,l=3]> "<J_f[r=1,l=3]>+<J_advection_f[l=3]>"
      
      # this is an explicit update of the velocity
      CELL_LOCAL <u_explicit[l=1]> "<u[r=1,l=1]>-(<dt>/<rho>)*(celldiv(<J_f[r=1,l=1]>)-<dynamic_force_c[l=1]>)" ON <domain>
      CELL_LOCAL <u_explicit[l=2]> "<u[r=1,l=2]>-(<dt>/<rho>)*(celldiv(<J_f[r=1,l=2]>)-<dynamic_force_c[l=2]>)" ON <domain>
      #CELL_LOCAL <u_explicit[l=3]> "<u[r=1,l=3]>-(<dt>/<rho>)*(celldiv(<J_f[r=1,l=3]>)-<dynamic_force_c[l=3]>)" ON <domain>
      
      # within the domain, update the velocity explicitly
      # on the walls, set the velocity to zero
      # at any remaining boundaries, set the velocity to be that of the neighbouring domain cell
      CELL_DERIVED <u[l=1]> "cellif(celldelta(<domain>),<u_explicit[l=1]>,cellif(facedelta(<walls>),0.d0,cellave(faceave[downcell](<u_explicit[l=1]>))))" ON <allcells>
      CELL_DERIVED <u[l=2]> "cellif(celldelta(<domain>),<u_explicit[l=2]>,cellif(facedelta(<walls>),0.d0,cellave(faceave[downcell](<u_explicit[l=2]>))))" ON <allcells>
      #CELL_DERIVED <u[l=3]> "cellif(celldelta(<domain>),<u_explicit[l=3]>,cellif(facedelta(<walls>),0.d0,cellave(faceave[downcell](<u_explicit[l=3]>))))" ON <allcells>
      
      # now just use previous file to calculate interpolated face centred velocity fluxes
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "u_f"
         # interpolate the cell centred velocity to the faces and find the velocity (flux) normal to the face (<u_f>), using a rhie-chow spirited interpolation technique on the domain faces
         
         # check default strings are set
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            
            
         
         # start by calculating the difference between the local face centred (dynamic) pressure gradient and average of cell centred (dynamic) pressure gradients in the face direction
         # `dynamic' pressure here means the pressure that is able to cause fluid flow, ie, possibly accounting for hydrostatic pressure variations (for example)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "p_error"
            # a Rhie-Chow-type velocity interpolation is applied to the face flux velocities
            # pressure gradient calculated via a divergence (consistent with momentum conservation) (on boundary cells values from the adjacent domain cells will be used)
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "dynamic_force" # cell centred dynamic force
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)dynamic force is the pressure force that could cause fluid movement
               #(hash inserted during unwrap)it is added directly to the momentum equations, and used in calculating p_error used in the face velocity interpolation
               #(hash inserted during unwrap)dynamic force now has the physically correct sign!
               #(hash inserted during unwrap)<dynamic_force_f> is calculated within <p_error>, which this file is called from
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)Other dynamic_force templates (eg, vof, electrokinetics) increment <dynamic_force_c[l=:]> set in this file, as well as <dynamic_force_f>
               #(hash inserted during unwrap)END_MARKDOWN
               
               #FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "p_f"
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Here we average the cell centred pressure <p> to the faces producing <p_f>.  The standard method is to use arithmetic averaging, as in
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)Low order averaging adjacentcell averaging use a distance weighted average of the adjacent cell values.  Select this by setting
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)High order adjacentcell averaging is as per low order adjacentcell averaging, except that the gradient within each cell is used to get a better estimate of the pressure on each side of the interface.  The amount of gradient used is set by `<p_f_grad_limiter>` which should be between 0.d0 (low order) and 1.d0 after the file is included.  To use this high order averaging set
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter> 1.d0 # keep this between 0.d0 and 1.d0
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # this is the default pressure interpolation
                  FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
                  
                  # the following are based on averaging from the adjacentcells only, but possibly using high order averaging
                  
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcells](<p>)" output
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 0
                     #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter> 1.d0 # ranging from 1.d0 (highest order) to 0.d0 which will give same as <<pfadjacentcells>> above
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 1
                        #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcells](cellave[lastface](faceave[advection](<p>,<facefromcelldirection>,<p_f_gradient_limiter>)))" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE_IF 0
                        #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcellsevenweighting](cellave[lastface](faceave[advection](<p>,<facefromcelldirection>,<p_f_gradient_limiter>)))" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)VARIABLE <p_f> "0.5d0*(faceave[advection](<p>,1.d0,<p_f_gradient_limiter>)+faceave[advection](<p>,-1.d0,<p_f_gradient_limiter>))" output
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 1
                           #(hash inserted during unwrap)VARIABLE <p_f> "faceif(facedelta(<boundaries>),<p>,<p_f>)" # special case boundary face pressure value to be equal to boundary cell value.  Without this the boundary pressure will be equally weighted.
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)END_IF
               CELL_DERIVED <dynamic_force_c[l=1]> "-celldivgrad[l=1](<p_f>)" ON <allcells>
               CELL_DERIVED <dynamic_force_c[l=2]> "-celldivgrad[l=2](<p_f>)" ON <allcells>
               #CELL_DERIVED <dynamic_force_c[l=3]> "-celldivgrad[l=3](<p_f>)" ON <allcells>
            
            # seems that using <dynamic_force_c_f[l=:]> usually consumes more memory and takes more time to compute, so remove it by default by including the following
            # in the far off future if nobody complains <dynamic_force_c_f[l=:]> may just disappear into the night
            # to bring back <dynamic_force_c_f[l=:]> set this string to empty using a general replacement or on calling
            # nodynamicforcecf should work with reflections, but not tested like heaps and heaps and heaps yet
            
            # set the opposite automatically
            
            #GENERAL_REPLACEMENTS R "" W "#"
            
            # for evaluating the face centred dynamic force there are three options: dxunit, facegrad and adjacentcells
            # uncomment the comment string corresponding to the one you want
            # default is dxunit
            # remember to set all of these strings on entry if changing from the default, with only the requested one uncommented
            
            
            # calculate <dynamic_force_c_f[l=:]> if requested
            # interpolation to face centres (for velocity correction) could be done using normal, adjacentcells or adjacentcellsevenweighting, but they're all about the same so choose the computationally simplest
            #FACE_LOCAL <dynamic_force_c_f[l=1]> "faceave[,adjacentcells](<dynamic_force_c[l=1]>)"
            #FACE_LOCAL <dynamic_force_c_f[l=2]> "faceave[,adjacentcells](<dynamic_force_c[l=2]>)"
            ##FACE_LOCAL <dynamic_force_c_f[l=3]> "faceave[,adjacentcells](<dynamic_force_c[l=3]>)"
            
            # dxunit method
            FACE_LOCAL <dynamic_force_f> "-facegrad[dxunit](<p>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
            FACE_CONSTANT <dot_facenorm_facedxunit> "dot(<facenorm[l=:]>,<facedxunit[l=:]>)" ON <domainfaces>
            # dxunit + dynamicforcecf
            #FACE_DERIVED <p_error> "(-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facedxunit[l=:]>))*<dot_facenorm_facedxunit>" ON <domainfaces>
            # dxunit - dynamicforcecf
            # lastfacenoglue is required when averaging the normal when we have periodic gluing, as we require the normal to be orientated relative to the original face, rather than its glued counterpart
            # for reflect gluing, <p_error> is zero anyway
            FACE_DERIVED <p_error> "faceif(<facereflectnorm>,(-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastfacenoglue](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <domainfaces>
            
            # facegrad method
            #FACE_LOCAL <dynamic_force_f> "-facegrad(<p>)" ON <allfaces>
            # facegrad + dynamicforcecf
            ##FACE_DERIVED <p_error> "-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facenorm[l=:]>)" ON <domainfaces>
            # facegrad - dynamicforcecf
            #FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastfacenoglue](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
            
            # adjacentcells method
            #FACE_LOCAL <dynamic_force_f> "-facegrad[adjacentcells](<p>)" ON <allfaces>
            # adjacentcells + dynamicforcecf
            ##FACE_DERIVED <p_error> "-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facenorm[l=:]>)" ON <domainfaces>
            # adjacentcells - dynamicforcecf
            #FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastfacenoglue](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
            
            # the following are two template lines for setting the strings prior to entering this file
            #GENERAL_REPLACEMENTS R "<<dynamicforcecfcomment>>" W "#"
            #GENERAL_REPLACEMENTS R "<<dynamicforcefdxunitcomment>>" W "#" R "<<dynamicforceffacegradcomment>>" W "#" R "<<dynamicforcefadjacentcellscomment>>" W "#"
            
         
         FACE_LOCAL <u_f_vect[l=1]> "faceave[](<u[l=1]>)"
         FACE_LOCAL <u_f_vect[l=2]> "faceave[](<u[l=2]>)"
         #FACE_LOCAL <u_f_vect[l=3]> "faceave[](<u[l=3]>)"
         FACE_DERIVED <u_f_{raw}> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" ON <allfaces> # volume (velocity) transport
         
         # this file now does both steady-state and transient using transient comments string replacements, which are set in constants.arb
         
         # save old correction velocity for transient calculations
         FACE_TRANSIENT <u_f_{correction}[r=1]> "0.d0" "<u_f_{correction}>" ON <domainfaces>
         
         # assemble <u_f_{correction}>, taking advantage of variable reuse so that only one expression is formed for <u_f_{correction}> (to maximise code efficiency and maxima expression simplifications)
         
         # first assemble demoninator of expression:
         
         # all equation variants here have viscous contribution, so add this first
         # the rf stands for reciprocal and face centred
         FACE_LOCAL <u_rf_{vis}> "<mu>/<facedx>^2" ON <domainfaces>
         FACE_DERIVED <u_f_{correction}> "<u_rf_{vis}>" ON <domainfaces>
         
         # advective contribution can be either simple or more complex (set by <<ufadvectioncomplexcomment>>)
         # the default behaviour is to use the simple advective contribution
         
         # include the following line in your input file prior to loading this template file to access the more complex contribution
         #GENERAL_REPLACEMENTS R <<ufadvectioncomplexcomment>> W ""
         
         # form opposite string to be consistent with <<ufadvectioncomplexcomment>> 
         
         #GENERAL_REPLACEMENTS R  W "#" 
         # next add simple advective contribution (which really assumes that locally |<u_f_{raw}>| >> |<u_f_{correction}>|
         #FACE_LOCAL <u_rf_{adv}> "2.d0*<rho>*abs(<u_f_{raw}>)/<facedx>" ON <domainfaces>
         # or more complex variant, which does not assume generally small correction velocities (and under steady-state conditions is equivalent to what was used pre v0.55) but is more expensive to compute, for what seems like little practical gain.  There is some evidence that the more complex variant can allow steady-state sims to converge more as Re increases, but very very marginal.
         ##FACE_LOCAL <eps_p> "facemax(abs(<p_error>),<tinyish>)" ON <domainfaces>
         ##FACE_LOCAL <u_rf_{adv}> "<eps_p>/(-abs(<u_f_{raw}>)+sqrt(<u_f_{raw}>^2+<eps_p>*<facedx>/<rho>))" ON <domainfaces>
         
         #FACE_DERIVED <u_f_{correction}> "<u_f_{correction}>+<u_rf_{adv}>"
         
         # for transient, add transient component to demoninator, take reciprocal, and add top transient and pressure contributions
         FACE_LOCAL <u_rf_{transient}> "<rho>/<dt>" ON <domainfaces>
         FACE_DERIVED <u_f_{correction}> "(-<C_{Rhie-Chow}>*<p_error>+<u_rf_{transient}>*<u_f_{correction}[r=1]>)/(<u_f_{correction}>+<u_rf_{transient}>)"
         # for steady-state just take reciprocal and add pressure contribution
         #FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<p_error>/(<u_f_{correction}>)"
         
         # final face velocity
         FACE_DERIVED <u_f> "<u_f_{raw}>+faceif(facedelta(<domainfaces>),<u_f_{correction}>,0.d0)" ON <allfaces> # volume (velocity) transport
         
         # this section just re-works the implicit timestepping equation to allow a newtstepmax to be applied to <dt_target>
         # save a derived copy of <dt_target> after <u_f> has been calculated so that we can apply newtstepmax to it
         # if <<implicittimestepcomment>> hasn't already been set then set it here (to off) - for on will have already required dynamic timestepping to be on
         
         #NONE_DERIVED <dt_target_derived> "<dt_target>" newtstepmax=10
         #NONE_EQUATION <dt implicit equation> "<dt>-<dt_target_derived>"
      
      # previous idea based on simpler transient timestep that 
      # # there are too many changes to u_f to warrant inclusion, so just bring in the following
      # <<dim1comment>>FACE_LOCAL <u_f_vect[l=1]> "faceave[<<reflect=1>>](<u[l=1]>)"
      # <<dim2comment>>FACE_LOCAL <u_f_vect[l=2]> "faceave[<<reflect=2>>](<u[l=2]>)"
      # <<dim3comment>>FACE_LOCAL <u_f_vect[l=3]> "faceave[<<reflect=3>>](<u[l=3]>)"
      # FACE_LOCAL <u_f_{raw}> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" ON <allfaces> # volume (velocity) transport
      
      # # note that as <dt> is limited by the explicit timestep constraint anyway, this condition also ensures that the correction velocity scales with the viscous term
      # FACE_LOCAL <u_f_{correction}> "-<C_{Rhie-Chow}>*<dt>*<p_error>/<rho>" ON <domainfaces>
      # CONSTANT <C_{Rhie-Chow}> 5.d0 # increase this for the explicit method from 1.d0
      # # final face velocity
      # FACE_DERIVED <u_f> "<u_f_{raw}>+faceif(facedelta(<domainfaces>),<u_f_{correction}>,0.d0)" ON <allfaces> # volume (velocity) transport
      
      # include just the continuity equation
         #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "conservation"
         # conservation equations solved over each domain cell (finite volume method)
         
         # check default strings are set
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            
            
         
         # cartesian specific
         CELL_EQUATION <continuity> "celldiv(<u_f>)" ON <domain> # continuity
         CELL_EQUATION <momentum[l=1]> "celldiv(<J_f[l=1]>)-<dynamic_force_c[l=1]>" ON <domain> # momentum component
         CELL_EQUATION <momentum[l=2]> "celldiv(<J_f[l=2]>)-<dynamic_force_c[l=2]>" ON <domain> # momentum component
         #CELL_EQUATION <momentum[l=3]> "celldiv(<J_f[l=3]>)-<dynamic_force_c[l=3]>" ON <domain> # momentum component
         
         # cylindrical specific
         #CELL_EQUATION <continuity> "celldiv(1.d0*<u_f>)/1.d0" ON <domain> # continuity
         # these also include the hoop stress terms when <<radiusdim?flag>> is appropriately set
         #CELL_EQUATION <momentum[l=1]> "celldiv(1.d0*<J_f[l=1]>)/1.d0-<dynamic_force_c[l=1]>+0*2.d0*<u[l=1]>*<mu>/(<cellx[l=1]>**2)" ON <domain> # momentum component
         #CELL_EQUATION <momentum[l=2]> "celldiv(1.d0*<J_f[l=2]>)/1.d0-<dynamic_force_c[l=2]>+0*2.d0*<u[l=2]>*<mu>/(<cellx[l=2]>**2)" ON <domain> # momentum component
         ##CELL_EQUATION <momentum[l=3]> "celldiv(1.d0*<J_f[l=3]>)/1.d0-<dynamic_force_c[l=3]>+0*2.d0*<u[l=3]>*<mu>/(<cellx[l=3]>**2)" ON <domain> # momentum component
         
         # add transient term which is independent on cartesian or cylindrical coordinates
         VARIABLE <momentum[l=1]> "<rho>*(<u[l=1]>-<u[l=1,r=1]>)/<dt>+<momentum[l=1]>"
         VARIABLE <momentum[l=2]> "<rho>*(<u[l=2]>-<u[l=2,r=1]>)/<dt>+<momentum[l=2]>"
         #VARIABLE <momentum[l=3]> "<rho>*(<u[l=3]>-<u[l=3,r=1]>)/<dt>+<momentum[l=3]>"
         #VARIABLE <momentum[l=1]> "(<rho>*<u[l=1]>-<rho[r=1]>*<u[l=1,r=1]>)/<dt>+<momentum[l=1]>"
         #VARIABLE <momentum[l=2]> "(<rho>*<u[l=2]>-<rho[r=1]>*<u[l=2,r=1]>)/<dt>+<momentum[l=2]>"
         ##VARIABLE <momentum[l=3]> "(<rho>*<u[l=3]>-<rho[r=1]>*<u[l=3,r=1]>)/<dt>+<momentum[l=3]>"
      VARIABLE <momentum[l=1]> CANCEL
      VARIABLE <momentum[l=2]> CANCEL
      #VARIABLE <momentum[l=3]> CANCEL
      
      # for walls use the following BC to be consistent with the implicit version
      # FACE_EQUATION <p_walls> "<dynamic_force_f>" ON <walls>
      
      # timestep has to be modified to include the explicit viscous stability condition
      CONSTANT <c_mu_explicit> 0.10d0 # multiplier for explicit viscous term stability timestep constraint - this is a conservative value
      # based on celldxmax
      #CONSTANT <celldxmaxmin> "cellmin(<celldxmax>,region=<domain>)" # minimum of the maximum cell dimensions
      #CONSTANT <dt_mu_explicit> "<c_mu_explicit>*<rho>*<celldxmaxmin>^2/<mu>" stepoutput
      # based on facedx, upon which <u_mf_{vis}> is also based
      # defining these as locals to avoid lousy substitution message - alternative is to cancel <dt> and <dt_initial> and redefine here, or reorder (requires another include though)
      NONE_LOCAL <facedxmin> "facemin(<facedx>,region=<domainfaces>)" # minimum of non-zero <facedx>'s
      NONE_LOCAL <dt_mu_explicit> "<c_mu_explicit>*<rho>*<facedxmin>^2/<mu>" stepoutput
      CONSTANT <dt_initial> [] "<dt_mu_explicit>" stepoutput
      #CONSTANT <CFL_initial> 0.25d0
      #CONSTANT <dt_CFL> "<CFL_initial>*<celldxmaxmin>/<u_av>" stepoutput # initial timestep based on cell dimension, expecting a velocity of magnitude <u_av>
      #CONSTANT <dt_initial> [] "nonemin(<dt_CFL>,<dt_mu_explicit>)" stepoutput
   
   # set the three boundary conditions on pressure:
   # set pressure to a uniform value over inlet
   CONSTANT <p_in> 5.6d0
   FACE_EQUATION <inlet flowrate equation> "<p_f>-<p_in>" ON <inlet> # specified pressure
   
   # set pressure to a uniform value over outlet
   FACE_EQUATION <outlet flowrate equation> "<p_f>" ON <outlet> # specified pressure
   
   # and on walls set the dynamic_force to zero
   FACE_EQUATION <p_walls> "<dynamic_force_f>" ON <walls>
   
   # explicitly set variable magnitudes using numerical constants
   VARIABLE <p> magnitude=<p_in>
   VARIABLE <u[l=1]> magnitude=<u_av>
   VARIABLE <u[l=2]> magnitude=<u_av>
   
   # overwrite previous properties with the following
   CONSTANT <mu> [Pa.s] 1.d-1 # viscosity of liquid
   
   # density is still specified - it may be used in a transient dimensional problem for example
   CONSTANT <rho> [kg/m^3] 1.d0 # density
   CONSTANT <u_av> [m/s] 0.2d0 # average inlet velocity
   
   # this parameter controls how conservative the timestep is - set to a low number (<<1) to ensure stability
   # if simulations become unstable, reduce this
   # actually has to be pretty low it seems, certainly 0.5d0 gives stability problems
   CONSTANT <c_mu_explicit> 0.25d0 # multiplier for explicit viscous term stability timestep constraint
   
   # also push this tolerance to a higher level to speed things up, if only trying to get a steady-state solution
   NEWTRESTOL 1.d-5
   INFO "simulations will not be time accurate with a large NEWTRESTOL being set"
   
   # decrease time between outputs
   CONSTANT <CFL_out> 0.1d0 # one way of entering the time between output is based on how many times a cell should be flushed between output, based on the average inlet velocity
   
   # for this example file limit the total number of iterations
   TIMESTEPMAX 10
   TIMESTEPOUT 5
   
   # calculate drag and lift on object
   NONE_OUTPUT <F_drag> [N] "facesum(<facearea>*dot(<facenorm[l=:]>,<tau[r=1,l=:,1]>),<cylinder>)" # force on object in axial direction
   NONE_OUTPUT <F_lift> [N] "facesum(<facearea>*dot(<facenorm[l=:]>,<tau[r=1,l=:,2]>),<cylinder>)" # force on object in vertical direction
   NONE_OUTPUT <C_drag> "2.d0*<F_drag>/(<rho>*<u_av>^2*0.1d0)" # drag coefficient
   NONE_OUTPUT <C_lift> "2.d0*<F_lift>/(<rho>*<u_av>^2*0.1d0)" # lift coefficient
   
   # and turn some outputs on using the generic VARIABLE statement that picks up the last type and centring
   VARIABLE <u_f_{correction}> output
   VARIABLE <u_f_{raw}> output
   VARIABLE <u_f> output
   VARIABLE <J_f[r=1,l=1]> output
   VARIABLE <tau[r=1,l=1,1]> output
   
   #INCLUDE_TEMPLATE "navier_stokes"
   #INCLUDE "strain_rate_magnitude"
   #-------------------------------------------------------------------
##################################################################################
