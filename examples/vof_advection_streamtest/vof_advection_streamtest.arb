VERSION 0.42

# simulation information
INFO_TITLE "VOF advection test 1 (uniform velocity) from the stream paper"
INFO_TITLE+ ": u=(2,1)"
INFO_TITLE+ ": circle"
INFO_AUTHOR "Dalton Harvie"
INFO_DATE "22/4/14"
INFO_VERSION "4"
INFO_DESCRIPTION "Does a linear advection test in line with that presented in DOI:10.1006/jcph.2000.6510, which itself is based on tests by Rudman and other workers"

#-------------------------------------------------------------------
# user-defined constants

#KERNEL_OPTIONS polynomialorder=2,polynomialaverageorder=2,polynomialcellorder=2

GENERAL_REPLACEMENTS REPLACE "<<dim3comment>>" WITH "#" # comment out any references to the third dimension in any included files

TIMESTEPMAX 5 # just compute 5 timesteps

# this should be a square box of sidelength 4 and origin at (0,0)
MSH_FILE "box.msh"
#MSH_FILE "box_unstructured.msh"

NONE_CONSTANT <vof_phi_initial_tol> 1.d-3
# the cellvofphishape function takes two vectors, a size and centre, returning a volume fraction for each cell
# the size of the object is determined by the maximum size that is consistent with all of the object's dimensions (defaults to huge), so for a sphere set one size to the sphere's diameter
# the centre of the object is specified by the centre vector, defaulting to zero if a component is not specified
# for 2D shapes choose a 3D shape that gives the correct intersection with the 2D plane (ie, sphere for circle, box for rectangle)
OVERRIDE_OPTIONS noinput,output
# circle
CELL_CONSTANT <vof_phi_initial_saved> "cellmax(cellmin(cellvofphishape[sphere](size[l=1]=0.8d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<vof_phi_initial_tol>)-cellvofphishape[sphere](size[l=1]=0.4d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<vof_phi_initial_tol>),1.d0),0.d0)"  input
CELL_CONSTANT <vof_phi_initial1> "cellmax(cellmin(cellvofphishape[sphere](size[l=1]=0.8d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<vof_phi_initial_tol>)-cellvofphishape[sphere](size[l=1]=0.4d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<vof_phi_initial_tol>),1.d0),0.d0)" input
CELL_CONSTANT <vof_phi_final1> "cellmax(cellmin(cellvofphishape[sphere](size[l=1]=0.8d0,centre[l=1]=3.5d0,centre[l=2]=0.5d0,phitol=<vof_phi_initial_tol>)-cellvofphishape[sphere](size[l=1]=0.4d0,centre[l=1]=3.5d0,centre[l=2]=0.5d0,phitol=<vof_phi_initial_tol>),1.d0),0.d0)"   input
CELL_CONSTANT <vof_phi_final2> "cellmax(cellmin(cellvofphishape[sphere](size[l=1]=0.8d0,centre[l=1]=3.5d0,centre[l=2]=2.0d0,phitol=<vof_phi_initial_tol>)-cellvofphishape[sphere](size[l=1]=0.4d0,centre[l=1]=3.5d0,centre[l=2]=2.0d0,phitol=<vof_phi_initial_tol>),1.d0),0.d0)"   input
# square
#CELL_CONSTANT <vof_phi_initial> "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<vof_phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<vof_phi_initial_tol>),1.d0),0.d0)"  input
#CELL_CONSTANT <vof_phi_initial1> "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<vof_phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,phitol=<vof_phi_initial_tol>),1.d0),0.d0)" input
#CELL_CONSTANT <vof_phi_final1> "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=3.5d0,centre[l=2]=0.5d0,phitol=<vof_phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=3.5d0,centre[l=2]=0.5d0,phitol=<vof_phi_initial_tol>),1.d0),0.d0)"   input
#CELL_CONSTANT <vof_phi_final2> "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=3.5d0,centre[l=2]=2.0d0,phitol=<vof_phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=3.5d0,centre[l=2]=2.0d0,phitol=<vof_phi_initial_tol>),1.d0),0.d0)"   input
# rotated square (not working yet)
#CELL_CONSTANT <vof_phi_initial>  "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<vof_phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<vof_phi_initial_tol>),1.d0),0.d0)"  input
#CELL_CONSTANT <vof_phi_initial1> "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<vof_phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=0.5d0,centre[l=2]=0.5d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<vof_phi_initial_tol>),1.d0),0.d0)" input
#CELL_CONSTANT <vof_phi_final1>   "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=3.5d0,centre[l=2]=0.5d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<vof_phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=3.5d0,centre[l=2]=0.5d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<vof_phi_initial_tol>),1.d0),0.d0)"   input
#CELL_CONSTANT <vof_phi_final2>   "cellmax(cellmin(cellvofphishape[cube](size[l=1]=0.8d0,centre[l=1]=3.5d0,centre[l=2]=2.0d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<vof_phi_initial_tol>)-cellvofphishape[cube](size[l=1]=0.4d0,centre[l=1]=3.5d0,centre[l=2]=2.0d0,axis[l=3]=26.57*<pi>/180.d0,phitol=<vof_phi_initial_tol>),1.d0),0.d0)"   input
OVERRIDE_OPTIONS

# set up velocity field
CELL_CONSTANT <u[l=1]> 2.d0
CELL_CONSTANT <u[l=2]> 1.d0
FACE_LOCAL <u_f_vect[l=1]> "faceave[reflect=1](<u[l=1]>)" output
FACE_LOCAL <u_f_vect[l=2]> "faceave[reflect=2](<u[l=2]>)"
FACE_CONSTANT <u_f> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" output
CELL_CONSTANT <CFL/dt local> "facesum(faceif(<facedivop>*<u_f>,<facedivop>*<u_f>,0.d0),region=<celljfaces>)" ON <domain> output
NONE_CONSTANT <CFL/dt> "cellmax(<CFL/dt local>,region=<domain>)" output
NONE_CONSTANT <CFL> 0.125d0 # this is the target CFL, based on the volume of fluid flowing out of each cell
NONE_CONSTANT <dt> "<CFL>/nonemax(<CFL/dt>,1.d-10)" # this is the timestep based on the target CFL
CONSTANT <celldxave> "cellsum(<celldxmax>,region=<domain>)/cellsum(1.d0,region=<domain>)" # average cell dimension

# set up time variables
NONE_CONSTANT <t_end> "3.d0/cellmax(abs(<u[l=1]>),region=<domain>)" # base final time on form moving 3 in the horizontal direction
NONE_CONSTANT <dt_out> "<t_end>/20.d0" # base output time on a number of steps within the end time
TRANSIENT_SIMULATION
NONE_TRANSIENT <t[r=0]> "0.d0" "<t[r=1]>+<dt[r=0]>" # time
NONE_TRANSIENT <t[r=1]> "<t>-<dt[r=0]>" "<t>" # time at last step
NONE_CONDITION <output test> "<t>-<t_out>-<dt_out>+<dt>*1.d-10" outputcondition # this will be true (>0.) whenever we are <dt_out> from last output
NONE_OUTPUT <t_out> "<t>" stepoutputnoupdate # this will record the time of the last output
NONE_CONDITION <stop test> "<t>-<t_end>" stopcondition # when this becomes true (>0.) the simulation stops

#TIMESTEPMAX 20
#TIMESTEPMAX 1
#TIMESTEPOUT 1

INCLUDE_ROOT "free_surface/volume_of_fluid"
DEFAULT_OPTIONS noderivative

# changed for v0.50 vof_development
# use same structure as per interface_geometry, except that we don't need to calculate the curvature
#INCLUDE "setup" R "CELL_UNKNOWN" W "#CELL_UNKNOWN"
#INCLUDE "expand_phi_delta" R "<<maxseparation>>" W "1" # maxseparation controls thickness of delta region, and hence also magnitude of currents - smoothing constant is now linked to this parameter
#INCLUDE "delta"
#INCLUDE "normals_delta"
#INCLUDE "expand_normals_angle"

# pre v0.50 vof advection routines
CELL_LOCAL <vof_phi_rounded> "cellif(<vof_phi>-<vof_phi_tol>,cellif(1.d0-<vof_phi_tol>-<vof_phi>,<vof_phi>,1.d0),0.d0)"
CELL_TRANSIENT <vof_phi[r=1]> "<vof_phi_initial>" "<vof_phi_rounded>" output
CONSTANT <vof_phi_tol> 1.d-8
CELL_LOCAL <vof_phi_lim> "cellmax(cellmin(<vof_phi>,1.d0),0.d0)" ON <all cells>
# compute a smoothed phi, which is used in the surface tension calculation and later in the vof advection
INCLUDE "smooth_phi"
# include routines to calculate surface tension force
INCLUDE "smooth_normals" R "<vof_phigrad_unit" W "<vof_phigrad_expand_unit"

DEFAULT_OPTIONS

CELL_LOCAL <vof_phi_initial> "<vof_phi_initial_saved>" ON <all cells>

# included routines are in terms of derived, so save these for current step
CELL_TRANSIENT <vof_phigrad_expand_unit[l=1,r=1]> "0.d0" "<vof_phigrad_expand_unit[l=1]>" ON <all cells>
CELL_TRANSIENT <vof_phigrad_expand_unit[l=2,r=1]> "0.d0" "<vof_phigrad_expand_unit[l=2]>" ON <all cells>

CELL_TRANSIENT <vofd[r=1]> "0.d0" "cellvofd[noderivative,exact](phi=<vof_phi[r=1]>,normal[l=1]=<vof_phigrad_expand_unit[l=1,r=1]>,normal[l=2]=<vof_phigrad_expand_unit[l=2,r=1]>,phitol=<vof_phi_tol>)" ON <all cells> output

# face centred advection phi can be worked out using routine in free_surface_functions.f90 (inbuilt), or using some template files
# the latter is more accurate, but only works for transient, 2D problems
# inbuilt routine
FACE_TRANSIENT <vof_phi_f[r=1]> "0.d0" "facevofphi[linearone](phi=<vof_phi[r=1]>,d=<vofd[r=1]>,flux=<u_f>,normal[l=1]=<vof_phigrad_expand_unit[l=1,r=1]>,normal[l=2]=<vof_phigrad_expand_unit[l=2,r=1]>,phitol=<vof_phi_tol>)" ON <all faces> output
# templates routines
#INCLUDE_ROOT "volume_of_fluid"
#INCLUDE "facevofphi_linearone_2D" R "<facevofphi_n[l=" W "<vof_phigrad_expand_unit[r=1,l=" R "<facevofphi_d>" W "<vofd[r=1]>" R "<facevofphi_phi>" W "<vof_phi[r=1]>"
#INCLUDE "facevofphi_linearone_2D_advected" R "<facevofphi_n[l=" W "<vof_phigrad_expand_unit[r=1,l=" R "<facevofphi_d>" W "<vofd[r=1]>" R "<facevofphi_phi>" W "<vof_phi[r=1]>" R "<facevofphi_f[r=1]>" W "<vof_phi_f[r=1]>"
#INCLUDE "facevofphi_linearone_2D_advected_vector_explicit" R "<facevofphi_n[l=" W "<vof_phigrad_expand_unit[r=1,l=" R "<facevofphi_d>" W "<vofd[r=1]>" R "<facevofphi_phi>" W "<vof_phi[r=1]>" R "<facevofphi_f[r=1]>" W "<vof_phi_f[r=1]>" R "<facevofphi_phi>" W "<vof_phi[r=1]>" R "<facevofphi_phitol>" W "<vof_phi_tol>"

VARIABLE <vof_phi_f[r=1]> output

CELL_TRANSIENT <vof_phi_adjust[r=1]> "0.d0" "cellvofphiadjust(phi[r=1]=<vof_phi[r=1]>,phif=<vof_phi_f[r=1]>,flux=<u_f>,dt=<dt>)" ON <domain> output
#CELL_CONSTANT <vof_phi_adjust[r=1]> 0.d0 ON <domain> output
FACE_TRANSIENT <vof_phi_f_adjusted[r=1]> "0.d0" "faceif(facedelta(<domain faces>),facemax(facemin(<vof_phi_f[r=1]>+faceif(<u_f>,faceave[downcell](<vof_phi_adjust[r=1]>),faceave[upcell](<vof_phi_adjust[r=1]>)),1.d0),0.d0),0.d0)" ON <all faces> output

CELL_TRANSIENT <vof_phi> "<vof_phi_initial>" "<vof_phi[r=1]>-<dt>*celldiv(<vof_phi_f_adjusted[r=1]>*<u_f>)" output

NONE_OUTPUT <error_initial_initial1> "cellsum(abs(<vof_phi_initial>-<vof_phi_initial1>),region=<domain>)/cellsum(<vof_phi_initial1>,region=<domain>)"
NONE_OUTPUT <error_final1> "cellsum(abs(<vof_phi>-<vof_phi_final1>),region=<domain>)/cellsum(<vof_phi>,region=<domain>)"
NONE_OUTPUT <error_final2> "cellsum(abs(<vof_phi>-<vof_phi_final2>),region=<domain>)/cellsum(<vof_phi>,region=<domain>)"
CELL_OUTPUT <icell_output> "<icell>"
FACE_OUTPUT <jface_output> "<jface>"

