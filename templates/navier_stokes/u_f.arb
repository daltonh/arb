# interpolate the cell centred velocity to the faces and find the velocity (flux) normal to the face (<u_f>), using a rhie-chow spirited interpolation technique on the domain faces

# check default strings are set
INCLUDE "default_string_replacements"

# start by calculating the difference between the local face centred (dynamic) pressure gradient and average of cell centred (dynamic) pressure gradients in the face direction
# `dynamic' pressure here means the pressure that is able to cause fluid flow, ie, possibly accounting for hydrostatic pressure variations (for example)
INCLUDE "p_error"

FACE_LOCAL <u_f_vect[l=<<i>>]> "faceave[<<reflect=<<i>>>>](<u[l=<<i>>]>)"
FACE_DERIVED <u_f_{raw}> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" ON <allfaces> # volume (velocity) transport

# this file now does both steady-state and transient using transient comments string replacements, which are set in constants.arb

# save old correction velocity for transient calculations
IF <<transientnavierstokes>>
  FACE_TRANSIENT <u_f_{correction}[r=1]> "0.d0" "<u_f_{correction}>" ON <domainfaces>
END_IF

# assemble <u_f_{correction}>, taking advantage of variable reuse so that only one expression is formed for <u_f_{correction}> (to maximise code efficiency and maxima expression simplifications)

# first assemble demoninator of expression:

# all equation variants here have viscous contribution, so add this first
# the rf stands for reciprocal and face centred
# same piece of code as in total_stress to deal with <mu_f> replacement
REPLACEMENTS R "<<mu_f>>" W "<mu_f>" # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
IF {{ return ( !(string_examine('<mu_f>')) && string_eval('<<uniformviscosity>>') ) }}  # this evaluates as true (1) if replacement string '<mu_f>' isn't defined, AND <<uniformviscosity>> is on (1)
  REPLACEMENTS S "<<mu_f>>" W "<mu>" # if we are here then we apply the uniform viscosity substitution
END_IF
FACE_LOCAL <u_rf_{vis}> "<<mu_f>>/<facedx>^2" ON <allfaces> # incase pextrapolationrhiechow is on, define these locals on allfaces (makes no difference to efficiency as they are locals anyway)
FACE_DERIVED <u_f_{correction}> "<u_rf_{vis}>" ON <domainfaces>

REPLACEMENTS R "<<rho_f>>" W "<rho_f>" # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
IF {{ return ( !(string_examine('<rho_f>')) && string_eval('<<uniformdensity>>') ) }}  # this evaluates as true (1) if replacement string '<rho_f>' isn't defined, AND <<uniformviscosity>> is on (1)
  REPLACEMENTS S "<<rho_f>>" W "<rho>" # if we are here then we apply the uniform density substitution
END_IF

#############################################
# advection term
IF {{ return (!(string_eval('<<stokes>>'))) }} # only for navier-stokes equations
#--------------
# use this option to base the adv component on the total velocity magnitude, rather than the component over each face
# the old way (pre v0.59) was to use <u_f_{raw}> which is the flux across the face when calculating the advective rhie-chow term
# the new way (v0.59 and onwards) is based on the total velocity magnitude, so overwrite the string <<ufmagnitude>> with <u_f_vect_magnitude> which is the total magnitude of <u_f_vect[l=:]>
  REPLACEMENTS D "<<ufadvectionmag>>" W "1"
#--------------
  REPLACEMENTS R "<<ufmagnitude>>" W "abs(<u_f_{raw}>)" # initialise variable using the old way, within the applicable block
  IF <<ufadvectionmag>> # ie, the new way
# for a transient simulation the previous velocity magnitude is used, consistent with that used in the momentum advection
# (although this can be overwritten by setting <<ufvectmagnitudeexplicit>> = 0 directly)
    REPLACEMENTS D "<<ufvectmagnitudeexplicit>>" W "<<transientnavierstokes>>"
    IF <<ufvectmagnitudeexplicit>>
      FACE_LOCAL <u_f_vect[l=<<i>>,r=1]> "faceave[<<reflect=<<i>>>>](<u[l=<<i>>,r=1]>)"
#     FACE_TRANSIENT <u_f_vect_magnitude[r=1]> "" "sqrt(facemax(dot(<u_f_vect[l=:,r=1]>,<u_f_vect[l=:,r=1]>),<tinyish>))" ON <allfaces>
      FACE_TRANSIENT <u_f_vect_magnitude[r=1]> "" "mag(<u_f_vect[l=:,r=1]>)" ON <allfaces>
      REPLACEMENTS S "<<ufmagnitude>>" W "<u_f_vect_magnitude[r=1]>" # S or SUBSTITUTE will redefine variable but in old context, ie, outside of IF block
    ELSE
#     FACE_LOCAL <u_f_vect_magnitude> "sqrt(facemax(dot(<u_f_vect[l=:]>,<u_f_vect[l=:]>),<tinyish>))" ON <allfaces>
      FACE_LOCAL <u_f_vect_magnitude> "mag(<u_f_vect[l=:]>)" ON <allfaces>
      REPLACEMENTS S "<<ufmagnitude>>" W "<u_f_vect_magnitude>" # S or SUBSTITUTE will redefine variable but in old context, ie, outside of IF block
    END_IF
  END_IF
# now calculate <u_rf_{adv}>
#-------------
# advective contribution can be either simple or more complex (set by <<ufadvectioncomplex>>)
# the default behaviour is to use the simple advective contribution
  REPLACEMENTS D <<ufadvectioncomplex>> W "0"
  IF <<ufadvectioncomplex>>
# more complex variant, which does not assume generally small correction velocities (and under steady-state conditions is equivalent to what was used pre v0.55) but is more expensive to compute, for what seems like little practical gain.  There is some evidence that the more complex variant can allow steady-state sims to converge more as Re increases, but very very marginal.
    FACE_LOCAL <eps_p> "facemax(abs(<p_error>),<tinyish>)" ON <allfaces>
    FACE_LOCAL <u_rf_{adv}> "<eps_p>/(-<<ufmagnitude>>+sqrt(<<ufmagnitude>>^2+<eps_p>*<facedx>/<<rho_f>>))" ON <allfaces>
  ELSE
# simple advective contribution (which really assumes that locally |<u_f_{raw}>| >> |<u_f_{correction}>|
    FACE_LOCAL <u_rf_{adv}> "2.d0*<<rho_f>>*<<ufmagnitude>>/<facedx>" ON <allfaces>
  END_IF
# ---------
# finally add on advection contribution
  FACE_DERIVED <u_f_{correction}> "<u_f_{correction}>+<u_rf_{adv}>"
END_IF

#############################################
IF <<transientnavierstokes>>
# for transient, add transient component to demoninator, take reciprocal, and add top transient and pressure contributions
  FACE_LOCAL <u_rf_{transient}> "<<rho_f>>/<dt>" ON <allfaces>
  FACE_DERIVED <u_f_{correction}> "(-<C_{Rhie-Chow}>*<p_error>+<u_rf_{transient}>*<u_f_{correction}[r=1]>)/(<u_f_{correction}>+<u_rf_{transient}>)"
ELSE
# for steady-state just take reciprocal and add pressure contribution
  FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<p_error>/(<u_f_{correction}>)"
END_IF
#############################################

# final face velocity
FACE_DERIVED <u_f> "<u_f_{raw}>+faceif(facedelta(<domainfaces>),<u_f_{correction}>,0.d0)" ON <allfaces> # volume (velocity) transport

# this section just re-works the implicit timestepping equation to allow a newtstepmax to be applied to <dt_target>
# save a derived copy of <dt_target> after <u_f> has been calculated so that we can apply newtstepmax to it
# this string will already have been set to 1 (as a general replacement) in transient_all_setup if this option is relevant
# this is the default behaviour when using implicit dynamic timestepping
REPLACEMENTS D "<<implicittimestepnewtstep>>" W "0"
IF <<implicittimestepnewtstep>>
  NONE_DERIVED <dt_target_derived> "<dt_target>" newtstepmax=10
  NONE_EQUATION <dt implicit equation> "<dt>-<dt_target_derived>"
END_IF
