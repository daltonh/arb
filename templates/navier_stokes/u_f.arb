# interpolate the cell centred velocity to the faces and find the velocity (flux) normal to the face (<u_f>), using a rhie-chow spirited interpolation technique on the domain faces

# check default strings are set
INCLUDE "default_string_replacements"

# start by calculating the difference between the local face centred (dynamic) pressure gradient and average of cell centred (dynamic) pressure gradients in the face direction
# `dynamic' pressure here means the pressure that is able to cause fluid flow, ie, possibly accounting for hydrostatic pressure variations (for example)
INCLUDE "p_error"

<<dim1comment>>FACE_LOCAL <u_f_vect[l=1]> "faceave[<<reflect=1>>](<u[l=1]>)"
<<dim2comment>>FACE_LOCAL <u_f_vect[l=2]> "faceave[<<reflect=2>>](<u[l=2]>)"
<<dim3comment>>FACE_LOCAL <u_f_vect[l=3]> "faceave[<<reflect=3>>](<u[l=3]>)"
FACE_DERIVED <u_f_{raw}> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" ON <allfaces> # volume (velocity) transport

# this file now does both steady-state and transient using transient comments string replacements, which are set in constants.arb

# save old correction velocity for transient calculations
<<transientnavierstokescomment>>FACE_TRANSIENT <u_f_{correction}[r=1]> "0.d0" "<u_f_{correction}>" ON <domainfaces>

# assemble <u_f_{correction}>, taking advantage of variable reuse so that only one expression is formed for <u_f_{correction}> (to maximise code efficiency and maxima expression simplifications)

# first assemble demoninator of expression:

# all equation variants here have viscous contribution, so add this first
# the rf stands for reciprocal and face centred
# same piece of code as in total_stress to deal with <mu_f> replacement
REPLACEMENTS R "<<mu_f>>" W "<mu_f>" # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
IF {{ return ( !(string_examine('<mu_f>')) && string_eval('<<uniformviscosity>>') ) }}  # this evaluates as true (1) if replacement string '<mu_f>' isn't defined, AND <<uniformviscosity>> is on (1)
  REPLACEMENTS R "<<mu_f>>" W "<mu>" # if we are here then we apply the uniform viscosity substitution
END_IF
FACE_LOCAL <u_rf_{vis}> "<<mu_f>>/<facedx>^2" ON <domainfaces>
FACE_DERIVED <u_f_{correction}> "<u_rf_{vis}>" ON <domainfaces>

# advective contribution can be either simple or more complex (set by <<ufadvectioncomplexcomment>>)
# the default behaviour is to use the simple advective contribution
GENERAL_REPLACEMENTS D <<ufadvectioncomplexcomment>> W "#"
# include the following line in your input file prior to loading this template file to access the more complex contribution
#GENERAL_REPLACEMENTS R <<ufadvectioncomplexcomment>> W ""

REPLACEMENTS R "<<rho_f>>" W "<rho_f>" # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
IF {{ return ( !(string_examine('<rho_f>')) && string_eval('<<uniformdensity>>') ) }}  # this evaluates as true (1) if replacement string '<rho_f>' isn't defined, AND <<uniformviscosity>> is on (1)
  REPLACEMENTS R "<<rho_f>>" W "<mu>" # if we are here then we apply the uniform density substitution
END_IF
# form opposite string to be consistent with <<ufadvectioncomplexcomment>> 
GENERAL_REPLACEMENTS R <<ufadvectionsimplecomment>> W "" 
<<ufadvectioncomplexcomment>>GENERAL_REPLACEMENTS R <<ufadvectionsimplecomment>> W "#" 
# next add simple advective contribution (which really assumes that locally |<u_f_{raw}>| >> |<u_f_{correction}>|
<<ufadvectionsimplecomment>><<navierstokescomment>>FACE_LOCAL <u_rf_{adv}> "2.d0*<<rho_f>>*abs(<u_f_{raw}>)/<facedx>" ON <domainfaces>
# or more complex variant, which does not assume generally small correction velocities (and under steady-state conditions is equivalent to what was used pre v0.55) but is more expensive to compute, for what seems like little practical gain.  There is some evidence that the more complex variant can allow steady-state sims to converge more as Re increases, but very very marginal.
<<ufadvectioncomplexcomment>><<navierstokescomment>>FACE_LOCAL <eps_p> "facemax(abs(<p_error>),<tinyish>)" ON <domainfaces>
<<ufadvectioncomplexcomment>><<navierstokescomment>>FACE_LOCAL <u_rf_{adv}> "<eps_p>/(-abs(<u_f_{raw}>)+sqrt(<u_f_{raw}>^2+<eps_p>*<facedx>/<<rho_f>>))" ON <domainfaces>

<<navierstokescomment>>FACE_DERIVED <u_f_{correction}> "<u_f_{correction}>+<u_rf_{adv}>"

# for transient, add transient component to demoninator, take reciprocal, and add top transient and pressure contributions
<<transientnavierstokescomment>>FACE_LOCAL <u_rf_{transient}> "<<rho_f>>/<dt>" ON <domainfaces>
<<transientnavierstokescomment>>FACE_DERIVED <u_f_{correction}> "(-<C_{Rhie-Chow}>*<p_error>+<u_rf_{transient}>*<u_f_{correction}[r=1]>)/(<u_f_{correction}>+<u_rf_{transient}>)"
# for steady-state just take reciprocal and add pressure contribution
<<steadystatenavierstokescomment>>FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<p_error>/(<u_f_{correction}>)"

# final face velocity
FACE_DERIVED <u_f> "<u_f_{raw}>+faceif(facedelta(<domainfaces>),<u_f_{correction}>,0.d0)" ON <allfaces> # volume (velocity) transport

# this section just re-works the implicit timestepping equation to allow a newtstepmax to be applied to <dt_target>
# save a derived copy of <dt_target> after <u_f> has been calculated so that we can apply newtstepmax to it
# if <<implicittimestepcomment>> hasn't already been set then set it here (to off) - for on will have already required dynamic timestepping to be on
GENERAL_REPLACEMENTS DEFAULT "<<implicittimestepcomment>>" W "#" DEFAULT "<<explicittimestepcomment>>" W ""
<<transientnavierstokescomment>><<implicittimestepcomment>>NONE_DERIVED <dt_target_derived> "<dt_target>" newtstepmax=10
<<transientnavierstokescomment>><<implicittimestepcomment>>NONE_EQUATION <dt implicit equation> "<dt>-<dt_target_derived>"
