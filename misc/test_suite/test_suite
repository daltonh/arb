#!/bin/bash
#
# file test_suite
#
# Copyright 2009-2015 Dalton Harvie (daltonh@unimelb.edu.au)
# 
# This file is part of arb finite volume solver, referred to as `arb'.
# 
# arb is a software package designed to solve arbitrary partial
# differential equations on unstructured meshes using the finite volume
# method.  Primarily it consists of fortran source code, perl source
# code and shell scripts.  arb replies on certain third party software
# to run, most notably the computer algebra system maxima
# <http://maxima.sourceforge.net/> which is released under the GNU GPL.
# 
# The copyright of arb is held by Dalton Harvie.
# 
# arb is released under the GNU GPL.  arb is free software: you can
# redistribute it and/or modify it under the terms of the GNU General
# Public License (version 3) as published by the Free Software Foundation.
# You should have received a copy of the GNU General Public Licence
# along with arb (see file licence/gpl.txt after unpacking).  If not,
# see <http://www.gnu.org/licences/>.
# 
# arb is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public Licence
# for more details.
# 
# For full details of arb's licence see the licence directory.
# 
# The current homepage for the arb finite volume solver project is
# <http://people.eng.unimelb.edu.au/daltonh/downloads/arb>.
#
#-------------------------------------------------------------------------
#
# a little script to run through and test all of the example/manual problems
# daltonh, 24/11/10

# usage: from the working directory run ./misc/test_suite/test_suite
#-------------------------------------------------------------------------------
# usage function
usage () {
  echo
  echo "HELP/USAGE: ./misc/test_suite/testsuite [options] [test_case1] [test_case2] [etc]";
  echo
  echo "This script will run through all of the test problems within the examples directory";
  echo "Run from the working directory (as above)";
  echo "Alternatively, if any test_case's are specified, only they will be run";
  echo "To stop this script cleanly, do touch test_suite_stop within the working directory (and touch stop after this to stop the current simulation asap)";
  echo
  echo "Possible options:";
  echo "  --clean|-c: remove previous results and run tests afresh";
  echo "  --refresh|r: only run the tests that were previously unsuccessful (default)";
  echo "  --compiler-gnu: use the gfortran compiler";
  echo "  --compiler-intel: use the intel compiler";
  echo "  --compiler-both: use both compilers sequentially (default)";
  echo "  --help|-h: display this HELP INFO";
  echo;
  exit 1;
}
#-------------------------------------------------------------------------------
cwd=`pwd`;
examples_dir=$cwd'/examples';
#examples_dir=$cwd'/examples_test';
suitesparse_dir=$cwd'/src/contributed/suitesparse'
log_file=$cwd'/test_suite.log'
saved_dir=$cwd'/saved_input_files'
stopfile='test_suite_stop'
error=0;
REFRESH=1; # default is refresh is on
COMPILER="both"; # both compilers used by default
arb_options=""; # any additional options you want passed
#arb_options="--debugger-none";
unset TESTCASES;

if [ -e $stopfile ] ; then rm $stopfile ; fi;

# check for any options
for i in $*
do
  case $i in
    "--refresh"|"-r") REFRESH=1;; # only runs that were unsuccessful on the last run are repeated (default behaviour)
    "--clean"|"-c") REFRESH=0;; # rerun simulations whether or not they were successful or not previously
    "--compiler-gnu") COMPILER="gnu";;
    "--compiler-intel") COMPILER="intel";;
    "--compiler-both") COMPILER="both";;
    "--help"|"-h") usage;;
    *) echo "INFO: adding test case $i"; TESTCASES[${#TESTCASES[@]}]=$i;;
  esac
done ;

if [ -e $log_file -a $REFRESH -eq 0 ] ; then rm $log_file ; fi;

if [ -e $log_file -a $REFRESH -eq 1 ] ; then echo "INFO: restart of test_suite" >>$log_file ; fi;

# check that examples are in the right location
if [ ! -d $examples_dir ] ; then
  echo "ERROR: examples directory $examples_dir does not exist";
  exit 1;
fi;

# if no test cases have been specifically given, set to all within the examples directory
if [ -z "${TESTCASES[0]}" ] ; then
  cd $examples_dir;
  TESTCASES=( * );
  cd ..;
fi;
echo "INFO: attempting to run within the following directories (validity checked later): ${TESTCASES[@]}" >>$log_file;

# set compilers based on COMPILER option
unset COMPILERS;
if [ $COMPILER = "both" ] ; then
echo "compiler = both"
  COMPILERS=( "gnu" "intel" );
else
  COMPILERS[0]=$COMPILER;
fi;
echo "INFO: using the following compilers: ${COMPILERS[@]}" >>$log_file;

# check that suitesparse solver is in the right location
if [ ! -d $suitesparse_dir ] ; then
  echo "ERROR: suitesparse directory $suitesparse_dir does not exist";
  exit 1;
fi;

# download and make suitesparse solver
echo "INFO: attempting to make the suitesparse solver";
echo "INFO: attempting to make the suitesparse solver" >>$log_file 2>>$log_file;
cd $suitesparse_dir;
make >>$log_file 2>>$log_file;
if [ $? -ne 0 ] ; then
  echo "ERROR: problem fetching/compiling the suitesparse solver";
  echo "ERROR: problem fetching/compiling the suitesparse solver" >>$log_file 2>>$log_file;
  cd $cwd;
  exit 1 ;
else
  echo "INFO: suitesparse solver successfully compiled";
  echo "INFO: suitesparse solver successfully compiled" >>$log_file 2>>$log_file;
  cd $cwd;
fi ;

# create saved_dir and move input files into it for later replacement
if [ -d $saved_dir ] ; then
  echo "ERROR: the saved input files directory $saved_dir already exists - delete or rename";
  exit 1;
fi

echo "INFO: saving existing arb and geo files" >>$log_file;
mkdir $saved_dir;
mv *.arb $saved_dir >/dev/null 2>/dev/null;
mv *.msh $saved_dir >/dev/null 2>/dev/null;
rm output/output*.msh   >/dev/null 2>/dev/null;
rm output/output*.scr   >/dev/null 2>/dev/null;
rm output/output*.stat  >/dev/null 2>/dev/null;
rm output/output*.stp   >/dev/null 2>/dev/null;
rm output/output*.csv   >/dev/null 2>/dev/null;
rm output/*warnings.txt >/dev/null 2>/dev/null;
rm output/*details.txt  >/dev/null 2>/dev/null;

# run through each example problem
for dir_name in ${TESTCASES[@]} ; do
  subdir=$examples_dir/$dir_name;
  if [ ! -d $subdir ] ; then
    echo "INFO: skipping directory $subdir as it does not exist";
    echo "INFO: skipping directory $subdir as it does not exist" >>$log_file;
    continue;
  fi
  arbfiles=`ls $subdir/*.arb 2>/dev/null`; # create a single string which lists all arb files in this subdirectory, ignoring errors (and creating empty string) if nothing present
  if [ -z "${arbfiles}" -o -L $subdir ] ; then
    echo "INFO: skipping directory $subdir as it is a link to another directory or does not contain an arb input file";
    echo "INFO: skipping directory $subdir as it is a link to another directory or does not contain an arb input file" >>$log_file;
    continue;
  fi # skip the directory if it doesn't contain an arb input file or is not a directory (could be a tutorial link for example)
  for compiler in ${COMPILERS[@]} ; do # run with the chosen compilers
# make results directory within examples directories and copy over all of the outputs
    results_dir=$subdir/resources/test_suite_results/$compiler;
    if [ ! -d $results_dir ] ; then mkdir -p $results_dir ; fi
    if [ $REFRESH -eq 1 -a -e $results_dir/SUCCESS ] ; then
      echo "INFO: skipping arb simulation of test case $subdir using $compiler compiler as successful results already exist";
      echo "INFO: skipping arb simulation of test case $subdir using $compiler compiler as successful results already exist" >>$log_file;
      continue;
    else
      echo "INFO: performing arb simulation of test case $subdir using $compiler compiler";
      echo "INFO: performing arb simulation of test case $subdir using $compiler compiler" >>$log_file;
      rm $results_dir/* >/dev/null 2>/dev/null;
    fi
    local_log_file="$results_dir/test_suite.log";
    cp $subdir/*.arb $cwd >>$local_log_file 2>>$local_log_file;
    cp $subdir/*.msh $cwd >>$local_log_file 2>>$local_log_file;
    ./arb $arb_options --quiet --compiler-$compiler >>$local_log_file 2>>$local_log_file;
    keyword=ERROR_IN_MAKE;
    if [ -e output/output.scr ] ; then
      last_line=`tail -n 2 output/output.scr`; # with change to quiet behaviour of arb, the SUCCESS statement is now on the second last line of output.scr
      keyword=`echo $last_line | cut -c 1-7`;
      if [[ ! "$keyword" == "SUCCESS" ]] ; then keyword="ERROR_IN_RUN"; fi
    fi
#   echo "DEBUG: keyword = $keyword" >>$local_log_file 2>>$local_log_file;
    cp output/output*.msh   $results_dir >/dev/null 2>/dev/null;
    cp output/output*.scr   $results_dir >/dev/null 2>/dev/null;
    cp output/output*.stat  $results_dir >/dev/null 2>/dev/null;
    cp output/output*.stp   $results_dir >/dev/null 2>/dev/null;
    cp output/output*.csv   $results_dir >/dev/null 2>/dev/null;
    cp output/*warnings.txt $results_dir >/dev/null 2>/dev/null;
    cp output/*details.txt  $results_dir >/dev/null 2>/dev/null;
# also create unwrapped input directory and copy over unwrapped_input.arb
    if [ ! -d $subdir/unwrapped_input ] ; then mkdir -p $subdir/unwrapped_input ; fi
    cp tmp/setup/unwrapped_input.arb $subdir/unwrapped_input >/dev/null 2>/dev/null;
    touch $results_dir/$keyword;
    if [[ "$keyword" == "SUCCESS" ]]; then
      echo "INFO: simulation $subdir using $compiler compiler was successful";
      echo "INFO: simulation $subdir using $compiler compiler was successful" >>$log_file;
      echo "INFO TEST_SUITE: simulation $subdir using $compiler compiler was successful" >>$local_log_file;
    else
      echo "ERROR: simulation $subdir using $compiler compiler was not successful: $keyword";
      echo "ERROR: simulation $subdir using $compiler compiler was not successful: $keyword" >>$log_file;
      echo "ERROR TEST_SUITE: simulation $subdir using $compiler compiler was not successful: $keyword" >>$local_log_file;
      error=1;
    fi;
# finally remove input files ready for the next run   
    rm *.arb >/dev/null 2>/dev/null # note, *.in files are not used if an *.arb file is present
    rm *.msh >/dev/null 2>/dev/null
    rm output/* >/dev/null 2>/dev/null; # and clear output files
    if [ -e fort.* ]; then
      echo "ERROR: debugging files (ie fort.*) are being produced: you must have left a debugging flag on?: exiting";
      echo "ERROR: debugging files (ie fort.*) are being produced: you must have left a debugging flag on?: exiting" >>$log_file;
      error=1;
      break 2; # jump out of two loop levels
    fi;
    if [ -e $stopfile ]; then
      echo "INFO: user has requested that test_suite program stops";
      echo "INFO: user has requested that test_suite program stops" >>$log_file;
      error=1;
      break 2; # jump out of two loop levels
    fi;
  done;
done;

# move original input and output files back to cwd and delete saved_dir
mv $saved_dir/* . >/dev/null 2>/dev/null;
rmdir $saved_dir;

if [ $error -eq 0 ] ; then
  echo "SUCCESS: all simulations completed gracefully";
  echo "SUCCESS: all simulations completed gracefully" >>$log_file;
  exit 0;
else
  echo "ERROR: atleast one simulation did not finish successfully";
  echo "ERROR: atleast one simulation did not finish successfully" >>$log_file;
  exit 1;
fi
