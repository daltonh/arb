#(comment created during unwrap): new block = resources/test_suite_results/intel/output/build/root_input.arb: sub_block = 0
# root_input.arb file created by the arb script
##################################################################################
# the following external fortran files were found by the arb script and are available for inclusion: /home/daltonh/fortran/arb/testsuite/arb_nonuniform_properties_cleanup2/src/free_surface_functions.f90
EXTERNALS "/home/daltonh/fortran/arb/testsuite/arb_nonuniform_properties_cleanup2/src/free_surface_functions.f90"
##################################################################################
# the following working directory files found by the arb script: electrokinetic_channel.arb
   #(comment created during unwrap): new block = electrokinetic_channel.arb: sub_block = 0
   #(hash inserted during unwrap)INCLUDE_WORKING "electrokinetic_channel.arb"
   # arb finite volume solver
   # Copyright 2009,2010 Dalton Harvie (daltonh@unimelb.edu.au)
   #
   # arb is released under the GNU GPL.  For full details see the license directory.
   #
   #-------------------------------------------------------------------
   # file equations.in
   VERSION 0.53
   
   INFO_TITLE "Fully-developed electrokinetic flow"
   INFO_DESCRIPTION "Now setup for electroviscous flow with zero total current"
   INFO_AUTHOR "Dalton Harvie"
   INFO_DATE "22/4/15" # interpreted as the last modification date
   
   # choose coordinate system
   # for cartesian slit flow include the following:
      #(comment created during unwrap): new block = ../../templates/general/cartesian_x1y2.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE_TEMPLATE "general/cartesian_x1y2"
      #(hash inserted during unwrap)MARKDOWN
      #(hash inserted during unwrap)sets general replacements for cartesian 2D coordinates in the xy plane
      #(hash inserted during unwrap)END_MARKDOWN
      
      
      
   # as the centreline is horizontal need to include reflect=2 when differentiating of averaging any l=2 vector components
   INFO_DESCRIPTION+ ": cartesian slit flow"
   # for cylindrical pipe flow include the following:
   #INCLUDE_TEMPLATE "general/cylindrical_reflect_r2z1"
   #INFO_DESCRIPTION+ ": cylindrical pipe flow (note, analytical expressions are not correct for this yet)"
   
   # for both coordinate systems the centreline is normal to the x_2 (ie, y) axis, so glue this back on itself while setting the reflection direction to use
   GLUE_FACES <centreline> reflect=2 # glue the centreline back on itself (while reflecting the y indicies of the mesh), creating a horizontal axis of symmetry along the bottom of the domain
   
   #----------------------------------------------------------------------------
   # solver options
   
   # for electrokinetic problems, higher order kernels give significantly better results (these are now the default anyway)
   KERNEL_OPTIONS polynomialaverageorder=2,polynomialorder=2 # specifies that when averaging/differentiating quantities to/at faces, ensure that function fits a second order polynomial
   
   #-------------------------------------------------------------------
   # geometry
   
   # CELL_REGION/FACE_REGION specified by: <name> "location string" # comments
   # where location string could be: "AT x1 x2 x3" for a single point closest to these coordinates
   # where location string could be: "WITHIN BOX x1_min x2_min x3_min x1_max x2_max x3_max" for all elements within a box defined by the minimum and maximum coordinate values
   # where location string could be: "COMPOUND +<a region>-<another region>" for a + and - compound region list
   # where location string could be: "BOUNDARY OF <a region>" - boundary faces/cells contained within or surrounding <a region>
   # where location string could be: "DOMAIN OF <a region>" - domain faces/cells contained within <a region>
   # where location string could be: "ASSOCIATED WITH <a region>" - faces/cells both contained within and surrounding <a region>
   
   FACE_REGION <walls> "COMPOUND <boundaries>-<inlet>-<outlet>-<centreline>"
   FACE_REGION <outlet centreline> "AT 0.d0 0.d0 0.d0 PART OF <outlet>"
   FACE_REGION <outlet sans centreline> "COMPOUND <outlet>-<outlet centreline>"
   FACE_REGION <inlet centreline> "AT 0.d0 0.d0 0.d0 PART OF <inlet>"
   FACE_REGION <inlet sans centreline> "COMPOUND <inlet>-<inlet centreline>"
   
   # MSH_FILE instructs arb to read or write a gmsh file (location is read location - write location will always be within the output directory)
   # output options are: output,centringoutput,meshoutput,centringmeshoutput,nooutput
   # input options are: input,centringinput,meshinput,centringmeshinput,noinput
   # data output format options for CELL centred data (which overwrite individual variable options if specified): elementdata,elementnodedata,elementnodelimiteddata
   #MSH_FILE "electrokinetic_channel_structured.msh"
   MSH_FILE "electrokinetic_channel_structured_nonuniform.msh"
   #MSH_FILE "electrokinetic_channel_unstructured.msh"
   
   # use templates from the electrokinetics template directory to build up problem
   # use these for a dimensional problem
   #INCLUDE_TEMPLATE "navier_stokes"
   #INCLUDE "constants" # specify physical and numerical constants
   #INCLUDE_TEMPLATE "electrokinetics"
   #INCLUDE "constants" # and the same for the electrokinetic equations
   # or these for a nondimensional problem
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "navier_stokes"
      #(comment created during unwrap): new block = ../../templates/navier_stokes/nondimensional_constants.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "nondimensional_constants" # specify physical and numerical constants
      # use this constants file if solving nondimensionally
      
         #(comment created during unwrap): new block = ../../templates/navier_stokes/constants.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "constants"
         # physical data
         CONSTANT <mu> [Pa.s] 1.d-3 # viscosity of liquid
         CONSTANT <rho> [kg/m^3] 1.d0 # density
         CONSTANT <u_av> [m/s] 1.d0 # required average inlet velocity (if used, sets flowrate through inlet)
         
         #-------------
         # set default strings using the following template file, which sets up a steady-state solution to the navier-stokes equations, with uniform viscosity and density
         # see below for appropriate statements to change these decisions
         # these strings are used throughout the navier_stokes template files
         # strings can also be set when calling the template files using per-file replacements, although this isn't the standard way of implementing these settings
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, requires three things to be set for each option
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
         
         # use the following to setup a transient simulation
         #GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "" R "<<steadystatenavierstokescomment>>" W "#" R "<<transientnavierstokes>>" W "1"
         
         # could set the transient status based on what type of arb simulation it is, but inadvisable really as there are many instances when only a partial-transient simulation is desired
         #<<transientcomment>>GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "" R "<<steadystatenavierstokescomment>>" W "#" R "<<transientnavierstokes>>" W "1"
         #<<steadystatecomment>>GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "#" R "<<steadystatenavierstokescomment>>" W "" R "<<transientnavierstokes>>" W "0"
         
         # use the following to specify the stokes equations
         #GENERAL_REPLACEMENTS R "<<stokescomment>>" W "" R "<<navierstokescomment>>" W "#" R "<<stokes>>" W "1"
         
         # use the following to specify nonuniform viscosity
         #GENERAL_REPLACEMENTS R "<<uniformviscositycomment>>" W "#" R "<<nonuniformviscositycomment>>" W "" R "<<uniformviscosity>>" W "0"
         
         # use the following to specify nonuniform density
         #GENERAL_REPLACEMENTS R "<<uniformdensitycomment>>" W "#" R "<<nonuniformdensitycomment>>" W "" R "<<uniformdensity>>" W "0"
         #-------------
         
         # numerical data
         CONSTANT <C_{Rhie-Chow}> [] 1.0d+0 # multiplier for Rhie-Chow-type velocity interpolation
         CONSTANT <adv_limiter> [] 1.d0 # multiplier used to limit gradients when calculating advection fluxes
         
         # find an estimate of the domain size using general template
         #(hash inserted during unwrap)INCLUDE_TEMPLATE "general"
            #(comment created during unwrap): new block = ../../templates/general/domain_lengthscale.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "domain_lengthscale" # this will find the none constant <a_lengthscale>
            # find an estimate of the domain size
            # here we use the maximum domain length in each dimension
            # previously used a more accurate but expensive formulation (see minimum_face_boundary_distance)
               #(comment created during unwrap): new block = ../../templates/general/domain_lengths.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "domain_lengths" # this will find a constant vector domain length in each dimension
               # based on node locations, here we calculate the maximum length of the domain in each dimension
               # these loops could be conducted over <boundarynodes>, but although cheaper, this will break if the domain has no boundaries (ie, fully periodic)
               # as this is only a single loop through each node this isn't an expensive calculation anyway (unlike the levelset-based minimum boundary distance)
               NONE_CONSTANT <nodexmax[l=1]> "nodemax(<nodex[l=1]>,region=<allnodes>)"
               NONE_CONSTANT <nodexmax[l=2]> "nodemax(<nodex[l=2]>,region=<allnodes>)"
               #NONE_CONSTANT <nodexmax[l=3]> "nodemax(<nodex[l=3]>,region=<allnodes>)"
               NONE_CONSTANT <nodexmin[l=1]> "nodemin(<nodex[l=1]>,region=<allnodes>)"
               NONE_CONSTANT <nodexmin[l=2]> "nodemin(<nodex[l=2]>,region=<allnodes>)"
               #NONE_CONSTANT <nodexmin[l=3]> "nodemin(<nodex[l=3]>,region=<allnodes>)"
               NONE_CONSTANT <domain_length[l=1]> "<nodexmax[l=1]>-<nodexmin[l=1]>"
               NONE_CONSTANT <domain_length[l=2]> "<nodexmax[l=2]>-<nodexmin[l=2]>"
               #NONE_CONSTANT <domain_length[l=3]> "<nodexmax[l=3]>-<nodexmin[l=3]>"
            # this is based on a vector from the minimum to the maximum coordinates
            #NONE_CONSTANT <a_lengthscale> "sqrt(nonemax(dot(<domain_length[l=:]>,<domain_length[l=:]>),0.d0))"
            # this is based on the maximum domain length over the three dimensions
            NONE_CONSTANT <a_lengthscale> "nonemax(<domain_length[l=1]>,nonemax(<domain_length[l=2]>,<domain_length[l=3]>))"
         
         # for reference calculate some nondimensional quantities
         # these should be overwritten by real nondimensional quantities if this is a nondimensional problem
         CONSTANT <Re> "<u_av>*<rho>*<a_lengthscale>/<mu>" # Reynolds number
      
      # set Reynolds number here to a value so that it isn't left as a function of <mu> from constants
      CONSTANT <Re> [1] 1.d-2 # Reynolds number, overwrite this after this file is included
      
      # convert dimensional parameters to nondimensional
      # by default an inertial scaling of pressure is used, however this can be changed by presetting this variable
         #(comment created during unwrap): new block = ../../templates/navier_stokes/nondimensional_constants.arb: sub_block = 1
         #(hash inserted during unwrap)IF 1
         # the following produces a pressure which is inertially scalled (ie, p_nondim = p_dim/(density*velocity^2)
         CONSTANT <mu> "1.d0/<Re>"
         CONSTANT <rho> 1.d0
         #(comment created during unwrap): new block = ../../templates/navier_stokes/nondimensional_constants.arb: sub_block = 1
         #(hash inserted during unwrap)ELSE
         #(hash inserted during unwrap)# the following should produce a pressure which is viscous scalled (ie, p_nondim = p_dim*length/(viscosity*velocity))
         #(hash inserted during unwrap)CONSTANT <mu> 1.d0
         #(hash inserted during unwrap)CONSTANT <rho> "<Re>"
         #(hash inserted during unwrap)END_IF
      CONSTANT <u_av> 1.d0
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "electrokinetics"
      #(comment created during unwrap): new block = ../../templates/electrokinetics/nondimensional_constants.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "nondimensional_constants" # and the same for the electrokinetic equations
      # general setup for nondimensional electrokinetic problems
      
         #(comment created during unwrap): new block = ../../templates/electrokinetics/constants.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "constants"
         # general setup for electrokinetic problems
         
         CONSTANT <average ion n molarity> [molarity] 1.d-3 # molarity = mol/l
         CONSTANT <T> [K] 298.15 # temperature
         CONSTANT <eps_fluid> [1] 78.0d0 # relatic static permittivity
         CONSTANT <wall charge> [C/m^2] -60.d-3 # wall surface charge
         CONSTANT <I_total> [A] 0.d0 # specify the total amount of current flowing through the inlet.  Default is for electroviscous flow
         CONSTANT <average ion D> [m^2/s] 1.d-9 # average ion diffusivities
         CONSTANT <average ion z> [1] 1.d0 # average ion valency magnitude
         
         # fundamental constants
         CONSTANT <e> [C] 1.60210d-19 # charge of an electron
         CONSTANT <N_A> [1/mol] 6.02252d23 # avogadro's number
         CONSTANT <eps_o> [F/m] 8.854187817d-12 # vacuum permittivity
         CONSTANT <k> [J/K] 1.38054d-23 # boltzmann's constant
         
         # some derived constants
         CONSTANT <average ion n> [molecules/m^3] "<average ion n molarity>*<N_A>*1.d3" # note units
         CONSTANT <e/kT> "<e>/(<k>*<T>)" # this is a dummy variable that is only used in the dimensional form of the equations
         CONSTANT <K^2/2> [1] 1.d0 # this is a dummy variable that is only used in the nondimensional form of the equations
         CONSTANT <BK^2/Re^2> [1] 1.d0 # this is a dummy variable that is only used in the nondimensional form of the equations
         
         # for reference and possible use in estimate_initial_potential, calculate some nondimensional quantities
         # these should be overwritten by real nondimensional quantities if this is a nondimensional problem
         # assumes that <a_lengthscale> has been calculated previously (probably within navier-stokes constants file)
         
         CONSTANT <K> "<a_lengthscale>*sqrt(2.d0*<e>^2*<average ion z>^2*<average ion n>/(<eps_o>*<eps_fluid>*<k>*<T>))" # nondimensional channel half-width
         CONSTANT <S> "<wall charge>*<e>*<average ion z>*<a_lengthscale>/(<eps_o>*<eps_fluid>*<k>*<T>)" # nondimensional surface charge
      
      # physical data
      CONSTANT <Re> [1] 1.d-2 # Reynolds number.  Overwrites value set in nondimensional_constants
      CONSTANT <Sc> [1] 1.d+3 # Schmidt number
      CONSTANT <B> [1] 2.34d-4 # B number
      CONSTANT <K> [1] 1.d-1 # K
      CONSTANT <S> [1] -2.d+1 # S (signed)
      CONSTANT <I_total> [1] 0.d0 # total current passing through domain
      
      # calculate derived constants and make dummy ones unity
      CONSTANT <u_av> [1] 1.d0
      CONSTANT <average ion n> [1] 1.d0
      CONSTANT <Pe> [1] "<Re>*<Sc>" # Peclet number
      CONSTANT <average ion D> [1] "1/<Pe>"
      CONSTANT <K^2/2> [1] "<K>^2/2.d0"
      CONSTANT <BK^2/Re^2> [1] "<B>*<K>^2/(<Re>^2)"
      CONSTANT <eps_fluid> [1] 1.d0
      CONSTANT <wall charge> [1] "<S>"
      CONSTANT <e> [1] 1.d0
      CONSTANT <eps_o> [1] 1.d0
      CONSTANT <e/kT> [1] 1.d0
      
      # zero some undefined dimensional constants
      CONSTANT <average ion n molarity> 0.d0
      CONSTANT <T> 0.d0
      
      # lengthscale of the mesh - for nondimensional problems this needs to be 1
      CONSTANT <a_lengthscale> "1.d0"
   
   # some concentrations and charges required in other equations, and also the face centred potential required in the dynamic_force calculation
      #(comment created during unwrap): new block = ../../templates/electrokinetics/binary_ion_combinations.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "binary_ion_combinations"
      # these are relationships that involve combinations of ion properties
      # here they are specific to a binary system of <ion+ n> and <ion- n>, so need overwriting for more complex systems
      # include this early on, before p_error inclusion
      
      # include positive ion concentrations
         #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_concentrations.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "ion_concentrations" 
         
         # these are some derived concentrations
         
         CELL_LOCAL <ion+ n pos> "cellmax(<ion+ n>,0.d0)"
         FACE_DERIVED <ion+ n_hf> "faceave[harmonicweighted](<ion+ n pos>)" ON <allfaces> # face centred concentrations used in pressure correction (p_error) and in nernst-planck ion transport
         #FACE_DERIVED <ion n_hf> "faceave[harmonic](<ion n pos>)" ON <allfaces>
      # include negative ion concentrations
         #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_concentrations.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "ion_concentrations" 
         
         # these are some derived concentrations
         
         CELL_LOCAL <ion- n pos> "cellmax(<ion- n>,0.d0)"
         FACE_DERIVED <ion- n_hf> "faceave[harmonicweighted](<ion- n pos>)" ON <allfaces> # face centred concentrations used in pressure correction (p_error) and in nernst-planck ion transport
         #FACE_DERIVED <ion n_hf> "faceave[harmonic](<ion n pos>)" ON <allfaces>
      
      # also define the following locals
      CELL_LOCAL <rho_e> "<e>*(<ion+ z>*<ion+ n>+<ion- z>*<ion- n>)" ON <allcells> # used on right of poisson equation
      CELL_LOCAL <rho_e pos> "<e>*(<ion+ z>*<ion+ n pos>+<ion- z>*<ion- n pos>)" ON <allcells> # used in momentum balance (navier-stokes)
      FACE_LOCAL <rho_e_hf> "<e>*(<ion+ z>*<ion+ n_hf>+<ion- z>*<ion- n_hf>)" ON <allfaces> output
      CELL_LOCAL <n_0^2 signed> "cellmin(<ion+ n>,<ion- n>)*abs(cellmax(<ion+ n>,<ion- n>))" ON <allcells>
      
      # for error checking
      #CELL_OUTPUT <rho_e error> "<rho_e>-<rho_e pos>" ON <allcells>
      
      # this face-averaged potential is needed early on in the derived calculations (for dynamic_force_c) so include it here
      FACE_DERIVED <U_f> "faceave(<U>)" ON <allfaces> # this is needed in <dynamic_force_c> which will be calculated in p_error_dxunit
   
   # now the flow parts
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "navier_stokes"
      #(comment created during unwrap): new block = ../../templates/navier_stokes/domain.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "domain"
         #(comment created during unwrap): new block = ../../templates/navier_stokes/unknowns.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "unknowns" # no .arb suffix is required
         # unknown variables used for flow problems
         CELL_UNKNOWN <u[l=1]> [] "0.d0" ON <allcells> magnitude=1.d0 # velocity component
         CELL_UNKNOWN <u[l=2]> [] "0.d0" ON <allcells> magnitude=1.d0 # velocity component
         #CELL_UNKNOWN <u[l=3]> [] "0.d0" ON <allcells> magnitude=1.d0 # velocity component
         CELL_UNKNOWN <p> [] "1.d0" ON <allcells> # pressure
         #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "total_stress"
         # total stress tensor
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_gradient_tensor.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "u_gradient_tensor"
            # a tensor of face centred gradients that respects any reflections
            # used in the total stress and boundary conditions now
            # as per conventional tensor notation, the first index is the derivative direction, and the second is the velocity direction
            FACE_DERIVED <ugrad_f[l=1,1]> "facegrad[l=1,](<u[l=1]>)" ON <allfaces>
            FACE_DERIVED <ugrad_f[l=1,2]> "facegrad[l=1,reflect=2](<u[l=2]>)" ON <allfaces>
            #FACE_DERIVED <ugrad_f[l=1,3]> "facegrad[l=1,](<u[l=3]>)" ON <allfaces>
            FACE_DERIVED <ugrad_f[l=2,1]> "facegrad[l=2,](<u[l=1]>)" ON <allfaces>
            FACE_DERIVED <ugrad_f[l=2,2]> "facegrad[l=2,reflect=2](<u[l=2]>)" ON <allfaces>
            #FACE_DERIVED <ugrad_f[l=2,3]> "facegrad[l=2,](<u[l=3]>)" ON <allfaces>
            #FACE_DERIVED <ugrad_f[l=3,1]> "facegrad[l=3,](<u[l=1]>)" ON <allfaces>
            #FACE_DERIVED <ugrad_f[l=3,2]> "facegrad[l=3,reflect=2](<u[l=2]>)" ON <allfaces>
            #               FACE_DERIVED <ugrad_f[l=3,3]> "facegrad[l=3,](<u[l=3]>)" ON <allfaces>
         
         # if the numerical velocity divergence is to be included in the stress calculation replace this string with an empty character prior to calling this template
         
         # calculate the velocity divergence (numerical) on each face
         #FACE_DERIVED <udiv_f> "<ugrad_f[l=1,1]>+<ugrad_f[l=2,2]>+<ugrad_f[l=3,3]>" ON <allfaces>
         
         # deal with uniform/nonuniform viscosity, allowing for possibility of user setting <mu_f> directly
         # if you want to overwrite <mu_f>, just define it prior to calling this file and your replacement will overwrite the following
         # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1  # this evaluates as true (1) if replacement string '<mu_f>' isn't defined, AND <<uniformviscosity>> is on (1)
            # if we are here then we apply the uniform viscosity substitution, with 'S'='SUBSTITUTE' meaning to replace the value of this string in its previous (above code block here) definition
            #(hash inserted during unwrap)END_IF
         #{{ print "IN template total_stress\n".string_debug; }}
         
         # no both cartesian and cylindrical stresses don't include pressure
         # without the numerical velocity divergence
         FACE_LOCAL <tau[l=1,1]> "-<mu>*2.d0*<ugrad_f[l=1,1]>" ON <allfaces>
         FACE_LOCAL <tau[l=2,2]> "-<mu>*2.d0*<ugrad_f[l=2,2]>" ON <allfaces>
         #FACE_LOCAL <tau[l=3,3]> "-<mu>*2.d0*<ugrad_f[l=3,3]>" ON <allfaces>
         # overwrite these if the numerical velocity divergence is to be included, see <<udivfcomment>> string replacement above
         # Note: "<udiv_f>/3.d0" is specifically replaced in strain_rate_magnitude template
         #FACE_LOCAL <tau[l=1,1]> "-<mu>*2.d0*(<ugrad_f[l=1,1]>-<udiv_f>/3.d0)" ON <allfaces>
         #FACE_LOCAL <tau[l=2,2]> "-<mu>*2.d0*(<ugrad_f[l=2,2]>-<udiv_f>/3.d0)" ON <allfaces>
         ##FACE_LOCAL <tau[l=3,3]> "-<mu>*2.d0*(<ugrad_f[l=3,3]>-<udiv_f>/3.d0)" ON <allfaces>
         FACE_LOCAL <tau[l=1,2]> "-<mu>*(<ugrad_f[l=1,2]>+<ugrad_f[l=2,1]>)" ON <allfaces>
         #FACE_LOCAL <tau[l=1,3]> "-<mu>*(<ugrad_f[l=1,3]>+<ugrad_f[l=3,1]>)" ON <allfaces>
         #FACE_LOCAL <tau[l=2,3]> "-<mu>*(<ugrad_f[l=2,3]>+<ugrad_f[l=3,2]>)" ON <allfaces>
         FACE_LOCAL <tau[l=2,1]> "<tau[l=1,2]>" ON <allfaces>
         #FACE_LOCAL <tau[l=3,1]> "<tau[l=1,3]>" ON <allfaces>
         #FACE_LOCAL <tau[l=3,2]> "<tau[l=2,3]>" ON <allfaces>
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "u_f"
         # interpolate the cell centred velocity to the faces and find the velocity (flux) normal to the face (<u_f>), using a rhie-chow spirited interpolation technique on the domain faces
         
         # check default strings are set
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, requires three things to be set for each option
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
         
         # start by calculating the difference between the local face centred (dynamic) pressure gradient and average of cell centred (dynamic) pressure gradients in the face direction
         # `dynamic' pressure here means the pressure that is able to cause fluid flow, ie, possibly accounting for hydrostatic pressure variations (for example)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "p_error"
            # a Rhie-Chow-type velocity interpolation is applied to the face flux velocities
            # pressure gradient calculated via a divergence (consistent with momentum conservation) (on boundary cells values from the adjacent domain cells will be used)
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "dynamic_force" # cell centred dynamic force
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)dynamic force is the pressure force that could cause fluid movement
               #(hash inserted during unwrap)it is added directly to the momentum equations, and used in calculating p_error used in the face velocity interpolation
               #(hash inserted during unwrap)dynamic force now has the physically correct sign!
               #(hash inserted during unwrap)<dynamic_force_f> is calculated within <p_error>, which this file is called from
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)Other dynamic_force templates (eg, vof, electrokinetics) increment <dynamic_force_c[l=:]> set in this file, as well as <dynamic_force_f>
               #(hash inserted during unwrap)END_MARKDOWN
               
               #FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "p_f"
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Here we average the cell centred pressure <p> to the faces producing <p_f>.  The standard method is to use arithmetic averaging, as in
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)Low order averaging adjacentcell averaging uses a distance weighted average of the adjacent cell values.  Select this by setting
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)High order adjacentcell averaging is as per low order adjacentcell averaging, except that the gradient within each cell is used to get a better estimate of the pressure on each side of the interface.  The amount of gradient used is set by `<p_f_grad_limiter>` which should be between 0.d0 (low order) and 1.d0 after the file is included.  To use this high order averaging set
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter> 1.d0 # keep this between 0.d0 and 1.d0
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # this is the default pressure interpolation
                  FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
                  
                  # the following are based on averaging from the adjacentcells only, but possibly using high order averaging
                  
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcells](<p>)" output
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 0
                     #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter> 1.d0 # ranging from 1.d0 (highest order) to 0.d0 which will give same as <<pfadjacentcells>> above
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 1
                        #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcells](cellave[lastface](faceave[advection](<p>,<facefromcelldirection>,<p_f_gradient_limiter>)))" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE_IF 0
                        #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcellsevenweighting](cellave[lastface](faceave[advection](<p>,<facefromcelldirection>,<p_f_gradient_limiter>)))" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)VARIABLE <p_f> "0.5d0*(faceave[advection](<p>,1.d0,<p_f_gradient_limiter>)+faceave[advection](<p>,-1.d0,<p_f_gradient_limiter>))" output
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 1
                           #(hash inserted during unwrap)VARIABLE <p_f> "faceif(facedelta(<boundaries>),<p>,<p_f>)" # special case boundary face pressure value to be equal to boundary cell value.  Without this the boundary pressure will be equally weighted.
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)END_IF
               CELL_DERIVED <dynamic_force_c[l=1]> "-celldivgrad[l=1](<p_f>)" ON <allcells>
               CELL_DERIVED <dynamic_force_c[l=2]> "-celldivgrad[l=2](<p_f>)" ON <allcells>
               #CELL_DERIVED <dynamic_force_c[l=3]> "-celldivgrad[l=3](<p_f>)" ON <allcells>
            
            # seems that using <dynamic_force_c_f[l=:]> usually consumes more memory and takes more time to compute, so remove it by default by including the following
            # in the far off future if nobody complains <dynamic_force_c_f[l=:]> may just disappear into the night
            # to bring back <dynamic_force_c_f[l=:]> set this string to empty using a general replacement or on calling
            # nodynamicforcecf should work with reflections, but not tested like heaps and heaps and heaps yet
            
            # set the opposite automatically
            
            #GENERAL_REPLACEMENTS R "" W "#"
            
            # for evaluating the face centred dynamic force there are three options: dxunit, facegrad and adjacentcells
            # uncomment the comment string corresponding to the one you want
            # default is dxunit
            # remember to set all of these strings on entry if changing from the default, with only the requested one uncommented
            
            
            # calculate <dynamic_force_c_f[l=:]> if requested
            # interpolation to face centres (for velocity correction) could be done using normal, adjacentcells or adjacentcellsevenweighting, but they're all about the same so choose the computationally simplest
            #FACE_LOCAL <dynamic_force_c_f[l=1]> "faceave[,adjacentcells](<dynamic_force_c[l=1]>)"
            #FACE_LOCAL <dynamic_force_c_f[l=2]> "faceave[reflect=2,adjacentcells](<dynamic_force_c[l=2]>)"
            ##FACE_LOCAL <dynamic_force_c_f[l=3]> "faceave[,adjacentcells](<dynamic_force_c[l=3]>)"
            
            # dxunit method
            FACE_LOCAL <dynamic_force_f> "-facegrad[dxunit](<p>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
            FACE_CONSTANT <dot_facenorm_facedxunit> "dot(<facenorm[l=:]>,<facedxunit[l=:]>)" ON <domainfaces>
            # dxunit + dynamicforcecf
            #FACE_DERIVED <p_error> "(-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facedxunit[l=:]>))*<dot_facenorm_facedxunit>" ON <domainfaces>
            # dxunit - dynamicforcecf
            # lastface is required when averaging the normal when we have periodic gluing, as we require the normal to be orientated relative to the original face, rather than its glued counterpart - this is now the default when cycling through the region adjacentfaceicells, which is used by faceave[adjacentcells]
            # for reflect gluing, <p_error> is zero anyway
            FACE_DERIVED <p_error> "faceif(<facereflectnorm>,(-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <domainfaces>
            
            # facegrad method
            #FACE_LOCAL <dynamic_force_f> "-facegrad(<p>)" ON <allfaces>
            # facegrad + dynamicforcecf
            ##FACE_DERIVED <p_error> "-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facenorm[l=:]>)" ON <domainfaces>
            # facegrad - dynamicforcecf
            #FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
            
            # adjacentcells method
            #FACE_LOCAL <dynamic_force_f> "-facegrad[adjacentcells](<p>)" ON <allfaces>
            # adjacentcells + dynamicforcecf
            ##FACE_DERIVED <p_error> "-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facenorm[l=:]>)" ON <domainfaces>
            # adjacentcells - dynamicforcecf
            #FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
            
            # the following are two template lines for setting the strings prior to entering this file
            #GENERAL_REPLACEMENTS R "<<dynamicforcecfcomment>>" W "#"
            #GENERAL_REPLACEMENTS R "<<dynamicforcefdxunitcomment>>" W "#" R "<<dynamicforceffacegradcomment>>" W "#" R "<<dynamicforcefadjacentcellscomment>>" W "#"
            
         
         FACE_LOCAL <u_f_vect[l=1]> "faceave[](<u[l=1]>)"
         FACE_LOCAL <u_f_vect[l=2]> "faceave[reflect=2](<u[l=2]>)"
         #FACE_LOCAL <u_f_vect[l=3]> "faceave[](<u[l=3]>)"
         FACE_DERIVED <u_f_{raw}> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" ON <allfaces> # volume (velocity) transport
         
         # this file now does both steady-state and transient using transient comments string replacements, which are set in constants.arb
         
         # save old correction velocity for transient calculations
         #FACE_TRANSIENT <u_f_{correction}[r=1]> "0.d0" "<u_f_{correction}>" ON <domainfaces>
         
         # assemble <u_f_{correction}>, taking advantage of variable reuse so that only one expression is formed for <u_f_{correction}> (to maximise code efficiency and maxima expression simplifications)
         
         # first assemble demoninator of expression:
         
         # all equation variants here have viscous contribution, so add this first
         # the rf stands for reciprocal and face centred
         # same piece of code as in total_stress to deal with <mu_f> replacement
         # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1  # this evaluates as true (1) if replacement string '<mu_f>' isn't defined, AND <<uniformviscosity>> is on (1)
            # if we are here then we apply the uniform viscosity substitution
            #(hash inserted during unwrap)END_IF
         FACE_LOCAL <u_rf_{vis}> "<mu>/<facedx>^2" ON <domainfaces>
         FACE_DERIVED <u_f_{correction}> "<u_rf_{vis}>" ON <domainfaces>
         
         # advective contribution can be either simple or more complex (set by <<ufadvectioncomplexcomment>>)
         # the default behaviour is to use the simple advective contribution
         
         # include the following line in your input file prior to loading this template file to access the more complex contribution
         #GENERAL_REPLACEMENTS R <<ufadvectioncomplexcomment>> W ""
         
         # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1  # this evaluates as true (1) if replacement string '<rho_f>' isn't defined, AND <<uniformviscosity>> is on (1)
            # if we are here then we apply the uniform density substitution
            #(hash inserted during unwrap)END_IF
         # form opposite string to be consistent with <<ufadvectioncomplexcomment>> 
         
         #GENERAL_REPLACEMENTS R  W "#" 
         # next add simple advective contribution (which really assumes that locally |<u_f_{raw}>| >> |<u_f_{correction}>|
         FACE_LOCAL <u_rf_{adv}> "2.d0*<rho>*abs(<u_f_{raw}>)/<facedx>" ON <domainfaces>
         # or more complex variant, which does not assume generally small correction velocities (and under steady-state conditions is equivalent to what was used pre v0.55) but is more expensive to compute, for what seems like little practical gain.  There is some evidence that the more complex variant can allow steady-state sims to converge more as Re increases, but very very marginal.
         #FACE_LOCAL <eps_p> "facemax(abs(<p_error>),<tinyish>)" ON <domainfaces>
         #FACE_LOCAL <u_rf_{adv}> "<eps_p>/(-abs(<u_f_{raw}>)+sqrt(<u_f_{raw}>^2+<eps_p>*<facedx>/<rho>))" ON <domainfaces>
         
         FACE_DERIVED <u_f_{correction}> "<u_f_{correction}>+<u_rf_{adv}>"
         
         # for transient, add transient component to demoninator, take reciprocal, and add top transient and pressure contributions
         #FACE_LOCAL <u_rf_{transient}> "<rho>/<dt>" ON <domainfaces>
         #FACE_DERIVED <u_f_{correction}> "(-<C_{Rhie-Chow}>*<p_error>+<u_rf_{transient}>*<u_f_{correction}[r=1]>)/(<u_f_{correction}>+<u_rf_{transient}>)"
         # for steady-state just take reciprocal and add pressure contribution
         FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<p_error>/(<u_f_{correction}>)"
         
         # final face velocity
         FACE_DERIVED <u_f> "<u_f_{raw}>+faceif(facedelta(<domainfaces>),<u_f_{correction}>,0.d0)" ON <allfaces> # volume (velocity) transport
         
         # this section just re-works the implicit timestepping equation to allow a newtstepmax to be applied to <dt_target>
         # save a derived copy of <dt_target> after <u_f> has been calculated so that we can apply newtstepmax to it
         # if <<implicittimestepcomment>> hasn't already been set then set it here (to off) - for on will have already required dynamic timestepping to be on
         
         ##NONE_DERIVED <dt_target_derived> "<dt_target>" newtstepmax=10
         ##NONE_EQUATION <dt implicit equation> "<dt>-<dt_target_derived>"
         #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "advection_flux" # even though this is called for the stokes equations, no terms will be created
         # flux of momentum over and in the direction of each face due to advection
         # which one is chosen depends on the comment strings
         # all require navierstokes equations to be current
         
         # check default strings are set
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, requires three things to be set for each option
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
         
         
         # steady-state and uniform density
         FACE_LOCAL <J_advection_f[l=1]> "<rho>*faceave[advection,](<u[l=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         FACE_LOCAL <J_advection_f[l=2]> "<rho>*faceave[advection,reflect=2](<u[l=2]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         #FACE_LOCAL <J_advection_f[l=3]> "<rho>*faceave[advection,](<u[l=3]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         # steady-state and varying density
         #FACE_LOCAL <J_advection_f[l=1]> "faceave[advection,](<rho>*<u[l=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         #FACE_LOCAL <J_advection_f[l=2]> "faceave[advection,reflect=2](<rho>*<u[l=2]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         ##FACE_LOCAL <J_advection_f[l=3]> "faceave[advection,](<rho>*<u[l=3]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         # transient and uniform density
         #FACE_LOCAL <J_advection_f[l=1]> "<rho>*faceave[advection,](<u[l=1,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         #FACE_LOCAL <J_advection_f[l=2]> "<rho>*faceave[advection,reflect=2](<u[l=2,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         ##FACE_LOCAL <J_advection_f[l=3]> "<rho>*faceave[advection,](<u[l=3,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         # transient and varying density
         ##FACE_LOCAL <J_advection_f[l=1]> "faceave[advection,](<rho[r=1]>*<u[l=1,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         ##FACE_LOCAL <J_advection_f[l=2]> "faceave[advection,reflect=2](<rho[r=1]>*<u[l=2,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         ###FACE_LOCAL <J_advection_f[l=3]> "faceave[advection,](<rho[r=1]>*<u[l=3,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         #(comment created during unwrap): new block = ../../templates/navier_stokes/momentum_flux.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "momentum_flux"
         # flux of momentum over and in the direction of each face
         
         # check default strings are set
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, requires three things to be set for each option
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
         
         # start by placing in viscous momentum transport, applicable to both the stokes and navier-stokes equations
         FACE_DERIVED <J_f[l=1]> "dot(<facenorm[l=:]>,<tau[l=:,1]>)" ON <allfaces>
         FACE_DERIVED <J_f[l=2]> "dot(<facenorm[l=:]>,<tau[l=:,2]>)" ON <allfaces>
         #FACE_DERIVED <J_f[l=3]> "dot(<facenorm[l=:]>,<tau[l=:,3]>)" ON <allfaces>
         
         # and now add advection momentum transport for just the navier-stokes equations using self-referencing
         VARIABLE <J_f[l=1]> "<J_f[l=1]>+<J_advection_f[l=1]>"
         VARIABLE <J_f[l=2]> "<J_f[l=2]>+<J_advection_f[l=2]>"
         #VARIABLE <J_f[l=3]> "<J_f[l=3]>+<J_advection_f[l=3]>"
         #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "conservation"
         # conservation equations solved over each domain cell (finite volume method)
         
         # check default strings are set
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, requires three things to be set for each option
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 1
            #(hash inserted during unwrap)IF 0
            #(hash inserted during unwrap)# old way
            #(hash inserted during unwrap)# cartesian specific
            #(hash inserted during unwrap)CELL_EQUATION <continuity> "celldiv(<u_f>)" ON <domain> # continuity
            #(hash inserted during unwrap)CELL_EQUATION <momentum[l=1]> "celldiv(<J_f[l=1]>)-<dynamic_force_c[l=1]>" ON <domain> # momentum component
            #(hash inserted during unwrap)CELL_EQUATION <momentum[l=2]> "celldiv(<J_f[l=2]>)-<dynamic_force_c[l=2]>" ON <domain> # momentum component
            #(hash inserted during unwrap)#CELL_EQUATION <momentum[l=3]> "celldiv(<J_f[l=3]>)-<dynamic_force_c[l=3]>" ON <domain> # momentum component
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)# cylindrical specific
            #(hash inserted during unwrap)#CELL_EQUATION <continuity> "celldiv(1.d0*<u_f>)/1.d0" ON <domain> # continuity
            #(hash inserted during unwrap)# these also include the hoop stress terms when <<radiusdim?flag>> is appropriately set
            #(hash inserted during unwrap)#CELL_EQUATION <momentum[l=1]> "celldiv(1.d0*<J_f[l=1]>)/1.d0-<dynamic_force_c[l=1]>+0*2.d0*<u[l=1]>*<mu>/(<cellx[l=1]>**2)" ON <domain> # momentum component
            #(hash inserted during unwrap)#CELL_EQUATION <momentum[l=2]> "celldiv(1.d0*<J_f[l=2]>)/1.d0-<dynamic_force_c[l=2]>+0*2.d0*<u[l=2]>*<mu>/(<cellx[l=2]>**2)" ON <domain> # momentum component
            #(hash inserted during unwrap)##CELL_EQUATION <momentum[l=3]> "celldiv(1.d0*<J_f[l=3]>)/1.d0-<dynamic_force_c[l=3]>+0*2.d0*<u[l=3]>*<mu>/(<cellx[l=3]>**2)" ON <domain> # momentum component
            #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 1
            #(hash inserted during unwrap)ELSE
            # compact way, with hoop stress calculated more efficiently
            
            # define cylindrical divergence modifier terms
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)END_IF
            
            # now create equations
            CELL_EQUATION <continuity> "celldiv(<u_f>)" ON <domain> # continuity
            CELL_EQUATION <momentum[l=1]> "celldiv(<J_f[l=1]>)-<dynamic_force_c[l=1]>" ON <domain> # momentum component
            CELL_EQUATION <momentum[l=2]> "celldiv(<J_f[l=2]>)-<dynamic_force_c[l=2]>" ON <domain> # momentum component
            
            
            # add on hoop stress term separately for cylindrical coordinates
               #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)# perform a check that <<radialdim>> has been correctly defined
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)ERROR 'This is a cylindrical coordinate simulation however the string 0 has not been correctly defined'
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)VARIABLE <momentum[l=0]> "<momentum[l=0]>+2.d0*<u[l=0]>*<mu>/(<cellx[l=0]>**2)"
               #(hash inserted during unwrap)END_IF
            #(hash inserted during unwrap)END_IF
         
         # add transient term which is independent on cartesian or cylindrical coordinates
         #VARIABLE <momentum[l=1]> "<rho>*(<u[l=1]>-<u[l=1,r=1]>)/<dt>+<momentum[l=1]>"
         #VARIABLE <momentum[l=2]> "<rho>*(<u[l=2]>-<u[l=2,r=1]>)/<dt>+<momentum[l=2]>"
         ##VARIABLE <momentum[l=3]> "<rho>*(<u[l=3]>-<u[l=3,r=1]>)/<dt>+<momentum[l=3]>"
         ##VARIABLE <momentum[l=1]> "(<rho>*<u[l=1]>-<rho[r=1]>*<u[l=1,r=1]>)/<dt>+<momentum[l=1]>"
         ##VARIABLE <momentum[l=2]> "(<rho>*<u[l=2]>-<rho[r=1]>*<u[l=2,r=1]>)/<dt>+<momentum[l=2]>"
         ###VARIABLE <momentum[l=3]> "(<rho>*<u[l=3]>-<rho[r=1]>*<u[l=3,r=1]>)/<dt>+<momentum[l=3]>"
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "electrokinetics"
      #(comment created during unwrap): new block = ../../templates/electrokinetics/dynamic_force.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "dynamic_force" # overwrite the dynamic_force used in the navier-stokes equations to include an electrical forcing term
      #(hash inserted during unwrap)MARKDOWN
      #(hash inserted during unwrap)This increments the dynamic forces calculated for the navier_stokes equations to include the electrical forcing terms
      #(hash inserted during unwrap)dynamic force is included in the navier-stokes conservation equations, so they don't need any other modification
      #(hash inserted during unwrap)<U_f> should also be defined previously
      #(hash inserted during unwrap)END_MARKDOWN
      
      VARIABLE <dynamic_force_c[l=1]> "<dynamic_force_c[l=1]>-<BK^2/Re^2>*<rho_e pos>*celldivgrad[l=1](<U_f>)"
      VARIABLE <dynamic_force_c[l=2]> "<dynamic_force_c[l=2]>-<BK^2/Re^2>*<rho_e pos>*celldivgrad[l=2](<U_f>)"
      #VARIABLE <dynamic_force_c[l=3]> "<dynamic_force_c[l=3]>-<BK^2/Re^2>*<rho_e pos>*celldivgrad[l=3](<U_f>)"
      
      # method of incrementing <dynamic_force_f> needs to be consistent with the method chosen in navier_stokes/p_error
      # use the strings set in navier_stokes/p_error to define this method
      
      # dxunit method
      VARIABLE <dynamic_force_f> "<dynamic_force_f>-<BK^2/Re^2>*<rho_e_hf>*facegrad[dxunit](<U>)"
      # facegrad method
      #VARIABLE <dynamic_force_f> "<dynamic_force_f>-<BK^2/Re^2>*<rho_e_hf>*facegrad(<U>)" ON <allfaces>
      # adjacentcells method
      #VARIABLE <dynamic_force_f> "<dynamic_force_f>-<BK^2/Re^2>*<rho_e_hf>*facegrad[adjacentcells](<U>)"
   
   # and the flow boundary conditions
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "navier_stokes"
      #(comment created during unwrap): new block = ../../templates/navier_stokes/walls_noslip.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "walls_noslip" # nonslip walls BC
      # boundary conditions on nonslip walls
         #(comment created during unwrap): new block = ../../templates/navier_stokes/noflux.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "noflux" 
         
         FACE_EQUATION <walls noflux> "<u_f>" ON <walls> # no flux normal to region
         #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "noslip" 
         # noslip now detects whether it is a 3D or 2D problem
         FACE_EQUATION <walls noslip1> "dot(<u_f_vect[l=:]>,<facetang1[l=:]>)" ON <walls> # no component tangential to the face
         #FACE_EQUATION <walls noslip2> "dot(<u_f_vect[l=:]>,<facetang2[l=:]>)" ON <walls> # no component tangential to the face in the second tangential direction
         #(comment created during unwrap): new block = ../../templates/navier_stokes/p_extrapolation.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "p_extrapolation" 
         
         FACE_EQUATION <walls p_extrapolation> "<dynamic_force_f>" ON <walls> # pressure gradient next to wall set so that dynamic pressure gradient inext to wall is zero
      #(comment created during unwrap): new block = ../../templates/navier_stokes/inlet_u_fully_developed.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "inlet_u_fully_developed" # fully developed velocity profile, setting a uniform pressure gradient to give using <u_av>
      # boundary conditions on inlet - fully developed flow
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_fully_developed.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
         
         #FACE_EQUATION <equation> "facegrad(dot(<u[l=:]>,cellave[lastface](<facenorm[l=:]>)))" ON <region> # normal velocity component is fully developed
         FACE_EQUATION <inlet fully developed> "ddot(<ugrad_f[l=:,:]>,<facenorm[l=:]>*<facenorm[l=:]>)" ON <inlet> # normal velocity component is fully developed
         #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "noslip" 
         
         FACE_EQUATION <inlet no slip1> "dot(<u_f_vect[l=:]>,<facetang1[l=:]>)" ON <inlet> # no component tangential to the face
         #FACE_EQUATION <inlet no slip2> "dot(<u_f_vect[l=:]>,<facetang2[l=:]>)" ON <inlet> # no component tangential to the face in the second tangential direction
      
      # alternatively, set uniform inlet pressure giving required average velocity
      NONE_DERIVED <u_av_calc> "facesum(-<u_f>*<facearea>,<inlet>)/facesum(<facearea>,<inlet>)" # calculate average velocity directed into the domain
      #NONE_DERIVED <u_av_calc> "facesum(-<u_f>*<facearea>*1.d0,<inlet>)/facesum(<facearea>*1.d0,<inlet>)" # calculate average velocity directed into the domain
      
      # now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <inlet sans centreline> and <inlet centreline> (from eg inlet_centreline_region template)
      NONE_EQUATION <inlet centreline flowrate equation> "<u_av_calc>-<u_av>" # set flowrate through inlet to give required average velocity
      NONE_DERIVED <inlet centreline gradp> "facesum(<dynamic_force_f>,region=<inlet centreline>)"
      FACE_EQUATION <inlet flowrate equation> "<dynamic_force_f>-<inlet centreline gradp>" ON <inlet sans centreline> # apply specified pressure over inlet
      #(comment created during unwrap): new block = ../../templates/navier_stokes/outlet_u_fully_developed.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "outlet_u_fully_developed" # fully developed velocity profile, setting pressure at centreline to zero and a uniform pressure gradient
      # boundary conditions on outlet - fully developed flow
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_fully_developed.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
         
         #FACE_EQUATION <equation> "facegrad(dot(<u[l=:]>,cellave[lastface](<facenorm[l=:]>)))" ON <region> # normal velocity component is fully developed
         FACE_EQUATION <outlet fully developed> "ddot(<ugrad_f[l=:,:]>,<facenorm[l=:]>*<facenorm[l=:]>)" ON <outlet> # normal velocity component is fully developed
         #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "noslip" 
         
         FACE_EQUATION <outlet no slip1> "dot(<u_f_vect[l=:]>,<facetang1[l=:]>)" ON <outlet> # no component tangential to the face
         #FACE_EQUATION <outlet no slip2> "dot(<u_f_vect[l=:]>,<facetang2[l=:]>)" ON <outlet> # no component tangential to the face in the second tangential direction
      
      # now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <outlet sans centreline> and <outlet centreline>
      NONE_EQUATION <outlet centreline flowrate equation> "facesum(<p_f>,region=<outlet centreline>)" # set pressure at centreline to be zero
      NONE_DERIVED <outlet centreline gradp> "facesum(<dynamic_force_f>,region=<outlet centreline>)"
      FACE_EQUATION <outlet flowrate equation> "<dynamic_force_f>-<outlet centreline gradp>" ON <outlet sans centreline> # apply specified pressure over outlet
   
   # now ion transport and potential equation
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "electrokinetics"
      #(comment created during unwrap): new block = ../../templates/electrokinetics/binary_ion_equations.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "binary_ion_equations" # transport of binary electrolyte (positive and negative ions), including boundary conditions
      # equations required for the transport of a binary univalent electrolyte
      # include statements for binary combinations should be included earlier before p_error calculation (binary_ion_combinations)
      
      # include positive ion transport equations
         #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_equations.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "ion_equations" 
         
            #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_constants.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "ion_constants"
            # ion constants for one specific ion species
            # all variables start with <ion so this can be replaced to make specific ions
            
            CONSTANT <ion+ z> [1] "<average ion z>" # valency of ion
            CONSTANT <ion+ D> [m^2/s] "<average ion D>" # diffusivity of ion
            #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_domain.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "ion_domain"
            # ion transport equations for one specific ion species
            # all variables start with <ion so this can be replaced to make specific ions
            
            #CELL_LOCAL <ion n initial> "<average ion n>"
            # initial value now based on initial potential, so the potential expression will be unwrapped to use here
            CELL_LOCAL <ion+ n initial> "<average ion n>*exp(-<ion+ z>*<e/kT>*<U>)"
            CELL_UNKNOWN <ion+ n> [molecules/m^3] "<ion+ n initial>" ON <allcells> # ion concentration, note units
            
            #CELL_TRANSIENT <ion+ n[r=1]> "<ion+ n initial>" "<ion+ n>" ON <allcells>
            CELL_DERIVED <ion+ limiter> [1] "celllimiter[lower](<ion+ n>,cellmin(<ion+ n>,,<cellicells>),celllimiter[upper](<ion+ n>,cellmax(<ion+ n>,,<cellicells>)))" ON <allcells> # relative limits
            FACE_LOCAL <ion+ n_f> "faceave[advection](<ion+ n>,<u_f>,<ion+ limiter>*<adv_limiter>)" ON <allfaces> # face advection-interpolated concentration
            FACE_DERIVED <ion+ J_f> [molecules/(m^2.s)] "<ion+ n_f>*<u_f>-<ion+ D>*(facegrad(<ion+ n>)+<ion+ z>*<e/kT>*<ion+ n_hf>*facegrad(<U>))" ON <allfaces> # flux of ions across each face
            
            # conservation equations, which now include (v0.5) a divergence term to help with enroute to convergence
            # cartesian only
            CELL_EQUATION <ion+ continuity> [molecules/(m^3.s)] "celldiv(<ion+ J_f>-faceave[lastcell](<ion+ n>)*<u_f>)" ON <domain>
            # cylindrical and cartesian
            #CELL_EQUATION <ion+ continuity> [molecules/(m^3.s)] "celldiv(1.d0*(<ion+ J_f>-faceave[lastcell](<ion+ n>)*<u_f>))/1.d0" ON <domain>
            
            # cartesian only
            #CELL_EQUATION <ion+ continuity> [molecules/(m^3.s)] "(<ion+ n>-<ion+ n[r=1]>)/<dt>+celldiv(<ion+ J_f>-faceave[lastcell](<ion+ n>)*<u_f>)" ON <domain>
            # cylindrical and cartesian
            ##CELL_EQUATION <ion+ continuity> [molecules/(m^3.s)] "(<ion+ n>-<ion+ n[r=1]>)/<dt>+celldiv(1.d0*(<ion+ J_f>-faceave[lastcell](<ion+ n>)*<u_f>))/1.d0" ON <domain>
            #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_walls.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "ion_walls"
            # ion wall boundary conditions for one specific ion species
            # all variables start with <ion so this can be replaced to make specific ions
            
            FACE_EQUATION <ion+ walls> "<ion+ J_f>" ON <walls> # no flux of ions through walls
            #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_fully_developed.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "ion_fully_developed" 
            
            # ion transport equations for one specific ion species
            # all variables start with <ion so this can be replaced to make specific ions
            
            FACE_EQUATION <ion+ outlet> "facegrad(<ion+ n>)" ON <outlet> # fully developed flow
            #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_fully_developed.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "ion_fully_developed" 
            
            # ion transport equations for one specific ion species
            # all variables start with <ion so this can be replaced to make specific ions
            
            FACE_EQUATION <ion+ inlet> "facegrad(<ion+ n>)" ON <inlet> # fully developed flow
      # include negative ion transport equations, correcting valency to be negative
         #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_equations.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "ion_equations" 
         
            #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_constants.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "ion_constants"
            # ion constants for one specific ion species
            # all variables start with <ion so this can be replaced to make specific ions
            
            CONSTANT <ion- z> [1] "<average ion z>" # valency of ion
            CONSTANT <ion- D> [m^2/s] "<average ion D>" # diffusivity of ion
            #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_domain.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "ion_domain"
            # ion transport equations for one specific ion species
            # all variables start with <ion so this can be replaced to make specific ions
            
            #CELL_LOCAL <ion n initial> "<average ion n>"
            # initial value now based on initial potential, so the potential expression will be unwrapped to use here
            CELL_LOCAL <ion- n initial> "<average ion n>*exp(-<ion- z>*<e/kT>*<U>)"
            CELL_UNKNOWN <ion- n> [molecules/m^3] "<ion- n initial>" ON <allcells> # ion concentration, note units
            
            #CELL_TRANSIENT <ion- n[r=1]> "<ion- n initial>" "<ion- n>" ON <allcells>
            CELL_DERIVED <ion- limiter> [1] "celllimiter[lower](<ion- n>,cellmin(<ion- n>,,<cellicells>),celllimiter[upper](<ion- n>,cellmax(<ion- n>,,<cellicells>)))" ON <allcells> # relative limits
            FACE_LOCAL <ion- n_f> "faceave[advection](<ion- n>,<u_f>,<ion- limiter>*<adv_limiter>)" ON <allfaces> # face advection-interpolated concentration
            FACE_DERIVED <ion- J_f> [molecules/(m^2.s)] "<ion- n_f>*<u_f>-<ion- D>*(facegrad(<ion- n>)+<ion- z>*<e/kT>*<ion- n_hf>*facegrad(<U>))" ON <allfaces> # flux of ions across each face
            
            # conservation equations, which now include (v0.5) a divergence term to help with enroute to convergence
            # cartesian only
            CELL_EQUATION <ion- continuity> [molecules/(m^3.s)] "celldiv(<ion- J_f>-faceave[lastcell](<ion- n>)*<u_f>)" ON <domain>
            # cylindrical and cartesian
            #CELL_EQUATION <ion- continuity> [molecules/(m^3.s)] "celldiv(1.d0*(<ion- J_f>-faceave[lastcell](<ion- n>)*<u_f>))/1.d0" ON <domain>
            
            # cartesian only
            #CELL_EQUATION <ion- continuity> [molecules/(m^3.s)] "(<ion- n>-<ion- n[r=1]>)/<dt>+celldiv(<ion- J_f>-faceave[lastcell](<ion- n>)*<u_f>)" ON <domain>
            # cylindrical and cartesian
            ##CELL_EQUATION <ion- continuity> [molecules/(m^3.s)] "(<ion- n>-<ion- n[r=1]>)/<dt>+celldiv(1.d0*(<ion- J_f>-faceave[lastcell](<ion- n>)*<u_f>))/1.d0" ON <domain>
            #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_walls.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "ion_walls"
            # ion wall boundary conditions for one specific ion species
            # all variables start with <ion so this can be replaced to make specific ions
            
            FACE_EQUATION <ion- walls> "<ion- J_f>" ON <walls> # no flux of ions through walls
            #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_fully_developed.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "ion_fully_developed" 
            
            # ion transport equations for one specific ion species
            # all variables start with <ion so this can be replaced to make specific ions
            
            FACE_EQUATION <ion- outlet> "facegrad(<ion- n>)" ON <outlet> # fully developed flow
            #(comment created during unwrap): new block = ../../templates/electrokinetics/ion_fully_developed.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "ion_fully_developed" 
            
            # ion transport equations for one specific ion species
            # all variables start with <ion so this can be replaced to make specific ions
            
            FACE_EQUATION <ion- inlet> "facegrad(<ion- n>)" ON <inlet> # fully developed flow
      CONSTANT <ion- z> [1] "-<average ion z>" # valency of ion-
      
      # calculate currents crossing into domain over inlet, most probably used in potential boundary conditions
      # cartesian
      NONE_DERIVED <I+> "-<e>*<ion+ z>*facesum(<ion+ J_f>*<facearea>,<inlet>)"
      NONE_DERIVED <I-> "-<e>*<ion- z>*facesum(<ion- J_f>*<facearea>,<inlet>)"
      # cylindrical
      #NONE_DERIVED <I+> "-<e>*<ion+ z>*facesum(<ion+ J_f>*<facearea>*1.d0,<inlet>)*2.d0*<pi>"
      #NONE_DERIVED <I-> "-<e>*<ion- z>*facesum(<ion- J_f>*<facearea>*1.d0,<inlet>)*2.d0*<pi>"
      NONE_DERIVED <I_total_calc> "<I+>+<I->"
      
      # overwrite inlet conditions to set concentration and a concentration gradient
      FACE_EQUATION <ion+ inlet> "<n_0^2 signed>-<average ion n>^2"
      #FACE_EQUATION <ion- inlet> "facegrad(<ion+ n>)^2+facegrad(<ion- n>)^2" # (if combined is difficult to converge then use only one species)
      #FACE_EQUATION <ion- inlet> "facegrad(<ion+ n>)" # this should be more stable for a negative surface charge
      FACE_EQUATION <ion- inlet> "faceif(<S>,facegrad(<ion- n>),facegrad(<ion+ n>))" # boundary condition is applied on the major ion species
      #(comment created during unwrap): new block = ../../templates/electrokinetics/potential_equations.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "potential_equations" # electrical poisson equation for potential, including boundary conditions
         #(comment created during unwrap): new block = ../../templates/electrokinetics/potential_domain.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "potential_domain"
         # potential equations
         CELL_UNKNOWN <U> "1.d0" ON <allcells> # electrical potential
         # cartesian only
         CELL_EQUATION <U poisson equation> "<eps_o>*celldiv(<eps_fluid>*facegrad(<U>))+<K^2/2>*<rho_e>" ON <domain> # Poisson potential equation
         # cylindrical and cartesian
         #CELL_EQUATION <U poisson equation> "<eps_o>*celldiv(1.d0*<eps_fluid>*facegrad(<U>))/1.d0+<K^2/2>*<rho_e>" ON <domain> # Poisson potential equation
         #(comment created during unwrap): new block = ../../templates/electrokinetics/potential_charged_walls.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "potential_charged_walls"
         FACE_EQUATION <U charged walls> "<eps_o>*<eps_fluid>*facegrad(<U>)-<wall charge>" ON <walls>
         #(comment created during unwrap): new block = ../../templates/electrokinetics/potential_outlet.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "potential_outlet"
         # these equations need <outlet>, <outlet centreline> and <outlet sans centreline> to be defined, by (eg)
         #FACE_REGION <outlet centreline> "AT 0.d0 0.d0 0.d0 PART OF <outlet>"
         #FACE_REGION <outlet sans centreline> "COMPOUND <outlet>-<outlet centreline>"
         
         # set uniform potential gradient over outlet to the gradient that exists in the centreline
         NONE_DERIVED <outlet centreline gradU> "facesum(facegrad(<U>),region=<outlet centreline>)" # find the potential gradient near the centreline as a variable with no centring
         FACE_EQUATION <outlet potential equation> "facegrad(<U>)-<outlet centreline gradU>" ON <outlet sans centreline>
         
         # and set the average potential at the outlet to zero
         #NONE_DERIVED <outlet average U> "facesum(<U>*<facearea>,<outlet>)/facesum(<facearea>,<outlet>)" # find the average potential over the whole outlet
         #NONE_EQUATION <outlet centreline potential equation> "<outlet average U>" # and set this to zero
         
         # or set potential at centreline to zero
         NONE_EQUATION <outlet centreline potential equation> "facesum(<U>,region=<outlet centreline>)" # use this none centred form so that if this equation has to be overwritten, the overwritten equation can be none centred (eg, specify total current)
         #(comment created during unwrap): new block = ../../templates/electrokinetics/potential_inlet.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "potential_inlet"
         # these are similar to the outlet equations, except for setting level of potential
         
            #(comment created during unwrap): new block = ../../templates/electrokinetics/potential_outlet.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "potential_outlet.arb" 
            
            # these equations need <outlet>, <outlet centreline> and <outlet sans centreline> to be defined, by (eg)
            #FACE_REGION <outlet centreline> "AT 0.d0 0.d0 0.d0 PART OF <outlet>"
            #FACE_REGION <outlet sans centreline> "COMPOUND <outlet>-<outlet centreline>"
            
            # set uniform potential gradient over outlet to the gradient that exists in the centreline
            NONE_DERIVED <inlet centreline gradU> "facesum(facegrad(<U>),region=<inlet centreline>)" # find the potential gradient near the centreline as a variable with no centring
            FACE_EQUATION <inlet potential equation> "facegrad(<U>)-<inlet centreline gradU>" ON <inlet sans centreline>
            
            # and set the average potential at the outlet to zero
            #NONE_DERIVED <outlet average U> "facesum(<U>*<facearea>,<outlet>)/facesum(<facearea>,<outlet>)" # find the average potential over the whole outlet
            #NONE_EQUATION <outlet centreline potential equation> "<outlet average U>" # and set this to zero
            
            # or set potential at centreline to zero
            NONE_EQUATION <inlet centreline potential equation> "facesum(<U>,region=<inlet centreline>)" # use this none centred form so that if this equation has to be overwritten, the overwritten equation can be none centred (eg, specify total current)
         
         # replace potential setting condition with an equation specifying total current
         NONE_EQUATION <inlet centreline potential equation> "<I_total_calc>-<I_total>" 
   
   # giving a better initial estimate leads to faster and more reliable convergence
      #(comment created during unwrap): new block = ../../templates/electrokinetics/estimate_initial_potential.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "estimate_initial_potential" # sets the initial potential using a very rough correlation.  Initial ion concentrations reference this potential.
      # based on the nondimensional parameters <S>, <K> and <a_lengthscale>, roughly estimate the initial potential field
      # include this after the potential unknown equation
      
      # very rough estimate of the zeta potential based on correlations in dhjcis11, doi:10.1016/j.jcis.2011.07.076 
      CONSTANT <alpha_large_S> "(3.d0*abs(<S>)+<pi>^2+6.d0-sqrt(nonemax(3.d0*(3.d0*<S>^2+12.d0*abs(<S>)+4.d0*<pi>^2+12.d0),0.d0)))/(2.d0*<pi>)"
      CONSTANT <alpha_small_S> "sqrt(nonemax(-1.5d0+sqrt(2.25d0+1.5d0*abs(<S>)),0.d0))"
      CONSTANT <alpha> "nonemin(<alpha_large_S>,<alpha_small_S>)"
      CONSTANT <Z estimate> "signum(<S>)*nonemin(abs(<S>)*coth(<K>)/<K>,-2.d0*log(cos(<alpha>)))" # signed, nondimensional zeta potential, taken as minimum between low and high potential solutions
      
      #(hash inserted during unwrap)INCLUDE_TEMPLATE "general"
         #(comment created during unwrap): new block = ../../templates/general/domain_lengthscale_face_boundary_distance.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "domain_lengthscale_face_boundary_distance" # use this formulation of <a_lengthscale> as it needs to be consistent with <minimum_face_boundary_distance>
         # find an estimate of the domain size
         # here we use a more accurate estimate of the domain size based on minimum_face_boundary_distance (used in electrokinetic routines for example)
            #(comment created during unwrap): new block = ../../templates/general/minimum_face_boundary_distance.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "minimum_face_boundary_distance" # this will find a constant vector domain length in each dimension
            # this bit of code taken from older level set routines, with a few name changes
            # finds minimum distance to walls, but is expensive to calculate
            FACE_LOCAL <face_from_cell_boundary_vector[l=1]> "<facex[l=1]>-faceave[lastcell](<cellx[l=1]>)"
            FACE_LOCAL <face_from_cell_boundary_vector[l=2]> "<facex[l=2]>-faceave[lastcell](<cellx[l=2]>)"
            #FACE_LOCAL <face_from_cell_boundary_vector[l=3]> "<facex[l=3]>-faceave[lastcell](<cellx[l=3]>)"
            CELL_LOCAL <minimum_face_boundary_distance> "sqrt(facemin(dot(<face_from_cell_boundary_vector[l=:]>,<face_from_cell_boundary_vector[l=:]>),region=<walls>))"
            
            # see domain_lengthscale_face_boundary_distance for a <a_lengthscale> calculated from this
         CONSTANT <a_lengthscale> "cellmax(<minimum_face_boundary_distance>,region=<domain>)" # an estimate of the mesh lengthscale (channel half-width) based on the minimum domain -> wall distance
      CELL_CONSTANT <U initial> "cellif(1.d0/<K>-<minimum_face_boundary_distance>/<a_lengthscale>,<Z estimate>*<K>*(1.d0/<K>-<minimum_face_boundary_distance>/<a_lengthscale>),0.d0)/<e/kT>" ON <allcells> output
      CELL_UNKNOWN <U> "<U initial>" # adopts region etc from real definition on the unknown <U>
   
   #-------------------------------------------------------------------
   # correct some magnitudes
   CELL_UNKNOWN <p> magnitude=1.d+5
   # the following magnitudes are resonably well calculated from the initial potential estimate, so don't bother setting explicitly
   #CELL_UNKNOWN <U> magnitude=1.d+1
   #CELL_UNKNOWN <ion+ n> magnitude=1.d+4
   #CELL_UNKNOWN <ion- n> magnitude=1.d+0
   
   # set nondimensional constants (these are based on a previous test case)
   CONSTANT <Re>  0.28089888E-03
   CONSTANT <Sc>   445.00000    
   CONSTANT <B>  0.29522318E-03 
   CONSTANT <K>   2.6488688     
   CONSTANT <S>  -27.453590     
   CONSTANT <I_total> [1] 0.d0 # total current passing through domain
   
   # output a flag telling us which term limited the correction velocity
   #FACE_OUTPUT <advection correction limited> "faceif(<facedx>^2/<mu>-<facedx>/(<rho>*facemax(abs(<u_f_{raw}>),1.d-10)),1.d0,0.d0)" ON <domainfaces> # is 1 where advection component is limiting velocity correction
   # and turn some outputs on
   FACE_DERIVED <u_f_{correction}> output
   FACE_DERIVED <u_f_{raw}> output
   FACE_DERIVED <u_f> output
   FACE_DERIVED <J_f[l=1]> output
   FACE_LOCAL <tau[l=1,1]> output
   
   # putting in exact initial conditions
   CELL_UNKNOWN <u[l=1]> "0.d0"
   CELL_UNKNOWN <u[l=2]> "0.d0"
   CELL_UNKNOWN <p> "0.d0"
   FACE_DERIVED <p_error> output
   #CONSTANT <adv_limiter> 0.d0
   
   #-------------------------------------------------------------------
   # some alternative discretisations:
   
   # enforce uniform celldivgrads for p and U in cells next to the inlet/outlet, rather than on the boundaries themselves
   #INCLUDE "inlet_u_fully_developed_celldivgrad" # fully developed velocity profile, setting a uniform pressure gradient to give using <u_av>
   #INCLUDE "outlet_u_fully_developed_celldivgrad" # fully developed velocity profile, setting pressure at centreline to zero and a uniform pressure gradient
   #INCLUDE "potential_outlet_celldivgrad"
   #INCLUDE "potential_inlet_celldivgrad"
   
   # apply concentration condition on cells next to inlet, rather than on boundary cells
   #FACE_EQUATION <ion+ inlet> "faceave[downcell](<n_0^2 signed>)-<average ion n>^2"
   
   # apply concentration condition on outlet instead of minor species facegrad
   # only use if outlet concentration is known
   # marginally more accurate calculated pressure/potential gradients for fully developed flow
   #FACE_EQUATION <ion+ outlet> "<n_0^2 signed>-<average ion n>^2"
   #FACE_EQUATION <ion- outlet> "faceif(<S>,facegrad(<ion- n>),facegrad(<ion+ n>))" # boundary condition is applied on the major ion species
   
   # include conduction of ions in the advection velocity, calculating the advection concentrations appropriately using upwinding
   #INCLUDE "ion_domain_ionuf" R "<ion" W "<ion+"
   #INCLUDE "ion_domain_ionuf" R "<ion" W "<ion-"
   
   #-------------------------------------------------------------------
   # output statistics
   
   # -----------
   # compare pressure/potential gradients against exact 1D solution, calculated numerically
   # Accompaniment to paper, `Microfluidic circuit analysis - Flowrate and
   # ion current relationships for thin slits and pipes'
   # by Dalton J.E. Harvie, Christian J.C. Biscombe and Malcolm R. Davidson
   # outputs from the electrokinetic flow solver (ekfs), using jmax = 10002
   # -----------
   #   SETTING KKK TO 2.6488688
   #   SETTING SSS TO -27.453590
   #   SETTING DDD(+1) TO 1.0848474
   #   SETTING DDD(-1) TO 1.0848474
   # CREATING NONDIMENSIONAL FLOWRATE AND CURRENT EXPRESSIONS
   #     1      = [-0.3333333    ]xDELP + [-0.9525616    ]xDELPHI
   #     III(+1 = [ -1.104795    ]xDELPPP + [ -12.90186    ]xDELPHIPHI
   #     III(-1 = [ 0.1522337    ]xDELPPP + [ 0.9042310E-02]xDELPHIPHI
   #     III_TO = [-0.9525617    ]xDELPPP + [ -12.89281    ]xDELPHIPHI
   #     ELECTROVISCOUS CASE: DELPPP =  -3.8029309546    : DELPHIPHI =  0.28097253761    
   # -----------
   
   CONSTANT <ekfs_ppp> -3.8029309546    
   CONSTANT <ekfs_fff> 0.28097253761    
   CONSTANT <axial pressure gradient analytical> "<ekfs_ppp>/<Re>" # actually based on ekfs results
   CONSTANT <axial potential gradient analytical> "<ekfs_fff>*<Re>/(<K>^2*<B>)"
   
   NONE_CONSTANT <X max> "facemax(<facex[l=1]>,,<allfaces>)"
   NONE_CONSTANT <X min> "facemin(<facex[l=1]>,,<allfaces>)"
   NONE_CONSTANT <Y max> "facemax(<facex[l=2]>,,<allfaces>)"
   NONE_CONSTANT <Y min> "facemin(<facex[l=2]>,,<allfaces>)"
   
   CELL_OUTPUT <axial pressure gradient> "celldivgrad[l=1](<p>)" elementdata
   CELL_OUTPUT <axial pressure gradient error> "abs(<axial pressure gradient>-<axial pressure gradient analytical>)" elementdata
   NONE_OUTPUT <axial pressure gradient L2 norm> "sqrt(cellsum(<axial pressure gradient error>^2,<domain>)/cellsum(1.d0,<domain>))"
   NONE_OUTPUT <axial pressure gradient L1 norm> "cellsum(<axial pressure gradient error>,<domain>)/cellsum(1.d0,<domain>)"
   NONE_OUTPUT <axial pressure gradient Linfty norm> "cellmax(<axial pressure gradient error>,region=<domain>)"
   NONE_OUTPUT <average inlet pressure> "facesum(<p>*<facearea>,<inlet>)/facesum(<facearea>,<inlet>)"
   NONE_OUTPUT <average outlet pressure> "facesum(<p>*<facearea>,<outlet>)/facesum(<facearea>,<outlet>)"
   NONE_OUTPUT <overall pressure difference error> "abs(1.d0 - (<average outlet pressure> - <average inlet pressure>)/(<axial pressure gradient analytical>*(<X max>-<X min>)))"
   NONE_OUTPUT <centreline inlet pressure> "facesum(<p>,region=<inlet centreline>)"
   NONE_OUTPUT <centreline outlet pressure> "facesum(<p>,region=<outlet centreline>)"
   NONE_OUTPUT <centreline pressure difference error> "abs(1.d0 - (<centreline outlet pressure> - <centreline inlet pressure>)/(<axial pressure gradient analytical>*(<X max>-<X min>)))"
   NONE_OUTPUT <centreline pressure gradient> "(<centreline outlet pressure> - <centreline inlet pressure>)/(<X max>-<X min>)"
   NONE_OUTPUT <average pressure gradient> "(<average outlet pressure> - <average inlet pressure>)/(<X max>-<X min>)"
   
   CELL_OUTPUT <axial potential gradient> "celldivgrad[l=1](<U>)" elementdata
   CELL_OUTPUT <axial potential gradient error> "abs(<axial potential gradient>-<axial potential gradient analytical>)" elementdata
   NONE_OUTPUT <axial potential gradient L2 norm> "sqrt(cellsum(<axial potential gradient error>^2,<domain>)/cellsum(1.d0,<domain>))"
   NONE_OUTPUT <axial potential gradient L1 norm> "cellsum(<axial potential gradient error>,<domain>)/cellsum(1.d0,<domain>)"
   NONE_OUTPUT <axial potential gradient Linfty norm> "cellmax(<axial potential gradient error>,region=<domain>)"
   NONE_OUTPUT <average inlet potential> "facesum(<U>*<facearea>,<inlet>)/facesum(<facearea>,<inlet>)"
   NONE_OUTPUT <average outlet potential> "facesum(<U>*<facearea>,<outlet>)/facesum(<facearea>,<outlet>)"
   NONE_OUTPUT <overall potential difference error> "abs(1.d0 - (<average outlet potential> - <average inlet potential>)/(<axial potential gradient analytical>*(<X max>-<X min>)))"
   NONE_OUTPUT <centreline inlet potential> "facesum(<U>,region=<inlet centreline>)"
   NONE_OUTPUT <centreline outlet potential> "facesum(<U>,region=<outlet centreline>)"
   NONE_OUTPUT <centreline potential difference error> "abs(1.d0 - (<centreline outlet potential> - <centreline inlet potential>)/(<axial potential gradient analytical>*(<X max>-<X min>)))"
   NONE_OUTPUT <centreline potential gradient> "(<centreline outlet potential> - <centreline inlet potential>)/(<X max>-<X min>)"
   NONE_OUTPUT <average potential gradient> "(<average outlet potential> - <average inlet potential>)/(<X max>-<X min>)"
   
   CELL_OUTPUT <icell output> "<icell>"
   FACE_OUTPUT <jface output> "<jface>"
   
   CELL_OUTPUT <n_0> "sqrt(cellmax(<ion+ n>*<ion- n>,0.d0))"
   CELL_OUTPUT <n_0^2 negative error> "-cellmin(<ion+ n>*<ion- n>,0.d0)"
   CELL_LOCAL <rho_e> ON <allcells> output
   
   CELL_OUTPUT <n_0 error> "abs(<n_0>-1.d0)" elementdata
   NONE_OUTPUT <n_0 L2 norm> "sqrt(cellsum(<n_0 error>^2,<domain>)/cellsum(1.d0,<domain>))"
   NONE_OUTPUT <n_0 L1 norm> "cellsum(<n_0 error>,<domain>)/cellsum(1.d0,<domain>)"
   NONE_OUTPUT <n_0 Linfty norm> "cellmax(<n_0 error>,region=<domain>)"
   
   #-------------------------------------------------------------------
##################################################################################
