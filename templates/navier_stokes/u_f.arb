MARKDOWN
Interpolate the cell centred velocity to the faces and find the velocity (flux) normal to the face (<u_f>), using a rhie-chow spirited interpolation technique on the domain faces
END_MARKDOWN

# check default strings are set
INCLUDE "default_string_replacements"

# start by calculating the difference between the local face centred (dynamic) pressure gradient and average of cell centred (dynamic) pressure gradients in the face direction
# `dynamic' pressure here means the pressure that is able to cause fluid flow, ie, possibly accounting for hydrostatic pressure variations (for example)
# the recommended behaviour is now to call this before this file, but to allow for backwards compatibility, check if the correction force has been defined, and if not, call dynamic_force
IF {{ return (!(arb_defined('<dynamic_force_f_{correction}>'))) }} # only calculate the dynamic_force correction if it isn't already defined
  INCLUDE "dynamic_force"
END_IF

# <u_f_vect[l=:]> is now defined in unknowns.arb
FACE_DERIVED <u_f_{raw}> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" ON <allfaces> # volume (velocity) transport over the face, only by arithmetic interpolation

# save old correction velocity for transient calculations
IF <<transientnavierstokes>>
  FACE_TRANSIENT <u_f_{correction}[r=1]> "0.d0" "<u_f_{correction}>" ON <domainfaces>
END_IF

# calculate all of the alpha coefficients used in the correction velocity calculation
INCLUDE "u_f_coefficients"

#############################################
# assemble <u_f_{correction}>, taking advantage of variable reuse so that only one expression is formed for <u_f_{correction}> (to maximise code efficiency and maxima expression simplifications)
# first assemble demoninator of expression by adding up the various alpha coefficients

# viscous
# all equation variants here have viscous contribution, so add this first
FACE_DERIVED <u_f_{correction}> "<u_f_alpha_{vis}>" ON <domainfaces>

# advection term
IF {{ return (!(string_eval('<<stokes>>'))) }} # only for navier-stokes equations
  FACE_DERIVED <u_f_{correction}> "<u_f_{correction}>+<u_f_alpha_{adv}>"
END_IF

# now take the reciprocal, to form the correction velocity, with added terms for the transient method
# transient
IF <<transientnavierstokes>>
# for transient, add transient component to demoninator, take reciprocal, and add top transient and pressure contributions
  FACE_DERIVED <u_f_{correction}> "(<C_{Rhie-Chow}>*<dynamic_force_f_{correction}>+<u_f_alpha_{transient}>*<u_f_{correction}[r=1]>)/(<u_f_{correction}>+<u_f_alpha_{transient}>)"
ELSE
# for steady-state just take reciprocal and add pressure contribution
  FACE_DERIVED <u_f_{correction}> "<C_{Rhie-Chow}>*<dynamic_force_f_{correction}>/(<u_f_{correction}>)"
END_IF
#############################################

# final face velocity
FACE_DERIVED <u_f> "<u_f_{raw}>+faceif(facedelta(<domainfaces>),<u_f_{correction}>,0.d0)" ON <allfaces> # volume (velocity) transport

# this oddball file is required for implicit timestepping after u_f is calculated
INCLUDE "transient_save_dt"
