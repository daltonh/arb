# within this file we calculate the curvature based on facegrad around faces

# doing cartesian and cylindrical curvatures separately

FACE_LOCAL <vof_kappa_cart_f> "-(facegrad[l=1,reflect=1](<vof_phigrad_expand_unit[l=1]>)+facegrad[l=2,reflect=2](<vof_phigrad_expand_unit[l=2]>)+facegrad[l=3,reflect=3](<vof_phigrad_expand_unit[l=3]>))" ON <all faces>
# two methods of calculating the cylindrical (separate) curvature
# average the normal component, and then divide by the radius, noting that the normal component is an odd function so must be reflected
#<<cylindricalcomment>>FACE_LOCAL <vof_kappa_cyl_f> "-faceave[reflect=<<radialdim>>](<vof_phigrad_expand_unit[l=<<radialdim>>]>)/<<radius_f>>" ON <all faces> # won't work on centreline, so instead use twice carteisan curvature there
# otherwise, around centreline, both the normal component and radius are odd functions, so one divided by the other becomes an even function, so does not need reflection around the centreline
<<cylindricalcomment>>FACE_LOCAL <vof_kappa_cyl_f> "-faceave(<vof_phigrad_expand_unit[l=<<radialdim>>]>/<<radius_c>>)" ON <all faces> # won't work on centreline, so instead use twice carteisan curvature there
# an alternative to calculating the cartesian and cylindrical components separately is to calculate them together using cylindrical divergence operator
# need to devise coding way to cancel reflection of gradient operator in the radial direction, as both the normal component and radius_c are odd functions in this direction around the centreline
# seems to be slightly more accurate than calculating the cartesian and cylindrical curvatures separately
# eg, if radial direction = 1 you would use the following which has no reflect on the first facegrad:
# TODO: implement system variable <facefromicellreflect[l=?]> and put <facefromicellreflect[l=<<radialdim>>]> in each derivative
#<<cylindricalcomment>>FACE_LOCAL <vof_kappa_totcyl_f> "-(facegrad[l=1](<vof_phigrad_expand_unit[l=1]>*<<radius_c>>)+facegrad[l=2,reflect=2](<vof_phigrad_expand_unit[l=2]>*<<radius_c>>)+facegrad[l=3,reflect=3](<vof_phigrad_expand_unit[l=3]>*<<radius_c>>))/<<radius_f>>" ON <all faces>

<<cartesiancomment>>FACE_DERIVED <vof_kappa_f> "faceif(<vof_delta_mask_f>,<vof_kappa_cart_f>,0.d0)" ON <all faces> output
#<<cylindricalcomment>>FACE_DERIVED <vof_kappa_f> "faceif(<vof_delta_mask_f>,faceif(<<radius_f>>-1.d-6*<facedx>,<vof_kappa_cart_f>+<vof_kappa_cyl_f>,2.d0*<vof_kappa_cart_f>),0.d0)" ON <all faces> output
<<cylindricalcomment>>FACE_DERIVED <vof_kappa_f> "faceif(<vof_delta_mask_f>,<vof_kappa_cart_f>+<vof_kappa_cyl_f>,0.d0)" ON <all faces> output
#<<cylindricalcomment>>FACE_DERIVED <vof_kappa_f> "faceif(<vof_delta_mask_f>,faceif(<<radius_f>>-1.d-6*<facedx>,<vof_kappa_totcyl_f>,2.d0*<vof_kappa_cart_f>),0.d0)" ON <all faces> output

#CELL_DERIVED <vof_kappa_c> "cellif(<vof_delta_mask>,<vof_kappa_f>,0.d0)" ON <all cells> output
# now weight using <vof_delta_f> magnitude limited by minimum <vof_phigrad_tol>
CELL_DERIVED <vof_kappa_c> "cellif(<vof_delta_mask>,facesum(<vof_kappa_f>*facemax(abs(<vof_delta_f>),default=<vof_phigrad_tol>),region=<celljfaces>)/facesum(facemax(abs(<vof_delta_f>),default=<vof_phigrad_tol>),region=<celljfaces>),0.d0)" ON <all cells> output
