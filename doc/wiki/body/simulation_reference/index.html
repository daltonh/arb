<!-- INFO from assembler: markdown_filename = /Users/daltonh/arb/development/arb_develop_v0.57/doc/wiki/body/simulation_reference/index.md: arb version = 0.57 -->
<!-- INFO from assembler: markdown_filename = /Users/daltonh/arb/development/arb_develop_v0.57/doc/wiki/body/simulation_reference/index.md: markdown_dir = /Users/daltonh/arb/development/arb_develop_v0.57/doc/wiki/body/simulation_reference/index.md: wiki_dir = /Users/daltonh/arb/development/arb_develop_v0.57/doc/wiki: doc_dir = /Users/daltonh/arb/development/arb_develop_v0.57/doc: working_dir = /Users/daltonh/arb/development/arb_develop_v0.57 -->
<!-- pre comments -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <meta http-equiv="Content-Style-Type" content="text/css" /> <meta name="generator" content="pandoc" />
<title></title>
  <style type="text/css">code{white-space: pre;}</style>
  
<link rel="stylesheet" href="/Users/daltonh/arb/development/arb_develop_v0.57/doc/wiki/css/arb_body.css" type="text/css" /> <link rel="stylesheet" href="/Users/daltonh/arb/development/arb_develop_v0.57/doc/wiki/css/arb_main.css" type="text/css" />
</head>
<body>
<div id="container">
<!-- add a blank left margin here-->
<!--<div id=leftcolumn></div>-->
<div id="maincolumn">
<!-- pre comments -->

<h1>Simulation setup reference [sec:setup_reference]</h1>
<h2>Meshes</h2>
<p>arb uses an unstructured mesh composed of cell elements that are separated by face elements. The dimension of each element is specified on a per-element basis, consistent with the particular computational domain that the element is within (that is, not globally). Cell elements are classified as either boundary cells (that is, on the boundary of a domain) or domain cells (that is, contained within a domain). Domain cells have a dimension that is equal to that of the domain they are in (ie, dimension 3/2/1 if the domain is a volume/surface/line, resp.). Boundary cells have a dimension that is one less than that of the associated domain (ie, dimension 2/1/0 if the domain is a volume/surface/line, resp.). Face elements are any elements that separate cell elements. Face elements also have a dimension that is one less than that of the domain they are within. Some face elements are specified explicitly within a file (if they are part of a physical entity such as for example), while the remainder are generated by arb when the mesh is read in. Face elements are also classified as being either domain faces or boundary faces. Each boundary face has the same geometry, and is conincident with, a boundary cell. Hence, a mesh has the same number of boundary faces as boundary cells.</p>
<p>Meshes are read in from files, generally produced by the gmsh program. Multiple files can be read in by arb for each simulation. arb has been coded to be able to handle any poly-sided first order elements supported by the gmsh file format. It has been tested to date (v0.3) with tetrahedron, boxes and prisms in 3D, triangles and rectangles in 2D, lines in 1D and points in 0D. Tetrahedron, triangles, lines and points are the default element geometries created by gmsh.</p>
<p>Meshes and data are also exported by arb using the format. During every simulation all domains and all output-enabled data will be written by default to the file. Other files may also be written, corresponding to any files that are read in (with any associated output-enabled data). Regions imported from files as well as regions created by arb will be exported to any written files, however note that as the physical entities handled by gmsh can only have a single dimension, elements that have a dimension that is less than any others within a region will not be associated with that region in any arb-created files. This is relevant for example when a compound region is created that contains both domain and boundary cells. When this arb-written file is displayed by gmsh it will only appear to contain the domain cells.</p>
<h3>Cell and face element specification</h3>
<p>The distinction between cell elements and face elements is not made by gmsh or contained explicitly in the file, but rather must be made by arb when a file is read in. Gmsh’s behaviour is to only write an element to a file if it is a member of a physical entity. Further, each physical entity has a single dimension. So, to decide whether an element is either a face or cell element, arb does two things when reading in each file:</p>
<ol style="list-style-type: decimal">
<li><p>The maximum dimension of all physical entities with the file is found. This is stored as the dimension of the particular mesh;</p></li>
<li><p>When an element is read in that has the same dimension as that of the mesh, it is regarded as a cell element. If it has a dimension that is one less than that of the mesh, it is regarded as a face element. If it has a dimension that is two or more less than that of the mesh, then the element is ignored.</p></li>
</ol>
<p>So what’s the implication of all this? Generally arb will be able to work out from each file which elements within it are cell elements and which are face elements. The only time it won’t is when <em>there are multiple domains having different dimensions contained within the one file</em>. For example, you have both a volume domain and a surface domain specified within a file, on which you want separate (but possibly linked) sets of equations solved.</p>
<p>If you do have multiple domains having different dimensions contained within the one file then the dimension of all regions (that is, physical entities) contained within the file that belong to any domains that have a dimension that is <em>less than</em> that of the file need their centring explicitly specified. For example, if a file contains both a volume and a surface domain, then all regions associated with the surface domain must have their centring explicitly specified. Statements for specifying this cell/face centring for particular regions (gmsh physical entities) are described in section [sec:gmsh_regions]. Alternatively, there is another way that may work for your simulation: As arb can read multiple files for each simulation, it may be easier to place domains of different dimensions in separate files. The cell/face specification will then be handled automatically without additional statements in the file (If you want multiple domains to share common mesh features however this may be difficult to accomplish using gmsh).</p>
<h3>Data and mesh file rereading</h3>
<p>The files written by can contain data. Variables associated with cell elements can be written in either (a uniform value for each cell) or (values vary linearly within each cell) gmsh formats. Variables associated with face elements will only be written in format. Variables which are centred are written using a special format which gmsh won’t display. Note that face and cell boundary elements are not written separately to each file by arb, but rather as a single element. Hence both cell and face boundary data is associated with a single element in each file.</p>
<p>One purpose of exporting data to a file is to provide initial conditions for another (or next) simulation. In this case generally you just have to specify the file from the previous simulation as the mesh file to be read in for the next simulation. Note that each arb-written file contains all the information about a mesh that was originally contained in the mesh-only gmsh-written file: Hence, when starting a simulation from an arb-written datafile is it not necessary (nor does it make sense) to also read in the original gmsh file. Also note that data files that contain variable values can only refer to mesh elements that are specified in the same data file (unless some fancy magic is worked in your equations).</p>
<h3>Mesh read and write options</h3>
<p>Mesh and data input and output is specified by statements within the file:</p>
<pre><code>MSH_FILE &quot;msh_file_name_including_path&quot; comma,separated,list,of,options # comments</code></pre>
<p>The file name refers to the read location. Options for the default file should be referred to by (which is the read location if it did exist). If a file is to be written it will always be written to the directory. As a result, all file basenames must be unique.</p>
<p>Three types of options are available for each file:</p>
<p><em>Output options:</em></p>
<p>These options specify what information is to be written to the file.</p>
<ul>
<li><p>: Both a mesh and all specified variables will be written.</p></li>
<li><p>: Both a mesh and all specified variables will be written. Output will be split between three files, each containing variables of only a single centring (cell, face and none). This can be handy for gmsh compatibility when doing cutgrid and streamtrace operations for example.</p></li>
<li><p>: Only the mesh is written, split between three files as above.</p></li>
<li><p>: Only the mesh is written.</p></li>
<li><p>: Neither the mesh or any data will be written.</p></li>
<li><p>: Same as the file options, but for output, compatible with ParaView (for example). The default is .</p></li>
<li><p>: Same as the file options, but for output, compatible with Tecplot. The default is .</p></li>
</ul>
<p>By default all meshes have the option specified, with the exception of the mesh, which has option .</p>
<p><em>Input options:</em></p>
<p>These options specify what information is to be read from the file.</p>
<ul>
<li><p>: Both a mesh and all relevant data will be read.</p></li>
<li><p>: Both a mesh and all relevant data will be read. In this case the existing is split into three, each containing variables of only a single centring (cell, face and none) as output from a previous simulation employing . In this case the filename should be specified without the centring, for example (rather than ).</p></li>
<li><p>: Only the mesh is read, split between three files as above.</p></li>
<li><p>: Only the mesh is read.</p></li>
<li><p>: Neither the mesh or any data will be read.</p></li>
</ul>
<p>By default all meshes have the option specified, with the exception of the mesh, which has option .</p>
<p><em>Data format options:</em></p>
<p>These options specify how cell centred data will be written to the file. These options overwrite any data format options specific to individual variables.</p>
<ul>
<li><p>: All cell data will be written using the format.</p></li>
<li><p>: All cell data will be written using the format.</p></li>
<li><p>: All cell data will be written using the format, but with the gradients in each cell limited so that each vertex value is bounded by surrounding cell values.</p></li>
</ul>
<p>By default all meshes have no data format options specified, the format instead being determined by the options contained in the individual variable definitions within input file.</p>
<h2>Regions [sec:regions]</h2>
<p>Regions are sets of elements that are used to locate user-defined variables and equations. Each region may contain only mesh elements of the same centring (that is, either cell or face elements, but not both). Regions may contain elements of different dimensions (see caveat in previous section regarding gmsh display of this though). Regions can be defined by the user directly in gmsh when the mesh is generated, or via statements in the file that are interpreted when is run. There are also several generic system generated regions. Region names must be delimited by the characters, and within these delimiters cannot contain the characters , , or . Apart from these four characters their names may contain any non-alphanumeric characters.</p>
<h3>Defining regions via gmsh [sec:gmsh_regions]</h3>
<p>Regions are specified in gmsh by defining and then naming physical entities. To do this via the gmsh GUI:</p>
<ul>
<li><p>Add a physical entity (under the physical groups tab) by selecting various elemental entities.</p></li>
<li><p>Edit the geometry file (using the edit tab) and change the physical entity’s name from the numerical name given by gmsh to the required delimited name suitable for arb.</p></li>
<li><p>Save the file.</p></li>
<li><p>Reload the file again (using the reload tab). If you now check under the visibility menu that the physical entity is visible.</p></li>
</ul>
<p>You can specify the cell or face designation of any gmsh element using the following commands within the file. This is seldom necessary (although it doesn’t hurt either), unless the file it is contained within contains multiple domains, of differing dimensions (see discussion in previous section).</p>
<pre><code>CELL_REGION &lt;gmsh_region_name&gt; 
FACE_REGION &lt;gmsh_region_name&gt;</code></pre>
<h3>Defining regions within the file</h3>
<p>There are several types of region specification statements that can be used in the file. Regions specified by these statements will overwrite any regions defined in the files, however a warning is issued (This allows files to be reread without altering region definition statements). The specification statements are:</p>
<p><em>Compound region:</em></p>
<pre><code>CELL_REGION &lt;name&gt; &quot;COMPOUND +&lt;region1&gt;+&lt;region2&gt;-&lt;region3&gt;&quot; # comments
FACE_REGION &lt;name&gt; &quot;COMPOUND &lt;region1&gt;-&lt;region2&gt;&quot; # comments</code></pre>
<p>A compound region is defined using other existing regions. All regions that are used in the definition (ie, , and in the above examples) must have the (same) centring that is specified by the keyword. If a sign precedes a region name in the list of regions, then all the mesh elements that are in the following region are added to the new compound region, if they are not already members. If a sign precedes a region name in the list of regions, then all the mesh elements that are in the following region are removed from the new compound region, if they are (at that stage) members of the new compound region. If no sign immediately precedes a region name in the defining list then a sign is assumed. When constructing a compound region deals with each region in the defining list sequentially; so whether a mesh element is included in the compound region or not may depend on the order that the regions are listed.</p>
<p><em>At region:</em></p>
<pre><code>CELL_REGION &lt;name&gt; &quot;AT x1 x2 x3&quot; # comments
CELL_REGION &lt;name&gt; &quot;AT x1 x2 x3 PART OF &lt;domain&gt;&quot; # comments
FACE_REGION &lt;name&gt; &quot;AT x1 x2 x3&quot; # comments
FACE_REGION &lt;name&gt; &quot;AT x1 x2 x3 PART OF &lt;inlet&gt;&quot; # comments</code></pre>
<p>This statement defines a region that contains one cell or one face mesh element. The element chosen lies closest to the point . The values , and can be real or double precision floats. An optional confines the choice of an element to those within . In this case must have the same centring as the region statement.</p>
<p><em>Within box region:</em></p>
<pre><code>CELL_REGION &lt;name&gt; &quot;WITHIN BOX x1_min x2_min x3_min x1_max x2_max x3_max&quot; # comments
FACE_REGION &lt;name&gt; &quot;WITHIN BOX x1_min x2_min x3_min x1_max x2_max x3_max&quot; # comments</code></pre>
<p>This statement defines a region including all elements (cell or face) that lie within a box with faces orientated with the coordinate directions, and location defined by the two corner points having the minimum () and maximum () coordinate values. An optional function is planned.</p>
<p><em>Boundary of region:</em></p>
<pre><code>CELL_REGION &lt;name&gt; &quot;BOUNDARY OF &lt;region&gt;&quot; # comments
FACE_REGION &lt;name&gt; &quot;BOUNDARY OF &lt;region&gt;&quot; # comments</code></pre>
<p>This statement defines a region that contains <em>only</em> the boundary elements (either cell or face) that border the region .</p>
<p><em>Domain of region:</em></p>
<pre><code>CELL_REGION &lt;name&gt; &quot;DOMAIN OF &lt;region&gt;&quot; # comments
FACE_REGION &lt;name&gt; &quot;DOMAIN OF &lt;region&gt;&quot; # comments</code></pre>
<p>This statement defines a region that contains <em>only</em> the domain elements (either cell or face) that are associated with the region .</p>
<p><em>Associated with region:</em></p>
<pre><code>CELL_REGION &lt;name&gt; &quot;ASSOCIATED WITH &lt;region&gt;&quot; # comments
FACE_REGION &lt;name&gt; &quot;ASSOCIATED WITH &lt;region&gt;&quot; # comments</code></pre>
<p>This statement defines a region that contains <em>both</em> the domain and boundary elements (either cell or face) that are associated with the region . Effectively this is a combination of the and statements.</p>
<h3>System generated regions</h3>
<p>The following regions are generated by at the start of a simulation. The names cannot be used for user-defined regions:</p>
<p><span>lp<span>10cm</span></span> region name &amp; description<br /> &amp; all cells<br /> &amp; internal domain cells<br /> &amp; cells located on the boundary<br /> &amp; all faces<br /> &amp; internal domain faces<br /> &amp; faces located on the boundary<br /> Additionally, there are a number of system regions which may be used in user-written expressions (see section [sec:language]) which specify sets of mesh elements relative to the current position. These names cannot be used for user-defined regions either:</p>
<p><span>llp<span>8cm</span></span> region name &amp; rel. to&amp; description<br /> &amp; cell &amp; faces that surround the current cell<br /> &amp; cell &amp; faces that surround the current cell, unless the current cell is on a boundary. In that instance move to the neighbouring domain cell and then cycle around the surrounding face cells.<br /> &amp; cell &amp; cells that are local to the current cell (more than just the adjacent cells)<br /> &amp; face &amp; cells that are local to the current face (more than just the adjacent cells)<br /> &amp; cell &amp; cells that are strictly adjacent to the current cell<br /> &amp; face &amp; cells that are strictly adjacent to the current face (always two)<br /> &amp; face &amp; cell that is adjacent to the current face in the direction of the normal<br /> &amp; face &amp; cell that is adjacent to the current face in the opposite direction to the normal<br /> &amp; face &amp; the cell that is upwind of the face, used when performing averaging (see section [sec:language]. Not really a user region.<br /> &amp; face &amp; the cell that is downwind of the face, used when performing averaging (see section [sec:language]. Not really a user region.<br /> &amp; cell &amp; surrounding faces used in a cell averaging kernel (see section [sec:language]. Not really a user region.<br /> &amp; cell &amp; surrounding cells used in cell derivative kernels (see section [sec:language]. Not really a user region.<br /> &amp; cell &amp; surrounding nodes used in a cell averaging kernels (see section [sec:language]. Not really a user region.<br /> &amp; face &amp; surrounding cells used in face averaging and derivative kernels (see section [sec:language]. Not really a user region.<br /> &amp; face/cell &amp; dummy region which specifies no elements, or the last element used in an operator’s context.<br /> Variables ———</p>
<p><span> This section needs some rewritting: there is only one input file now</span></p>
<p>There are eight types of user defined variables: constant, transient, derived, unknown, equation, output, condition and local. Each of these are stored in arb using the same general data structure (fortran type ). Any of these variables can be defined by a user-written expression in which is read by and interpreted by maxima. Additionally, the constant type may be defined in and there given (only) a numerical value. Along with the user defined variables, there are also system defined variables which can be used in user-written expressions.</p>
<p>All variables have an associated compound variable type (scalar, vector or tensor) which is used mainly for output purposes.</p>
<p>Details of both the user and system defined variables are given in this section.</p>
<h3>Constant type variable defined in [sec:equation_constants]</h3>
<p><em>Synopsis:</em></p>
<p>Constant variables are evaluated once at the start of a simulation. If defined in they are defined using an expression which may contain only system variables and other constants — in the latter case the constants must have been defined in either the file or previously (above) in the file.</p>
<p><em>Defining statements:</em></p>
<pre><code>CELL_CONSTANT &lt;name&gt; [multiplier*units] &quot;expression&quot; ON &lt;region&gt; options # comments
FACE_CONSTANT &lt;name&gt; [multiplier*units] &quot;expression&quot; ON &lt;region&gt; options # comments
NONE_CONSTANT &lt;name&gt; [multiplier*units] &quot;expression&quot; options # comments
CONSTANT &lt;name&gt; [multiplier*units] &quot;expression&quot; options # comments</code></pre>
<p><em>Statement components:</em></p>
<ul>
<li><p><em>(required)</em>: This keyword specifies the centring of the variable. Constants that have cell or face centring vary over the simulation domain, and have values associated with each cell or face, respectively (subject to the statement, below). None centred constants have one value that is not linked to any spatial location. If the centring specifier is omitted from the keyword (as in ) then none centring is assumed (ie., keyword is equivalent to keyword ).</p></li>
<li><p><em>(required)</em>: Each variable must have a unique name, delimited by the and characters. Besides these characters, the variable may contain spaces and any other non-alphanumeric characters except for double quotation marks (which demarcate the expression strings) and hash character (which indicates that a comment follows). If the name ends with a direction index, as in or , then the variable is considered to be a component of a three dimensional vector compound. Similarly, if the name ends with a double direction index, as in , the variable is considered to be a component of a three by three tensor compound. Components of compounds that are not explicitly defined are given a zero value (when used in dot and double dot products for example). All defined components that are members of the same compound must be of the same variable type, have the same centring, be defined over the same region and have the same units and multiplier. Certain names are reserved for system variables (see section [sec:system_variables]).</p></li>
<li><p><em>(optional)</em>: When reading in numerical constants, each value is multiplied by this value. At present not in use in .</p></li>
<li><p><em>(optional):</em> A string which specifies the units for the variable. At present this string is not interpreted by the code at all and the user must ensure that the units used are consistent.</p></li>
<li><p><em>(required)</em>: When a constant is defined in , this double-quoted expression is used to specify the value of the constant. As they may contain system variables and also other constants, they may vary throughout the domain. For more details regarding the syntax of these expressions, see section [sec:language].</p></li>
<li><p><em>(optional)</em>: This part of the statement determines over what region the variable should be defined. It is only applicable for cell and face centred variables, and must in these cases refer to a region that has the same centring as the variable. If omitted then by default a cell centred constant will be defined on and a face centred constant on . Note that referring to a variable value outside of its region of definition will produce an error when running .</p></li>
<li><p><em>(optional)</em>: This is a comma separated list of options. Options earlier in the list take precedence over later ones. Valid options for the constant variable type include:</p>
<ul>
<li><p>: The compound variable that this component is a member of to be written to each applicable file. The opposite option exists. Default is for unknown variables, output variables, derived cell-centred variables, and transient variables that do not correspond to the oldest stored timestep (that is, <span class="math">$\code{rstep}&lt;\code{rstepmax}$</span>). The default is for everything else.</p></li>
<li><p>: The compound variable that this component is a member of is to be included in the file. The opposite option exists. By default only this option is set only for unknown, output and transient non-centred variables that are at the current timestep (that is, <span class="math">$\code{rstep}=0$</span>). The option also exists which specifies that the variable should be included in the file, but that its value is not updated before being printed. This option is useful for outputing variables which should only be updated when a file is actually written (for example, a variable that records the time when output occurs).</p></li>
<li><p>: This component to be written to each applicable file. Default is for all variables.</p></li>
<li><p>: The compound variable that is component is a member will be read from each applicable file. The opposite option exists. Default is for all unknown and transient variables and for everything else.</p></li>
<li><p>: This component to be read from each applicable file. Default is for all variables.</p></li>
<li><p>: This compound will be written using the gmsh format. Any data format options specified for each file will overwrite this option. Other options include , , , and . Default is and .</p></li>
</ul></li>
<li><p><em>(optional)</em>: Anything written beyond the first appearing on each line of the input file is regarded as a comment.</p></li>
</ul>
<p><em>Examples:</em></p>
<pre><code>CELL_CONSTANT &lt;test constant&gt; &quot;&lt;cellx[l=1]&gt;^2&quot; ON &lt;boundaries&gt; # a test
FACE_CONSTANT &lt;test constant 2&gt; [m] &quot;&lt;facex[l=2]&gt;&quot; # another test</code></pre>
<h3>Constant type variable defined in</h3>
<p><em>Synopsis:</em></p>
<p>Constant variables defined in are set to numerical values read directly by the executable, rather than expressions interpreted by maxima.</p>
<p><em>Defining statements:</em></p>
<pre><code>CELL_CONSTANT &lt;name&gt; [multiplier*units] value ON &lt;region&gt; options # comments
FACE_CONSTANT &lt;name&gt; [multiplier*units] value ON &lt;region&gt; options # comments
NONE_CONSTANT &lt;name&gt; [multiplier*units] value options # comments
CONSTANT &lt;name&gt; [multiplier*units] value options # comments</code></pre>
<p><em>Statement components:</em></p>
<p>The components of these statements are the same as in section [sec:equation_constants] with the exception of:</p>
<ul>
<li><em>(required)</em>: A numerical value of real or double precision type.</li>
</ul>
<p><em>Examples:</em></p>
<pre><code>CONSTANT &lt;mu&gt; [Pa.s] 1.0d-3 # fluid viscosity
NONE_CONSTANT &lt;rho&gt; [997*kg/m^3] 1.0 # fluid density</code></pre>
<h3>Constant type variable defined per region in</h3>
<p><em>Synopsis:</em></p>
<p>This definition can be used in the file to assign different numerical values to either a cell or face centred constant in specific regions. Two statements are required for this type of constant definition: The first defines the list of regions where the next constant will be set () and the second defines the constant and sets/lists the corresponding numerical values (). The region names in the statement must have the same centring as the following statement. Furthermore, the over which the constant is defined must include all of the regions listed within the previous statement.</p>
<p><em>Defining statements:</em></p>
<pre><code>REGION_LIST &lt;region1&gt; &lt;region2&gt; ... &lt;regionN&gt; # comments
CELL_REGION_CONSTANT &lt;name&gt; [multiplier*units] value1 value2 ... valueN ON &lt;region&gt; options # comments
FACE_REGION_CONSTANT &lt;name&gt; [multiplier*units] value1 value2 ... valueN ON &lt;region&gt; options # comments</code></pre>
<p><em>Statement components:</em></p>
<p>The components of these statements are the same as in section [sec:equation_constants] with the exception of:</p>
<ul>
<li><p>… <em>(required)</em>: A list of regions that have the same centring as the following statement.</p></li>
<li><p>… <em>(required)</em>: A list of numerical values for the constant, corresponding in a one-to-one fashion with the list of regions given in the previous statement.</p></li>
</ul>
<p><em>Examples:</em></p>
<pre><code>REGION_LIST &lt;inlet&gt; &lt;outlet&gt; # some face regions
FACE_REGION_CONSTANT &lt;electric field&gt; [V/m] 10 20. ON &lt;boundaries&gt; </code></pre>
<h3>Transient type variable defined in</h3>
<p><em>Synopsis:</em></p>
<p>Transient variables are used only in transient simulations, and are evaluated at the start of each timestep. Transient variables are typically used to store previous timestep values, or to provide constant data to a simulation that depends explicitly on the time.</p>
<p><em>Defining statements:</em></p>
<pre><code>CELL_TRANSIENT &lt;name&gt; [multiplier*units] &quot;initial expression&quot; &quot;expression&quot; ON &lt;region&gt; options # comments
FACE_TRANSIENT &lt;name&gt; [multiplier*units] &quot;initial expression&quot; &quot;expression&quot; ON &lt;region&gt; options # comments
NONE_TRANSIENT &lt;name&gt; [multiplier*units] &quot;initial expression&quot; &quot;expression&quot; options # comments
NONE_TRANSIENT &lt;name&gt; [multiplier*units] &quot;&quot; &quot;expression&quot; options # this will use the update expression as the initial expression
NONE_TRANSIENT &lt;name&gt; [multiplier*units] &quot;expression&quot; options # the initial expression here depends on rstep</code></pre>
<p><em>Statement components:</em></p>
<p>Along with the information presented in section [sec:equation_constants], the following applies to transient variables:</p>
<ul>
<li><p><em>(required)</em>: If no centring is specified then none centring is assumed.</p></li>
<li><p><em>(required)</em>: Along with the rules detailed in section [sec:equation_constants], transient variables are associated with particular relative timesteps. Relative timesteps, described using the term in this document, indicate how many timesteps previous to the current one the variable refers to. The value of a variable is defined in a similar manner to the direction of a variable, using an index in square brackets at the end of the variable name: For example, would be the time corresponding to the end of the current timestep, would be time from the previous timestep, the time from the (earlier) timestep before that one and so on. If an index is omitted from a definition, then is assumed. Actually, any type of variable can be associated with any particular relative timestep, but it is rare to do this with anything other than a transient variable.</p></li>
<li><p><em>(optional)</em>: This expression is applied once (only) at the start of a simulation, and represents the variable’s initial condition. These initial expressions are applied in the order of increasing (relative timestep), meaning that the current (latest) time value is calculated first, followed by the previous timestep value, and then one before etc. This expression should not depend on any transient variables that have a higher (an earlier timestep) or that are from the same timestep (equal ) but defined later in the input file. If an initial expression is not given at all (no quotation marks present for this field), then the value of zero is assumed if the variable has , or the update expression otherwise. If the initial expression is not specified but quotation marks are present for this field, then the update expression is substituted for the initial expression - ie, a shorthand way of repeating the update expression.</p></li>
<li><p><em>(required)</em>: This expression for the transient variable is applied once at the start of each timestep. These expressions are applied in the order of decreasing (relative timestep), meaning that the earliest time value is calculated first, followed by the next timestep value, until the current time (<span class="math">$\code{rstep}=0$</span>) is reached. Circular references are not allowed in the expression (in practice this is not limiting).</p></li>
<li><p><em>(optional)</em>: If ommitted then by default a cell centred transient will be defined on and a face centred transient on .</p></li>
<li><p><em>(optional)</em>: This is a comma separated list of options. Valid options for transient variables are the same as those for constants, as detailed in section [sec:equation_constants])</p></li>
</ul>
<p><em>Examples:</em></p>
<pre><code>NONE_TRANSIENT &lt;t[r=0]&gt; &quot;0.d0&quot; &quot;&lt;t[r=1]&gt;+&lt;dt&gt;&quot; # current end-of-timestep time (r=0)
NONE_TRANSIENT &lt;t[r=1]&gt; &quot;&lt;t&gt;-&lt;dt&gt;&quot; &quot;&lt;t&gt;&quot; # time at last step (r=1)
NONE_TRANSIENT &lt;t[r=2]&gt; &quot;&lt;t[r=1]&gt;-&lt;dt&gt;&quot; &quot;&lt;t[r=1]&gt;&quot; # time at step before last step (r=2, assuming a constant dt)
NONE_TRANSIENT &lt;z[r=1]&gt; [m] &quot;&lt;z&gt;-&lt;w_0&gt;*&lt;dt&gt;&quot; &quot;&lt;z_real&gt;&quot; # position of ball at last step (r=1)
NONE_TRANSIENT &lt;w[r=1]&gt; [m/s] &quot;&lt;w&gt;&quot; &quot;&lt;w_real&gt;&quot; # velocity of ball at last step (r=1)</code></pre>
<h3>Derived type variable defined in [sec:equation_deriveds]</h3>
<p><em>Synopsis:</em></p>
<p>Derived variables depend on the unknown variables and other previously defined (ie, above in the file) derived variables.</p>
<p><em>Defining statements:</em></p>
<pre><code>CELL_DERIVED &lt;name&gt; [multiplier*units] &quot;expression&quot; ON &lt;region&gt; options # comments
FACE_DERIVED &lt;name&gt; [multiplier*units] &quot;expression&quot; ON &lt;region&gt; options # comments
NONE_DERIVED &lt;name&gt; [multiplier*units] &quot;expression&quot; options # comments
DERIVED &lt;name&gt; [multiplier*units] &quot;expression&quot; options # comments</code></pre>
<p><em>Statement components:</em></p>
<p>Along with the information presented in section [sec:equation_constants], the following applies to derived variables:</p>
<ul>
<li><p><em>(required)</em>: If no centring is specified then none centring is assumed.</p></li>
<li><p><em>(required)</em>: This is an expression for the derived variable in terms of constant, transient, unknown, previously defined derived (appearing above in ) and system variables.</p></li>
<li><p><em>(optional)</em>: If ommitted then by default a cell centred derived will be defined on and a face centred derived on .</p></li>
<li><p><em>(optional)</em>: This is a comma separated list of options. Valid options for derived variables (as well as those given in section [sec:equation_constants]) include:</p>
<ul>
<li><p>: Normally the derivative of this variable’s expression is calculated with respect to each unknown variable (the Jacobian) when performing the Newton-Raphson solution procedure. Including this option sets this derivative to zero. This may be required for functions for which the derivative cannot be calculated or for functions that undergo step changes (not continuous) which are not ammeniable to solution via the Newton-Raphson procedure. Using this option will usually slow convergence.</p></li>
<li><p>: Including one of these options causes the code to check the sign of the derived variable. In theory this could be used for quantities like concentrations that are only physically meaningful when being positive. By using an expression such as and including the option an upper limit for a variable can also be enforced. In practice using these types of limiting conditions to prevent equation singularities slows convergence to an unfeasibly slow rate. It is usually better to choose the form of the equations so that they are stable even for small unphysical excursions, and then check once convergence has been achieved that the results are physical.</p></li>
</ul></li>
</ul>
<p><em>Examples:</em></p>
<pre><code>FACE_DERIVED &lt;tau[l=1,1]&gt; &quot;&lt;p&gt; - &lt;mu&gt;*2.d0*facegrad[l=1](&lt;u[l=1]&gt;)&quot; output
CELL_DERIVED &lt;graddivp[l=1]&gt; &quot;celldivgrad[l=1](&lt;p&gt;)&quot; # divergence based pressure gradient</code></pre>
<h3>Unknown type variable defined in</h3>
<p><em>Synopsis:</em></p>
<p>Unknown variables are those upon which the equations and derived variables ultimately depend.</p>
<p><em>Defining statements:</em></p>
<pre><code>CELL_UNKNOWN &lt;name&gt; [multiplier*units] magnitude &quot;expression&quot; ON &lt;region&gt; options # comments
FACE_UNKNOWN &lt;name&gt; [multiplier*units] magnitude &quot;expression&quot; ON &lt;region&gt; options # comments
NONE_UNKNOWN &lt;name&gt; [multiplier*units] magnitude &quot;expression&quot; options # comments
UNKNOWN &lt;name&gt; [multiplier*units] magnitude &quot;expression&quot; ON &lt;region&gt; options # comments</code></pre>
<p><em>Statement components:</em></p>
<p>Along with the information presented in section [sec:equation_deriveds], the following applies to unknown variables:</p>
<ul>
<li><p><em>(required)</em>: If no centring is specified then cell centring is assumed.</p></li>
<li><p><em>(required)</em>: An order of magnitude estimate (postive and greater than zero real or double precision value) must be specified for all unknown variables. This magnitude is used when checking on the convergence of the solution.</p></li>
<li><p><em>(required)</em>: For an unknown variable the expression specifies the variable’s initial value. The expression may contain constant variables, derived variables, previously defined unknown variables, (initial) transient variables and system variables.</p></li>
<li><p><em>(optional)</em>: If ommitted then by default a cell centred unknown will be defined on and a face centred unknown on .</p></li>
<li><p><em>(optional)</em>: The option is not applicable for unknown variables.</p></li>
</ul>
<p><em>Examples:</em></p>
<pre><code>CELL_UNKNOWN &lt;u[l=1]&gt; 1.d0 &quot;&lt;u_av&gt;&quot; # a velocity component
CELL_UNKNOWN &lt;p&gt; [] 1.d0 &quot;1.d0-&lt;cellx[l=1]&gt;&quot; # pressure
NONE_UNKNOWN &lt;p_in&gt; [Pa] 1.d0 &quot;1.d0&quot; # the pressure at the inlet</code></pre>
<h3>Equation type variable defined in</h3>
<p><em>Synopsis:</em></p>
<p>Equation variables represent the equations to be satisfied. The equation expressions should be formulated so that when the equation is satisfied, the expression equals zero. The number of equations must equal the number of unknown variables. Furthermore, for the system to be well posed the equations must be unknown (no single equation can be made from a combination of the other equations).</p>
<p><em>Defining statements:</em></p>
<pre><code>CELL_EQUATION &lt;name&gt; [multiplier*units] &quot;expression&quot; ON &lt;region&gt; options # comments
FACE_EQUATION &lt;name&gt; [multiplier*units] &quot;expression&quot; ON &lt;region&gt; options # comments
NONE_EQUATION &lt;name&gt; [multiplier*units] &quot;expression&quot; options # comments
EQUATION &lt;name&gt; [multiplier*units] &quot;expression&quot; options # comments</code></pre>
<p><em>Statement components:</em></p>
<p>Along with the information presented in section [sec:equation_deriveds], the following applies to equation variables:</p>
<ul>
<li><p><em>(required)</em>: If no centring is specified then none centring is assumed.</p></li>
<li><p><em>(required)</em>: For an equation variable the expression should equal zero when the equation is satisfied. The expression may contain constant, transient, derived, unknown and system variables.</p></li>
<li><p><em>(optional)</em>: If ommitted then by default a cell centred equation will be defined on and a face centred equation on .</p></li>
</ul>
<p><em>Examples:</em></p>
<pre><code>CELL_EQUATION &lt;continuity&gt; &quot;celldiv(&lt;u_f&gt;)&quot; ON &lt;domain&gt; # continuity
FACE_EQUATION &lt;outlet noslip&gt; &quot;dot(&lt;u[l=:]&gt;,&lt;facetang1[l=:]&gt;)&quot; ON &lt;outlet&gt; # no component tangential to outlet
NONE_EQUATION &lt;p_in for flowrate&gt; &quot;&lt;u_av_calc&gt;-&lt;u_av&gt;&quot; # set flowrate through inlet to give required average velocity</code></pre>
<h3>Output type variable defined in</h3>
<p><em>Synopsis:</em></p>
<p>Output variables are evaluated once convergence of the solution has been reached: They are only for output purposes.</p>
<p><em>Defining statements:</em></p>
<pre><code>CELL_OUTPUT &lt;name&gt; [multiplier*units] &quot;expression&quot; ON &lt;region&gt; options # comments
FACE_OUTPUT &lt;name&gt; [multiplier*units] &quot;expression&quot; ON &lt;region&gt; options # comments
NONE_OUTPUT &lt;name&gt; [multiplier*units] &quot;expression&quot; options # comments
OUTPUT &lt;name&gt; [multiplier*units] &quot;expression&quot; options # comments</code></pre>
<p><em>Statement components:</em></p>
<p>Along with the information presented in section [sec:equation_deriveds], the following applies to output variables:</p>
<ul>
<li><p><em>(required)</em>: If no centring is specified then none centring is assumed.</p></li>
<li><p><em>(required)</em>: For an output variable the expression may contain constant, transient, derived, unknown, equation and system variables.</p></li>
<li><p><em>(optional)</em>: If ommitted then by default a cell centred output variable will be defined on and a face centred output variable on .</p></li>
<li><p><em>(optional)</em>: The option is not applicable for output variables (this option is implicitly set anyway for these variables).</p></li>
</ul>
<p><em>Examples:</em></p>
<pre><code>NONE_OUTPUT &lt;F_drag&gt; [N] &quot;facesum(&lt;facearea&gt;*dot(&lt;facenorm[l=:]&gt;,&lt;tau[l=:,1]&gt;),&lt;cylinder&gt;)&quot; # force on object in axial direction</code></pre>
<h3>Condition type variable defined in</h3>
<p><em>Synopsis:</em></p>
<p>Condition variables control the running of the simulation. They can initiate the following actions: output, stop, convergence and a bell.</p>
<p><em>Defining statements:</em></p>
<pre><code>CELL_CONDITION &lt;name&gt; [multiplier*units] &quot;expression&quot; ON &lt;region&gt; options # comments
FACE_CONDITION &lt;name&gt; [multiplier*units] &quot;expression&quot; ON &lt;region&gt; options # comments
NONE_CONDITION &lt;name&gt; [multiplier*units] &quot;expression&quot; options # comments
CONDITION &lt;name&gt; [multiplier*units] &quot;expression&quot; options # comments</code></pre>
<p><em>Statement components:</em></p>
<p>Along with the information presented in section [sec:equation_deriveds], the following applies to condition variables:</p>
<ul>
<li><p><em>(required)</em>: If no centring is specified then none centring is assumed.</p></li>
<li><p><em>(required)</em>: For a condition variable, if the evaluated expression is positive (<span class="math"> &gt; 0</span>) then the condition is satisfied and the corresponding action will take place. Note that an action will take place if any of the condition variables that correspond to it are positive (in fact, after one positive value is found the remainder are not even evaluated).</p></li>
<li><p><em>(optional)</em>: If ommitted then by default a cell centred condition variable will be defined on and a face centred condition variable on .</p></li>
<li><p><em>(optional)</em>: In addition to the options discussed for the other variables, one or more of the following options may be applied to each condition variable to specify what action it corresponds to:</p>
<ul>
<li><p>: For transient and steady-state simulations, indicates when the Newton loop has converged. Is evaluated at the start of each Newton loop.</p></li>
<li><p>: For a transient simulation, indicates when the simulation should finish. Is evaluated at the end of each successful timestep.</p></li>
<li><p>: For a transient simulation, indicates when the output files should be written. Is evaluated at the end of each successful timestep.</p></li>
<li><p>: For a transient simulation, indicates when a noise should be made (this one’s a bit silly). Is evaluated at the end of each successful timestep.</p></li>
</ul></li>
</ul>
<p><em>Examples:</em></p>
<pre><code>NONE_CONDITION &lt;time based stop condition&gt; &quot;&lt;t&gt;-&lt;tend&gt;&quot; stopcondition # when this becomes true (&gt;0.) the simulation stops
NONE_CONDITION &lt;bouncing bell&gt; &quot;noneif(&lt;z&gt;,-1.d0,1.d0)&quot; bellcondition # is positive when &lt;z&gt; is negative at the end of a timestep
NONE_CONDITION &lt;output test&gt; &quot;&lt;t&gt;-&lt;tout&gt;-&lt;dtout&gt;&quot; outputcondition # this will be true (&gt;0.) whenever we are &lt;dtout&gt; from last output</code></pre>
<h3>Local type variable defined in</h3>
<p><em>Synopsis:</em></p>
<p>Local variables are like derived variables, except that they are not stored, but rather evaluated only when required. Local variables may be used instead of derived variables to save memory. This strategy makes sense if the variable is only going to be used once or twice at each location. Local variables may also be used to split up an otherwise long expression into smaller (and possibly common) sub-statements, dependent on the local conditions. For example, in the examples given below, local variables are used to calculate the second derivative of the normal velocity to a wall, in the normal direction to a wall.</p>
<p><em>Defining statements:</em></p>
<pre><code>CELL_LOCAL &lt;name&gt; [multiplier*units] &quot;expression&quot; ON &lt;region&gt; options # comments
FACE_LOCAL &lt;name&gt; [multiplier*units] &quot;expression&quot; ON &lt;region&gt; options # comments
NONE_LOCAL &lt;name&gt; [multiplier*units] &quot;expression&quot; options # comments
LOCAL &lt;name&gt; [multiplier*units] &quot;expression&quot; options # comments</code></pre>
<p><em>Statement components:</em></p>
<p>Along with the information presented in section [sec:equation_deriveds], the following applies to condition variables:</p>
<ul>
<li><p><em>(required)</em>: If no centring is specified then none centring is assumed.</p></li>
<li><p><em>(required)</em>: A local variable may depend on ‘local’ variables which correspond to the locale of the calling statement: For example, in the following examples we refer to the of the face on which the local variable is calculated. Note that it would not make sense to output this separately over , as the would be undefined.</p></li>
<li><p><em>(optional)</em>: The output region for a local variable is only really used right now to specify what elements are output (should the option be set).</p></li>
</ul>
<p><em>Examples:</em></p>
<pre><code>CELL_LOCAL &lt;u_n&gt; &quot;dot(&lt;u[l=:]&gt;,cellave[lastface](&lt;facenorm[l=:]&gt;))&quot;
CELL_LOCAL &lt;d u_n d x[l=1]&gt; &quot;cellgrad[l=1](&lt;u_n&gt;)&quot;
CELL_LOCAL &lt;d u_n d x[l=2]&gt; &quot;cellgrad[l=2](&lt;u_n&gt;)&quot;
CELL_LOCAL &lt;d u_n d x_n&gt; &quot;dot(&lt;d u_n d x[l=:]&gt;,cellave[lastface](&lt;facenorm[l=:]&gt;))&quot;
FACE_LOCAL &lt;d^2 u_n d x_n^2&gt; &quot;facegrad(&lt;d u_n d x_n&gt;)&quot; ON &lt;boundaries&gt; output</code></pre>
<h3>System variables [sec:system_variables]</h3>
<p><em>TODO</em></p>
<h2>Simulation options</h2>
<ul>
<li><p>: choose between the two types of simulation.</p></li>
<li><p>: end input</p></li>
<li><p>: ignore the text between these statements.</p></li>
<li><p>: add the following options to every subsequent variable, until cleared again using a blank statement. When listed in order, default options precede a variable’s individually specified options - hence, in the case of conflicting option statements, individual options take precedence over default options (ie, the individual options have a higher priority).</p></li>
<li><p>: are the same as , except that they follow a variable’s individually specified options, and so in the case of conflicting option statements, take precedence over the individual options (ie, the override options have a higher priority).</p></li>
<li><p>: choose the type of linear solver to use.</p></li>
</ul>
<h2>Include statements and string replacements</h2>
<p>Include statements allow other input files to be included. These files can be user written, or be from a library of template files within the directory. String substitution that occurs as the file is read in allow these included files to be (basically) used as functions. An ‘unwrapped’ input file that is a handy reference as to how the include statements behaved (and can be used as an input file for subsequent runs) is placed at after every run setup. The include statements are:</p>
<ul>
<li><p>: choose a template directory to look for any files included via any following statements. If no string is specified, then the include root directory name is set equal to that of its parent (including) file. If the blank string is specified, then is set to the blank string and all templates directories (up to two subdirectory levels) are searched for the following included files. The definitions are hierarchical, in that the definition in a child file does not affect that of the parent.</p></li>
<li><p>: command to include a file from the most recent directory (or subdirectory thereof), possibly also specifying file-specific string replacements using the syntax (or the shorter ). If an directory has not been specified (or cancelled with a blank statement) then the templates directories will be searched until a matching file is found (up to two subdirectory levels right now).</p></li>
<li><p>: include the following files from the working directory. This command does not affect and is not influenced by the directory and is (basically) used to include sets of user-written statements (i.e., like a local a function).</p></li>
</ul>
<p>Partnering the include file capability is the ability to read in multiple definitions for the same variable. The ultimate position of a variable’s definition is that of the first definition for that variable. The ultimate expression used for a variable is that given (read in) last. This functionality allows a variable’s expression to be changed from what is used in (say) a template file by specifying a new definition lower in the file, after the template file include statement. Options can also be added to previously specified options for a variable by including more definition statements (that may only contain options and not expressions) lower in the input file. Similarly for units.</p>
<p>There are two types of string replacements that occur when a line from an input file is parsed: i) file-specific replacements, which occur recursively through ‘child’ file inclusions, and ii) general replacements, which occur throughout all files from their point of definition onwards, until (possibly) cancelled. The following demonstrates a general replacement statement specifying two general replacement strings, using a long and short form:</p>
<p>There are certain system generated general replacements that occur automatically unless specifically changed by the user. Use the search hint to find the list of these in .</p>
<p>The above demonstrates how to cancel a search string replacement, using either a long () or short () form. Note that both general and file specific replacements do not occur on a line of an input file if the line is itself a general replacement definition line (specifically, it begins with the keyword), or is an include line for a file (begins with some type of keyword).</p>
<h2>Kernel options</h2>
<p>There are many options that can be used to change the kernels used. For example</p>
<p>specifies that when averaging/differentiating quantities to/at faces, ensure that a second order polynomial would be reproduced precisely.</p>
<h2>Glued boundaries</h2>
<p>Used to implement periodic or reflection boundaries by glueing two boundary face regions together. Boundary regions to be glued must have the same element structure (size and number). Individual element matching between the boundaries is accomplished by matching the closest element locations, relative to the region centroids (much like the and operators).</p>
<p>Example of a periodic boundary glueing the top and bottom boundaries of a domain:</p>
<p>Example of a reflection (axis of symmetry) boundary along the left side of a domain:</p>
<p>In the case of reflection, certain operators (eg, ) need to be aware when they are operating on the component of a vector, that needs to be reflected over this reflection boundary. See the options for each operator.</p>
<h2>Simulation Info</h2>
<p>The following strings can be used within an input file to help keep track of what the file contains. These and other automatically generated info strings are included as comments in most of the output files.</p>
<h2>Solver code</h2>
<p>Most of the arb input file consists of ‘solver code’, which has the generic form of:</p>
<pre >
<span style="color: #808080;">KEYWORD </span><span style="color: #808080;">&lt;possibly a name&gt;</span> <span style="color: #808080;">&quot;other things including delimited strings&quot;</span><span style="color: #808080;"> list_of_comma_separated_options </span><span style="color: #87D7D7;"># trailing comment</span>
</pre>

<p>Solver code can be continued with the ampersand symbol, and is based on the ideas used in free-form fortran (<a href="http://fortranwiki.org/fortran/show/Continuation+lines">http://fortranwiki.org/fortran/show/Continuation+lines</a>):</p>
<pre >
<span style="color: #875FFF;">NONE_CONSTANT</span> <span style="color: #808080;">&lt;a&gt;</span><span style="color: #808080;"> &amp; </span><span style="color: #87D7D7;"># comments are allowed</span>
 <span style="color: #808080;">&quot;</span><span style="color: #808080;">&lt;b&gt;</span> <span style="color: #875FFF;">+</span> <span style="color: #808080;">&lt;c&gt;</span><span style="color: #808080;">&quot;</span><span style="color: #808080;"> &amp; </span><span style="color: #87D7D7;"># on each line, but </span>
  <span style="color: #008787;">nooutput</span> <span style="color: #87D7D7;"># only the last is carried through to the unwrapped_input.arb file</span>
<span style="color: #875FFF;">NONE_CONSTANT</span> <span style="color: #808080;">&lt;b&gt;</span> <span style="color: #808080;">&quot;</span><span style="color: #808080;">&lt;a&amp;</span>
<span style="color: #808080;">    &amp;&gt;</span> <span style="color: #875FFF;">+</span> <span style="color: #808080;">&lt;c&amp;</span>
<span style="color: #808080;">&gt;</span><span style="color: #808080;">&quot;</span><span style="color: #808080;">&amp; </span><span style="color: #87D7D7;"># will work too</span>
</pre>

<p>Note that this type of line continuation is not supported in the string code discussed next.</p>
<h2>String code</h2>
<p>v0.57 introduces the concept of string code, which is code that is embedded within the solver code and used to a) generate string replacement variables (termed string variables), and also to b) generated solver code directly. String code is delimited by {{ and }}. The basic rules of string code are:</p>
<ol>
<li>string replacements are not performed on string code</li>
<li>string code can be placed anywhere within the solver code</li>
<li>there is no limitation to the characters used within string code, EXCEPT for }}, which even enclosed within a string will terminate the string code</li>
</ol>
<p>String code is parsed as perl code, evaluated within perl using the ‘eval’ (string) function (<a href="http://perldoc.perl.org/functions/eval.html">http://perldoc.perl.org/functions/eval.html</a>). For all intents and purposes, whatever is enclosed within {{ and }} is run as a perl subroutine, within the (scope of the) StringCode.pm module of setup_equations.pl, and whatever is returned from that eval (think subroutine) is substituted into the solver code in place of the string code. So the following string code</p>
<pre >
<span style="color: #808080;">{{ return </span><span style="color: #808080;">&quot;</span><span style="color: #875FFF;">TRANSIENT_SIMULATION</span><span style="color: #808080;">&quot;</span><span style="color: #808080;"> }}</span>
</pre>

<p>becomes the following solver code when arb is run,</p>
<pre >
<span style="color: #875FFF;">TRANSIENT_SIMULATION</span>
</pre>

<p>and hence appears as this solver code in the unwrapped_input.arb file. Note that if no return value is specified then any string code block evaluates as an empty string, and hence has no (immediate) effect within the solver code:</p>
<pre >
<span style="color: #808080;">NONE_CON{{ my $a </span><span style="color: #875FFF;">=</span> <span style="color: #FFAF00;">1</span><span style="color: #808080;">; }}STANT </span><span style="color: #808080;">&lt;a&gt;</span> <span style="color: #FFAF00;">1.d0</span> <span style="color: #87D7D7;"># the solver code keyword becomes NONE_CONSTANT here</span>
</pre>

<p>Also note that a print statement within the string code is printed to the standard output (the screen, or output.scr), and not to the solver code:</p>
<pre >
<span style="color: #808080;">{{ print </span><span style="color: #808080;">&quot;</span><span style="color: #875FFF;">INFO</span><span style="color: #808080;">: this message will appear on the screen\n&quot;</span><span style="color: #808080;">; }}</span>
</pre>

<p>Comments and line continuations are allowed in the string code, in the same way that they are allowed in perl code:</p>
<pre >
<span style="color: #808080;">{{</span>
<span style="color: #87D7D7;"># new lines and comments within string code follow perl rules, as the code is parsed as perl code</span>

<span style="color: #808080;">  my $a </span><span style="color: #875FFF;">=</span> <span style="color: #FFAF00;">1</span><span style="color: #808080;">; </span><span style="color: #87D7D7;"># set a local variable to 1</span>
<span style="color: #808080;">  my $b </span><span style="color: #875FFF;">=</span><span style="color: #808080;"> $a</span><span style="color: #875FFF;">*</span><span style="color: #FFAF00;">3</span><span style="color: #808080;">; </span><span style="color: #87D7D7;"># setting another local variable</span>

<span style="color: #808080;">  return $b; </span><span style="color: #87D7D7;"># we are returning the value of $b here</span>

<span style="color: #808080;">}}</span>
</pre>

<p>As each string code block is evaluated using a separate perl eval call, local variables defined within one string code block are not available within subsequent string code blocks:</p>
<pre >
<span style="color: #808080;">{{</span>
<span style="color: #808080;">  my $a </span><span style="color: #875FFF;">=</span> <span style="color: #FFAF00;">1</span><span style="color: #808080;">; set a local variable to </span><span style="color: #FFAF00;">1</span><span style="color: #808080;">, noting that 'use string' and 'use warnings' are turned on in perl</span>
<span style="color: #808080;">  print </span><span style="color: #808080;">&quot;$a\n&quot;</span><span style="color: #808080;">; </span><span style="color: #87D7D7;"># prints the value 1 to the screen</span>
<span style="color: #808080;">}}</span>
<span style="color: #808080;">{{</span>
<span style="color: #808080;">  print </span><span style="color: #808080;">&quot;$a\n&quot;</span><span style="color: #808080;">; </span><span style="color: #87D7D7;"># generates an error as $a is not defined within the scope of this string code block</span>
<span style="color: #808080;">}}</span>
</pre>

<p>Instead, string variables can be used to pass information outside the scope of a particular string code block. The perl subroutine ‘string_set’ is available to set the value of a string variable, and ‘string_eval’ to return its value. The following example could be instead achieved using:</p>
<pre >
<span style="color: #808080;">{{</span>
<span style="color: #808080;">  string_set(</span><span style="color: #808080;">&quot;$a&quot;</span><span style="color: #808080;">,</span><span style="color: #FFAF00;">1</span><span style="color: #808080;">); set a string variable </span><span style="color: #808080;">&quot;$a&quot;</span><span style="color: #808080;"> to </span><span style="color: #FFAF00;">1</span>
<span style="color: #808080;">  print string_eval(</span><span style="color: #808080;">&quot;$a&quot;</span><span style="color: #808080;">).</span><span style="color: #808080;">&quot;\n&quot;</span><span style="color: #808080;">; </span><span style="color: #87D7D7;"># prints the value 1 to the screen</span>
<span style="color: #808080;">}}</span>
<span style="color: #808080;">{{</span>
<span style="color: #808080;">  print string_eval(</span><span style="color: #808080;">&quot;$a&quot;</span><span style="color: #808080;">).</span><span style="color: #808080;">&quot;\n&quot;</span><span style="color: #808080;">; </span><span style="color: #87D7D7;"># prints the value 1 to the screen</span>
<span style="color: #808080;">}}</span>
</pre>

<p>String variables are the same variables used to achieve string replacements within the solver code, however, by default if a string variable name starts with ‘$’, the string variable is given the noreplace option which means that the solver code is not searched/replaced with this particular variable. This option can also be explicitly set at creation time or via the ‘string_option’ subroutine:</p>
<pre >
<span style="color: #808080;">{{ string_set(</span><span style="color: #808080;">&quot;</span><span style="color: #5F5F87;">&lt;&lt;a&gt;&gt;</span><span style="color: #808080;">&quot;</span><span style="color: #808080;">,</span><span style="color: #808080;">&quot;</span><span style="color: #FFAF00;">1.d0</span><span style="color: #808080;">&quot;</span><span style="color: #808080;">,noreplace); }}</span>
<span style="color: #808080;">{{ string_option(</span><span style="color: #808080;">&quot;</span><span style="color: #5F5F87;">&lt;&lt;a&gt;&gt;</span><span style="color: #808080;">&quot;</span><span style="color: #808080;">,noreplace); }}</span>
</pre>

<p>Strings variables can also be deleted, and if set without a value, imply the empty string:</p>
<pre >
<span style="color: #808080;">{{</span>
<span style="color: #808080;">  string_set(</span><span style="color: #808080;">&quot;</span><span style="color: #5F5F87;">&lt;&lt;c&gt;&gt;</span><span style="color: #808080;">&quot;</span><span style="color: #808080;">); </span><span style="color: #87D7D7;"># strings set with no value implies ''</span>
<span style="color: #808080;">  string_delete(</span><span style="color: #808080;">&quot;</span><span style="color: #5F5F87;">&lt;&lt;c&gt;&gt;</span><span style="color: #808080;">&quot;</span><span style="color: #808080;">) </span><span style="color: #87D7D7;"># strings can also be deleted</span>
<span style="color: #808080;">}}</span>
</pre>

<p>String code allows more flexibility in coding arb, and will be employed more in the template files. Looping is possible now using (for example);</p>
<pre >
<span style="color: #808080;">{{</span>
<span style="color: #808080;">  my $loop_code </span><span style="color: #875FFF;">=</span><span style="color: #808080;"> '';</span>
<span style="color: #808080;">  for my $n in ( </span><span style="color: #FFAF00;">0</span><span style="color: #808080;"> .. </span><span style="color: #FFAF00;">2</span><span style="color: #808080;"> ) {</span>
<span style="color: #808080;">    $loop_code .</span><span style="color: #875FFF;">=</span> <span style="color: #808080;">&quot;</span><span style="color: #875FFF;">CONSTANT</span> <span style="color: #808080;">&lt;a&quot;.$n.&quot;&gt;</span><span style="color: #808080;"> $n.d0\n&quot;</span><span style="color: #808080;">;</span>
<span style="color: #808080;">  }</span>
<span style="color: #808080;">  return $loop_code;</span>
<span style="color: #808080;">}}</span>
</pre>

<p>which would evaluate as the solver code</p>
<pre >
<span style="color: #875FFF;">CONSTANT</span> <span style="color: #808080;">&lt;a0&gt;</span> <span style="color: #FFAF00;">0.d0</span>
<span style="color: #875FFF;">CONSTANT</span> <span style="color: #808080;">&lt;a1&gt;</span> <span style="color: #FFAF00;">1.d0</span>
<span style="color: #875FFF;">CONSTANT</span> <span style="color: #808080;">&lt;a2&gt;</span> <span style="color: #FFAF00;">2.d0</span>
</pre>

<p>With some imagination arrays and hashes could even be stored within the string variables (but you’ll have to learn some perl!). Variables defined within setup_equations.pl can also be accessed within the string code, as can generic perl subroutines.</p>
<pre >
<span style="color: #808080;">{{</span>
<span style="color: #808080;">  print </span><span style="color: #808080;">&quot;$::transient_simulation\n&quot;</span><span style="color: #808080;">; </span><span style="color: #87D7D7;"># is a variable defined in main of setup_equations.pl which indicates whether this is a transient simulation or not</span>
<span style="color: #808080;">  if (!($::transient_simulation)) {</span>
<span style="color: #808080;">    print </span><span style="color: #808080;">&quot;</span><span style="color: #875FFF;">WARNING</span><span style="color: #808080;"> $ENV{USERNAME}: did you want to run a transient simulation?\n&quot;</span><span style="color: #808080;">; </span><span style="color: #87D7D7;"># not tested, but should work...</span>
<span style="color: #808080;">  }</span>
<span style="color: #808080;">}}</span>
</pre>

<h2>Code blocks</h2>
<p>Code blocks are separate ‘chunks’ of code that define the scope of the file include paths, as well as the string variables. A new code block is started whenever a new file is included:</p>
<pre >
<span style="color: #875FFF;">INCLUDE_LOCAL</span> <span style="color: #5F5F87;">&quot;some_arb_code&quot;</span> <span style="color: #87D7D7;"># a new block is created after the string &quot;some_arb_code&quot; has been read</span>
</pre>

<p>String code that follows an include statement is included as the first statement in the newly created block:</p>
<pre >
<span style="color: #875FFF;">INCLUDE_LOCAL</span> <span style="color: #5F5F87;">&quot;another_arb_code&quot;</span><span style="color: #808080;"> {{ string_set(</span><span style="color: #808080;">&quot;</span><span style="color: #5F5F87;">&lt;&lt;mu_f&gt;&gt;</span><span style="color: #808080;">&quot;</span><span style="color: #808080;">,</span><span style="color: #808080;">&quot;</span><span style="color: #5F5F87;">&lt;&lt;mu&gt;&gt;</span><span style="color: #808080;">&quot;</span><span style="color: #808080;">); }} </span><span style="color: #87D7D7;"># so the replacement is done on the contents of another_arb_code.arb</span>
</pre>

<p>(Solver) code blocks can also be defined within the one file using the keywords ‘BLOCK’ and ‘END_BLOCK’:</p>
<pre >
<span style="color: #808080;">BLOCK</span>
<span style="color: #808080;">{{ string_set(</span><span style="color: #808080;">&quot;$a&quot;</span><span style="color: #808080;">,</span><span style="color: #808080;">&quot;</span><span style="color: #FFAF00;">1.d0</span><span style="color: #808080;">&quot;</span><span style="color: #808080;">); }}</span>
<span style="color: #808080;">{{ string_set(</span><span style="color: #808080;">&quot;$b&quot;</span><span style="color: #808080;">,</span><span style="color: #808080;">&quot;</span><span style="color: #FFAF00;">2.d0</span><span style="color: #808080;">&quot;</span><span style="color: #808080;">,</span><span style="color: #808080;">&quot;global&quot;</span><span style="color: #808080;">); }}</span>
<span style="color: #808080;">{{ print string_eval(</span><span style="color: #808080;">&quot;$a&quot;</span><span style="color: #808080;">); }} </span><span style="color: #87D7D7;"># prints 1.d0</span>
<span style="color: #808080;">{{ print string_eval(</span><span style="color: #808080;">&quot;$b&quot;</span><span style="color: #808080;">); }} </span><span style="color: #87D7D7;"># prints 2.d0</span>
<span style="color: #808080;">END_BLOCK</span>
<span style="color: #808080;">{{ print string_eval(</span><span style="color: #808080;">&quot;$a&quot;</span><span style="color: #808080;">); }} </span><span style="color: #87D7D7;"># error as $a is no longer defined in the parent block</span>
<span style="color: #808080;">{{ print string_eval(</span><span style="color: #808080;">&quot;$b&quot;</span><span style="color: #808080;">); }} </span><span style="color: #87D7D7;"># prints 2.d0 as $b was defined as a global variable</span>
</pre>

<h2>If statements</h2>
<p>The following solver code shows an if statement:</p>
<pre >
<span style="color: #808080;">IF </span><span style="color: #FFAF00;">1</span>
  <span style="color: #875FFF;">NONE_CONSTANT</span> <span style="color: #808080;">&lt;a&gt;</span> <span style="color: #FFAF00;">1.d0</span>
<span style="color: #808080;">END_IF</span>
</pre>

<p>Code flow through an IF statement is dependent on what follows the ‘IF’ keyword: An empty string or ‘0’ evaluates as false, whereas anything else is true. So the following are true,</p>
<pre >
<span style="color: #808080;">IF </span><span style="color: #FFAF00;">1</span>
<span style="color: #808080;">IF asd afsdf sdg sdgfas </span><span style="color: #87D7D7;"># some comment</span>
<span style="color: #808080;">IF </span><span style="color: #FFAF00;">0</span><span style="color: #808080;"> adfd</span>
<span style="color: #808080;">IF </span><span style="color: #808080;">&quot;</span><span style="color: #FFAF00;">0</span><span style="color: #808080;">&quot;</span> <span style="color: #87D7D7;"># note this!</span>
</pre>

<p>whereas the following are false</p>
<pre >
<span style="color: #808080;">IF </span><span style="color: #FFAF00;">0</span>
<span style="color: #808080;">IF </span><span style="color: #87D7D7;"># possible trailing comment</span>
<span style="color: #808080;">IF</span>
<span style="color: #808080;">IF&amp;</span>
<span style="color: #808080;">  &amp; </span><span style="color: #87D7D7;"># line continuation</span>
</pre>

<p>There are also the continuation statements of ELSE_IF and ELSE demonstrated by:</p>
<pre >
<span style="color: #808080;">IF </span><span style="color: #FFAF00;">0</span>
  <span style="color: #875FFF;">NONE_CONSTANT</span> <span style="color: #808080;">&lt;a&gt;</span> <span style="color: #FFAF00;">1.d0</span>
<span style="color: #808080;">ELSE_IF </span><span style="color: #FFAF00;">1</span>
  <span style="color: #875FFF;">NONE_CONSTANT</span> <span style="color: #808080;">&lt;a&gt;</span> <span style="color: #FFAF00;">2.d0</span>
<span style="color: #808080;">ELSE</span>
  <span style="color: #875FFF;">NONE_CONSTANT</span> <span style="color: #808080;">&lt;a&gt;</span> <span style="color: #FFAF00;">3.d0</span>
<span style="color: #808080;">END_IF</span>
</pre>

<p>IF, ELSE_IF, ELSE and END_IF are all solver code keywords, so require their own lines.</p>
<p>In practice the IF statements would be used in conjunction with string replacements or string code:</p>
<pre >
<span style="color: #808080;">IF </span><span style="color: #8700D7;">&lt;&lt;transientflag&gt;&gt;</span> <span style="color: #87D7D7;"># here &lt;&lt;transientflag&gt;&gt; is a system generated string variable which is replaced by 1 for a transient simulation</span>
  <span style="color: #875FFF;">CONSTANT</span> <span style="color: #808080;">&lt;dt&gt;</span> <span style="color: #FFAF00;">0.1d0</span>
<span style="color: #808080;">ELSE_IF {{ return string_eval(</span><span style="color: #808080;">&quot;$some_string_variable&quot;</span><span style="color: #808080;">) }} </span><span style="color: #87D7D7;"># here the string code enclosed in {{ }} evaluates as the return value, which here would be the value of the string variable $some_string_variable which would have been previously set</span>
  <span style="color: #875FFF;">CONSTANT</span> <span style="color: #808080;">&lt;dt&gt;</span> <span style="color: #FFAF00;">1.d0</span>
<span style="color: #808080;">ELSE</span>
  <span style="color: #875FFF;">CONSTANT</span> <span style="color: #808080;">&lt;dt&gt;</span> <span style="color: #FFAF00;">2.d0</span>
<span style="color: #808080;">END_IF</span>
</pre>

<!-- post comments -->
</div>
<div id="rightheader">
<h1>
arb
</h1>
<h2>
v0.57
</h2>
<h3>
manual
</h3>
</div>
<div id="rightcontents">
<h3>
contents
</h3>
&lt;<contents>&gt;
</div>
</div>
</body>
</html>
<!-- post comments -->


