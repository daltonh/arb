# root_input.arb file created by the arb script
##################################################################################
# the following external fortran files were found by the arb script and are available for inclusion: src/free_surface_functions.f90
EXTERNALS "src/free_surface_functions.f90"
##################################################################################
# the following working directory files found by the arb script: oscillating_volume_of_fluid_drop_in_quadrant.arb
#INCLUDE_WORKING "oscillating_volume_of_fluid_drop_in_quadrant.arb"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../oscillating_volume_of_fluid_drop_in_quadrant.arb without any search/replace combinations
# arb finite volume solver
# Copyright 2009,2010 Dalton Harvie (daltonh@unimelb.edu.au)
#
# arb is released under the GNU GPL.  For full details see the license directory.
#
#-------------------------------------------------------------------
# file equations.in
VERSION 0.50

# the following strings describe the simulation and are passed to the output files
INFO_TITLE "Oscillating vof droplet"
INFO_DESCRIPTION "Oscillating 2D droplet calculated using the volume of fluid method in a quadrant"
INFO_DESCRIPTION+ ": Stationary droplet can be calculated using this but with circle instead of ellipse as initial phi"
INFO_DESCRIPTION+ ": now works for cartesian or cylindrical"
INFO_AUTHOR "Dalton Harvie"
INFO_DATE "05/7/14" # interpreted as the last modification date

# for a cylindrical droplet
#GENERAL_REPLACEMENTS R "#" W "" R "" W "#"
# for a cartesian droplet don't need to change anything from their defaults, just comment out the above, as these two strings are set automatically

# for uniform properties (rho and mu) include the following line
#GENERAL_REPLACEMENTS R "<<uniformcomment>>" W "" R "<<nonuniformcomment>>" W "#"
# or for nonuniform properties (rho and mu) include the following line
#GENERAL_REPLACEMENTS R "<<uniformcomment>>" W "#" R "<<nonuniformcomment>>" W ""

# for a single mesh domain (all on the fluid mesh) include the following
#GENERAL_REPLACEMENTS R "<<singledomaincomment>>" W "" R "<<doubledomaincomment>>" W "#"
# for a double mesh domain everything except the curvature calculation (and its dependent smoothed phi and normals) is done on the fluid domain, and the rest on the free surface domain which is coincident and larger
#GENERAL_REPLACEMENTS R "" W "#" R "#" W ""

INFO_DESCRIPTION+ ": cartesian 2D droplet"
#INFO_DESCRIPTION+ ": cylindrical droplet"
#INFO_DESCRIPTION+ ": uniform properties (rho and mu)"
INFO_DESCRIPTION+ ": nonuniform properties (rho and mu)"
INFO_DESCRIPTION+ ": done on a single domain"
#INFO_DESCRIPTION+ ": done on a double (fluid + free surface) domain"

#-------------------------------------------------------------------
# MSH_FILE instructs arb to read or write a gmsh file (location is read location - write location will always be within the output directory)
# output options are: output,centringoutput,meshoutput,centringmeshoutput,nooutput
# input options are: input,centringinput,meshinput,centringmeshinput,noinput
# data output format options for CELL centred data (which overwrite individual variable options if specified): elementdata,elementnodedata,elementnodelimiteddata
# vtk file output options are: vtkoutput,centringvtkoutput,meshvtkoutput,centringmeshvtkoutput,novtkoutput (novtkoutput is the default)
# dat file output options are: dat_output,centringdat_output,meshdat_output,centringmeshdat_output,nodat_output (nodat_output is the default)
MSH_FILE "free_surface_quadrant_extruded_structured_fluid.msh" nooutput
#MSH_FILE "free_surface_quadrant_extruded_structured_free_surface.msh" nooutput
#MSH_FILE "output/latest.output.msh" input

#-------------------------------------------------------------------
# geometry stuff

GLUE_FACES <fluid west> reflect=1
#GLUE_FACES <free surface west> reflect=1
#GLUE_FACES <free surface centre west> reflect=1
GLUE_FACES <fluid south> reflect=2
#GLUE_FACES <free surface south> reflect=2
#GLUE_FACES <free surface centre south> reflect=2

# CELL_REGION/FACE_REGION specified by: <name> "location string" # comments
# where location string could be: "AT x1 x2 x3" for a single point closest to these coordinates
# where location string could be: "WITHIN BOX x1_min x2_min x3_min x1_max x2_max x3_max" for all elements within a box defined by the minimum and maximum coordinate values
# where location string could be: "COMPOUND +<a region>-<another region>" for a + and - compound region list
# where location string could be: "BOUNDARY OF <a region>" - boundary faces/cells contained within or surrounding <a region>
# where location string could be: "DOMAIN OF <a region>" - domain faces/cells contained within <a region>
# where location string could be: "ASSOCIATED WITH <a region>" - faces/cells both contained within and surrounding <a region>
# where location string could be: "SURROUNDS <a region>" - faces/cells that surround <a region>, irrespective of whether they are boundary or domain elements - right now only works when <a region> is cell centred

#INCLUDE_ROOT "free_surface/volume_of_fluid"
# INFO: setting include root directory to free_surface/volume_of_fluid
# commands to form the single mesh regions from the fluid msh file
#INCLUDE "single_region_formation"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/single_region_formation.arb without any search/replace combinations
# regions specific to fluid mesh
FACE_REGION <walls> "COMPOUND <boundaries>"
FACE_REGION <one face> "AT 1.d+4 1.d+4 0.d0 PART OF <walls>"
FACE_REGION <walls sans one face> "COMPOUND <walls>-<one face>"
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/single_region_formation.arb
#--------------------------------------------------------
# commands to form the double mesh regions from both the fluid and free surface msh files
# also do general region name replacements
#INCLUDE "double_region_formation"

# commands to replace all generic regions with fluid msh equivalents
#INCLUDE "fluid_replacements"

#-------------------------------------------------------------------
# user-defined constants

#KERNEL_OPTIONS polynomialorder=2,polynomialaverageorder=2

# setup basic cylindrical general replacements by including the following two lines
#INCLUDE_ROOT "general"
#INCLUDE "cylindrical_reflect_r1z2"
# these statements only necessary in cartesian as already included in above files, but GENERAL_REPLACEMENT statements can't be commented out by other strings, so just repeat them
#GENERAL_REPLACEMENTS REPLACE "<<dim3comment>>" WITH "#" # comment out any references to the third dimension in any included files
#GENERAL_REPLACEMENTS REPLACE "<<reflect=1>>" WITH "reflect=1"
# include this for both cylindrical and cartesian when using a quadrant
#GENERAL_REPLACEMENTS REPLACE "<<reflect=2>>" WITH "reflect=2"

# bring in default physical and numerical constants
#INCLUDE_ROOT "navier_stokes"
# INFO: setting include root directory to navier_stokes
#INCLUDE "nondimensional_constants"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/nondimensional_constants.arb without any search/replace combinations
# use this constants file if solving nondimensionally

#INCLUDE "constants"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/constants.arb without any search/replace combinations
# physical data
CONSTANT <mu> [Pa.s] 1.d-3 # viscosity of liquid
CONSTANT <rho> [kg/m^3] 1.d0 # density
CONSTANT <u_av> [m/s] 1.d0 # required average inlet velocity (if used, sets flowrate through inlet)

# replace any references to the face centred fluid properties with the constant values
# get rid of these replacements and define alternative statements for the face centred fluid properties if they do vary
#GENERAL_REPLACEMENTS REPLACE "<mu_f>" WITH "<mu>" REPLACE "<rho_f>" WITH "<rho>"

# setup transient and steady-state general replacements that are specific to navier-stokes equations, based on simulation type
# NB, this could be overwritten if using a transient simulation of the steady-state equations for example
##GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "" R "<<steadystatenavierstokescomment>>" W "#"
#GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "#" R "<<steadystatenavierstokescomment>>" W ""

# now just assume that simulation is steady-state, overwriting this with the transient replacments in the transient_setup files
#GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "#" R "<<steadystatenavierstokescomment>>" W ""

# numerical data
CONSTANT <C_{Rhie-Chow}> [] 1.0d+0 # multiplier for Rhie-Chow-type velocity interpolation
CONSTANT <adv_limiter> [] 1.d0 # multiplier used to limit gradients when calculating advection fluxes

# for reference calculate some nondimensional quantities
# these should be overwritten by real nondimensional quantities if this is a nondimensional problem

# this bit of code taken from level set routines, and identical
# finds minimum distance to walls
FACE_LOCAL <ls_boundary_vector[l=1]> "<facex[l=1]>-faceave[lastcell](<cellx[l=1]>)"
FACE_LOCAL <ls_boundary_vector[l=2]> "<facex[l=2]>-faceave[lastcell](<cellx[l=2]>)"
#FACE_LOCAL <ls_boundary_vector[l=3]> "<facex[l=3]>-faceave[lastcell](<cellx[l=3]>)"
CELL_LOCAL <ls_minimum_boundary_distance> "sqrt(facemin(dot(<ls_boundary_vector[l=:]>,<ls_boundary_vector[l=:]>),region=<walls>))"

CONSTANT <a_lengthscale> "cellmax(<ls_minimum_boundary_distance>,region=<domain>)" # an estimate of the mesh lengthscale (channel half-width) based on the minimum domain -> wall distance
CONSTANT <Re> "<u_av>*<rho>*<a_lengthscale>/<mu>" # Reynolds number
# INCLUDE FINISHED for ../templates/navier_stokes/constants.arb
#--------------------------------------------------------

# set Reynolds number here to a value so that it isn't left as a function of <mu> from constants
CONSTANT <Re> [1] 1.d-2 # Reynolds number, overwrite this after this file is included

# convert dimensional parameters to nondimensional
CONSTANT <mu> "1.d0/<Re>"
CONSTANT <rho> 1.d0
CONSTANT <u_av> 1.d0
# INCLUDE FINISHED for ../templates/navier_stokes/nondimensional_constants.arb
#--------------------------------------------------------
#INCLUDE "nonuniform_properties" # this just cancels the previous general property replacements on <mu> and <rho>
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/nonuniform_properties.arb without any search/replace combinations
# for now this just cancels the general variable property replacements done in constants.arb
#GENERAL_REPLACEMENTS CANCEL "<mu_f>" CANCEL "<rho_f>"
# INCLUDE FINISHED for ../templates/navier_stokes/nonuniform_properties.arb
#--------------------------------------------------------
#INCLUDE_ROOT "volume_of_fluid"
# INFO: setting include root directory to volume_of_fluid
#INCLUDE "nondimensional_constants"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/nondimensional_constants.arb without any search/replace combinations
# use this constants file if solving nondimensionally

#INCLUDE "constants"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/constants.arb without any search/replace combinations
# physical data
CONSTANT <sigma> [N/m] 0.072d0 # surface tension coefficient

# now define some nondimensional reference data
CONSTANT <Ca> "<u_av>*<mu>/<sigma>"
CONSTANT <We> "<Ca>*<Re>"
CONSTANT <S> "1.d0/(<We>+<Ca>)"
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/constants.arb
#--------------------------------------------------------

CONSTANT <S> 1.d+3 # surface tension strength nondimensional number, see harvie 2004

# calc these from the above and <Re> (should be set explicitly from navier_stokes/nondimensional_constants)
CONSTANT <We> "1.d0/(<S>*(1.d0+1.d0/<Re>))"
CONSTANT <Ca> "<We>/<Re>"

# convert dimensional parameters to nondimensional, using inertial scaling for pressure and surface tension
CONSTANT <sigma> [1] "1.d0/<We>"
CONSTANT <mu> "1.d0/<Re>"
CONSTANT <rho> 1.d0
CONSTANT <u_av> 1.d0
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/nondimensional_constants.arb
#--------------------------------------------------------
# calculate the mac2 cartesian vof velocity errors for reference (http://dx.doi.org/10.1016/j.apm.2005.08.015)
#INCLUDE "parasitic_mac2_correlation"
#INCLUDE "parasitic_nonuniform_properties_mac2_correlation"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/parasitic_nonuniform_properties_mac2_correlation.arb without any search/replace combinations
# calculates the parasitic current magnitude based on dhamm06 paper, using nondimensional numbers <We> and <Ca>
# now for nonuniform density and viscosity

CONSTANT <parasitic_mac2_celldxave> "cellsum(<celldxmax>,region=<domain>)/cellsum(1.d0,region=<domain>)"
CONSTANT <parasitic_mac2_uu_V> "2.d0*nonemax(<vof_rho_d_ratio>,1.d0)/(nonemax(<Ca>,<tinyish>)*(1.d0+<vof_rho_d_ratio>)*nonemin(<vof_mu_d_ratio>,1.d0))"
CONSTANT <parasitic_mac2_a_V> 6.4d-4
CONSTANT <parasitic_mac2_uu_A> "sqrt(2.d0/(nonemax(<We>,<tinyish>)*(1.d0+<vof_rho_d_ratio>)*<parasitic_mac2_celldxave>))"
CONSTANT <parasitic_mac2_a_A> 6.4d-2
NONE_TRANSIENT <parasitic_mac2_uu_T> "0.d0" "2.d0*<t>/(nonemax(<We>,tinyish)*(1.d0+<vof_rho_d_ratio>)*(<parasitic_mac2_celldxave>**2))" nostepoutput
CONSTANT <parasitic_mac2_a_T> 8.3d-3
CONSTANT <parasitic_mac2_u_V> "<parasitic_mac2_uu_V>*<parasitic_mac2_a_V>" stepoutput
CONSTANT <parasitic_mac2_u_A> "<parasitic_mac2_uu_A>*<parasitic_mac2_a_A>" stepoutput
NONE_TRANSIENT <parasitic_mac2_u_T> "" "<parasitic_mac2_uu_T>*<parasitic_mac2_a_T>" stepoutput
NONE_TRANSIENT <parasitic_mac2_u_p> "" "nonemin(<parasitic_mac2_u_V>,nonemin(<parasitic_mac2_u_A>,<parasitic_mac2_u_T>))" stepoutput
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/parasitic_nonuniform_properties_mac2_correlation.arb
#--------------------------------------------------------
# for nonuniform properties, define them
#INCLUDE "nondimensional_nonuniform_properties"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/nondimensional_nonuniform_properties.arb without any search/replace combinations
# include this to define varying properties
CONSTANT <vof_rho_d_ratio> 1.d0 # dimensional <rho_d>/<rho_c>
CELL_LOCAL <vof_rho_c[r=0]> "(<vof_phi_lim>*(<vof_rho_d_ratio>-1.d0)+1.d0)*<rho>" ON <all cells>
CELL_LOCAL <vof_rho_c[r=1]> "(<vof_phi[r=1]>*(<vof_rho_d_ratio>-1.d0)+1.d0)*<rho>" ON <all cells>
FACE_LOCAL <vof_rho_advection_f[r=1]> "(<vof_phi_f_adjusted[r=1]>*(<vof_rho_d_ratio>-1.d0)+1.d0)*<rho>" ON <all faces> # advection interpolation to use in fluxes calculation
FACE_LOCAL <vof_rho_f> "(<vof_phi_lim>*(<vof_rho_d_ratio>-1.d0)+1.d0)*<rho>" ON <all faces> # simple interpolation to use in velocity correction calculation
CONSTANT <vof_mu_d_ratio> 1.d0 # dimensional <mu_d>/<mu_c>
CELL_LOCAL <vof_mu_c> "(cellmax(<vof_phi_lim>,0.d0)*(<vof_mu_d_ratio>-1.d0)+1.d0)*<mu>" ON <all cells>
FACE_LOCAL <vof_mu_f> "faceave(<vof_mu_c>)" ON <all faces>
FACE_LOCAL <vof_mu_harmonic_f> "faceave[harmonic](<vof_mu_c>)" ON <all faces>
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/nondimensional_nonuniform_properties.arb
#--------------------------------------------------------

#-------------------------------------------------------------------

# for test simulation just do a few timesteps
#TIMESTEPOUT 1
TIMESTEPMAX 5 # just compute the first 5 timesteps for this trial simulation
NEWTSTEPMAX 100
NEWTSTEPDEBUGOUT 90

# physical data, now for nondimensional uniform properties
# set these
#CONSTANT <Re> 1.d+2
CONSTANT <Re> 1.d+2
CONSTANT <S> 1.d+1 # surface tension strength nondimensional number, see harvie 2004, applied mathematical modelling (http://dx.doi.org/10.1016/j.apm.2005.08.015)
# for nonuniform properties, express as a ratio between the disperse phase and the continuous phase (which is used as the properties scale)
CONSTANT <vof_rho_d_ratio> 1.d+1 # dimensional <rho_d>/<rho_c>
CONSTANT <vof_mu_d_ratio> 1.d+1 # dimensional <mu_d>/<mu_c>

#CONSTANT <t_end> [] 1.d+2 # time for simulation to stop
CONSTANT <t_end> [] 1.d2 # time for simulation to stop
#CONSTANT <t_end> [] 1.d-2 # time for simulation to stop
CONSTANT <celldxave> "cellsum(<celldxmax>,region=<domain>)/cellsum(1.d0,region=<domain>)" # average cell dimension
CONSTANT <dt_initial> [] "1.d-4*<celldxave>" # initial timestep based on cell dimension, expecting a velocity of magnitude around 1
#CONSTANT <dt_out> [] 1.d-1 # time between output
CONSTANT <dt_out> [] "<t_end>/50.d0" # time between output
#CONSTANT <dt_surf> "0.5d0*sqrt(0.5d0*<We>*<celldxave>^3/<pi>)"
CONSTANT <dt_surf> "huge"
# dynamic timestep constants
CONSTANT <dt_increase> 1.2d0
CONSTANT <dt_max> "<dt_initial>*1.d4"
CONSTANT <dt_min> "<dt_initial>*1.d-3"
CONSTANT <CFL_max> 0.25d0

# transient bits
TRANSIENT_SIMULATION

# dynamic timestep, next 4 lines
NONE_TRANSIENT <dt[r=1]> "<dt_initial>" "<dt>" stepoutput
FACE_TRANSIENT <u_f[r=1]> "0.d0" "<u_f>" ON <all faces>
CELL_TRANSIENT <CFL local[r=1]> "" "<dt[r=1]>*facesum(faceif(<facedivop>*<u_f[r=1]>,<facedivop>*<u_f[r=1]>,0.d0),region=<celljfaces>)" ON <domain> output
#CELL_TRANSIENT <CFL local[r=1]> "" "<dt[r=1]>*facesum(faceif(<facedivop>*<u_f[r=1]>,1.d0*<facedivop>*<u_f[r=1]>,0.d0),region=<celljfaces>)/1.d0" ON <domain> output
NONE_TRANSIENT <CFL[r=1]> "" "cellmax(<CFL local[r=1]>,region=<domain>)" output
NONE_TRANSIENT <dt[r=0]> "<dt_initial>" "nonemin(nonemax(nonemin(nonemin(<dt_increase>,<CFL_max>/nonemax(<CFL[r=1]>,<tiny>))*<dt[r=1]>,<dt_max>),<dt_min>),<dt_surf>)" stepoutput,input
# constant timestep, next 1 line
#NONE_CONSTANT <dt> "<dt_initial>"

NONE_TRANSIENT <t[r=0]> "0.d0" "<t[r=1]>+<dt[r=0]>" # time
NONE_TRANSIENT <t[r=1]> "<t>-<dt[r=0]>" "<t>" # time at last step
NONE_CONDITION <output test> "<t>-<t_out>-<dt_out>+<dt>*1.d-10" outputcondition # this will be true (>0.) whenever we are <dt_out> from last output
NONE_OUTPUT <t_out> "<t>" stepoutputnoupdate # this will record the time of the last output
NONE_CONDITION <stop test> "<t>-<t_end>" stopcondition # when this becomes true (>0.) the simulation stops

CELL_UNKNOWN <p> [] "(2.d0^0)*<vof_phi>/<We>" ON <all cells> elementdata # pressure
CELL_UNKNOWN <u[l=1]> [] "0.d0" ON <all cells> magnitude=1.d0 # velocity component
CELL_UNKNOWN <u[l=2]> [] "0.d0" ON <all cells> magnitude=1.d0 # velocity component

CELL_TRANSIENT <u[l=1,r=1]> "0.d0" "<u[l=1]>" ON <all cells>
CELL_TRANSIENT <u[l=2,r=1]> "0.d0" "<u[l=2]>" ON <all cells>

# CSF based levelset formulation with reinitialisation
#INCLUDE_ROOT "volume_of_fluid"
# INFO: setting include root directory to volume_of_fluid
#INCLUDE "setup"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/setup.arb without any search/replace combinations
# first set up some constants relating to the discretisation

# phi fraction below which (for either phase) indicates that we aren't in an interface cell 
# there is a default value for this set in free_surface_functions.f90 (phitol_default) which will be used in the vof-specific functions if this is not passed to them explicitly
CONSTANT <vof_phi_tol> 1.d-8
# convert this to a single tolerance on the gradient of phi also, using the average celldxmax within the domain
NONE_CONSTANT <celldxave> "cellsum(<celldxmax>,region=<domain>)/cellsum(1.d0,region=<domain>)" # average cell dimension, exactly the same as defined in navier_stokes files
NONE_CONSTANT <vof_phigrad_tol> "<vof_phi_tol>/<celldxave>" # use this as a standard phigrad tolerance

# this is the vof function, defined on all cells
CELL_UNKNOWN <vof_phi> [] "<vof_phi_initial>" ON <all cells> magnitude=1.d0
#CELL_LOCAL <vof_phi_lim> "cellmax(cellmin(<vof_phi>,1.d0),0.d0)"
# now this is a derived, so that newtstepmax can be used with it to turn off implicit iterations if newton loop is not converging
CELL_DERIVED <vof_phi_lim> "cellmax(cellmin(<vof_phi>,1.d0),0.d0)" ON <all cells> newtstepmax=20
# update vof, while rounding to identify interface cells
CELL_LOCAL <vof_phi_rounded> "cellif(<vof_phi>-<vof_phi_tol>,cellif(1.d0-<vof_phi_tol>-<vof_phi>,<vof_phi>,1.d0),0.d0)"
CELL_TRANSIENT <vof_phi[r=1]> "<vof_phi_rounded>" "<vof_phi_rounded>" ON <all cells> nooutput
# update without rounding
#CELL_TRANSIENT <vof_phi[r=1]> "<vof_phi>" "<vof_phi>" ON <all cells> nooutput

CELL_LOCAL <vof_phi_initial> "0.d0" # default initial phi value - set this to something in the actual input file

# also define a mask that may be required in smoothing routines that defines which cells are interface cells or not
# should think more carefully about <vof_phi_tol> here
#CELL_LOCAL <vof_interface_mask> "cellif(cellmax(<vof_phi_lim>,region=<adjacentcellicells>)-cellmin(<vof_phi_lim>,region=<adjacentcellicells>)-<vof_phi_tol>,1.d0,0.d0)" ON <all cells>
# now make this a derived and limit variation to newtstepmax=3 - for CFL < 1 there is a bit of slack in this mask which should mean that this doesn't matter
#CELL_DERIVED <vof_interface_mask> "cellif(cellmax(<vof_phi_lim>,region=<adjacentcellicells>)-cellmin(<vof_phi_lim>,region=<adjacentcellicells>)-<vof_phi_tol>,1.d0,0.d0)" ON <all cells> newtstepmax=3
CELL_TRANSIENT <vof_interface_mask> "" "cellif(cellmax(<vof_phi_lim>,region=<adjacentcellicells>)-cellmin(<vof_phi_lim>,region=<adjacentcellicells>)-<vof_phi_tol>,1.d0,0.d0)" ON <all cells>
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/setup.arb
#--------------------------------------------------------

# define real initial vof
NONE_CONSTANT <vof_phi_initial_tol> 1.d-4 # accuracy in computing initial shapes (in terms of volume fraction per cell)
# circle (cylinder/sphere)
CONSTANT <radius1> 1.0d0
CELL_CONSTANT <vof_phi_initial_saved> "cellvofphishape[sphere](size[l=1]=2.d0*<radius1>,centre[l=1]=0.d0,centre[l=2]=0.d0,phitol=<vof_phi_initial_tol>)" ON <all cells> output,elementdata
# ellipse
#CONSTANT <radius_a> 0.9d0
#CONSTANT <radius_b> 1.1d0
#CELL_CONSTANT <vof_phi_initial_saved> "cellvofphishape[ellipsoid](size[l=1]=2.d0*<radius_a>,size[l=2]=2.d0*<radius_b>,centre[l=1]=0.d0,centre[l=2]=0.d0,phitol=<vof_phi_initial_tol>)" ON <all cells> output,elementdata
CELL_LOCAL <vof_phi_initial> "<vof_phi_initial_saved>" ON <all cells>

# the following curvature and related cell centred unit normal and smooth phi calculations are done on the free surface mesh
#INCLUDE "cancel_fluid_replacements"
#INCLUDE "link_double_domain_variables" # NB, has to be done while no region replacements are active, so do it here but as only involves locals could go in other places (start of file eg)
#INCLUDE "free_surface_replacements"

# calculate the interface curvature, using a 2D expansion of the unit normals
#INCLUDE "interface_geometry_2D"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/interface_geometry_2D.arb without any search/replace combinations
# create <vof_phi_delta> either by using local to link to <vof_phi>
#INCLUDE "phi_delta"
# or convolving <vof_phi> to create an expanded/smoothed <vof_phi_delta>
#INCLUDE "expand_phi_delta" R "<<maxseparation>>" W "1" # maxseparation controls thickness of delta region, and hence also magnitude of currents - smoothing constant is now linked to this parameter
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/expand_phi_delta.arb with the following search/replace combinations: replace <<maxseparation>> with 1
# used an expanding (smoothing) convolution to find vof_phi_delta from vof_phi

#GENERAL_REPLACEMENTS R "1" W "2"

#INCLUDE "convolve_variable_constant" R "<vof_variable_default>" W "<vof_phi>" R "<vof_variable_convolve_constant>" W "<vof_phi_delta_expand_constant>" R "<vof_variable>" W "<vof_phi>" R "<vof_variable_convolve>" W "<vof_phi_delta>" R "<vof_variable_mask>" W "<vof_interface_mask>" R "<vof_variable_convolve_mask" W "<vof_phi_delta_mask" R "<vof_variable_convolve" W "<vof_phi_delta_expand" R "<vof_variable" W "<vof_phi_delta"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/convolve_variable_constant.arb with the following search/replace combinations: replace <vof_variable_default> with <vof_phi>: replace <vof_variable_convolve_constant> with <vof_phi_delta_expand_constant>: replace <vof_variable> with <vof_phi>: replace <vof_variable_convolve> with <vof_phi_delta>: replace <vof_variable_mask> with <vof_interface_mask>: replace <vof_variable_convolve_mask with <vof_phi_delta_mask: replace <vof_variable_convolve with <vof_phi_delta_expand: replace <vof_variable with <vof_phi_delta
# convolving (smoothing or taking derivative) of <vof_phi> based on a single separation loop
# needs <vof_interface_mask> set and produces <vof_phi_delta> and <vof_phi_delta_mask[r=0 and 1]>
# needs a local of <vof_phi_delta_expand_weight> set afterwards too if required (defaults to 1)

# needs the following set:
#GENERAL_REPLACEMENTS R "1" W "3" # which can also have other options such as 4,faceseparation
#GENERAL_REPLACEMENTS R "<vof_phi_delta" W "<vof_phi"
#GENERAL_REPLACEMENTS R "<<dynamic_variable>>" W "DERIVED" or "CONSTANT" depending on whether weight function depends on unknowns or is constant
#GENERAL_REPLACEMENTS R "<vof_phi>" W "0.d0" or give it a value - this is the value given to the <vof_phi_delta> outside of the <vof_phi_delta_mask>

# general convolution setup, same for every
# find normalised distance between cell in separation loop and cell centre
#CELL_LOCAL <vof_convolve_dist^2> "dot(<celltoseparationicellr[l=:]>,<celltoseparationicellr[l=:]>)"
CELL_LOCAL <vof_convolve_dist^2> "<celltoseparationicellrsquared>"
#CELL_CONSTANT <vof_convolve_eps_centre^2> "cellmin(cellmin(<celldxmin>,region=<adjacentcellicells>),2.d0*<celldxkernel>)**2" ON <all cells>
CELL_CONSTANT <vof_convolve_eps_centre^-2> "cellmin(cellmin(<celldxmin>,region=<adjacentcellicells>),2.d0*<celldxkernel>)**(-2)" ON <all cells>
CELL_LOCAL <vof_convolve_eps^-2> "cellfromcellave[separationcentre](<vof_convolve_eps_centre^-2>)" ON <all cells>

# define kernels here
# hyperbolic
#CELL_LOCAL <vof_phi_smooth_kernel> "1.d0/(<vof_smooth_dist^2>/<vof_smooth_eps^2>+<vof_phi_smooth_constant>)"
#CELL_LOCAL <vof_phi_delta_expand_kernel> "1.d0/(<vof_convolve_dist^2>/<vof_convolve_eps^2>+<vof_phi_delta_expand_constant>/5.d0)*<cellvol>"
# hyperbolic + sqrt
#CELL_LOCAL <vof_phi_smooth_kernel> "1.d0/(sqrt(<vof_smooth_dist^2>/<vof_smooth_eps^2>)+<vof_phi_smooth_constant>)"
#CELL_LOCAL <vof_phi_delta_expand_kernel> "1.d0/(sqrt(<vof_convolve_dist^2>/<vof_convolve_eps^2>)+<vof_phi_delta_expand_constant>/5.d0)*<cellvol>"
# hyperbolic + squared
#CELL_LOCAL <vof_phi_delta_expand_kernel> "1.d0/((<vof_convolve_dist^2>/<vof_convolve_eps^2>)^2+<vof_phi_delta_expand_constant>/2.d0)*<cellvol>"
#CELL_LOCAL <vof_phi_delta_expand_kernel> "<cellvol>/((<vof_convolve_dist^2>/<vof_convolve_eps^2>+<vof_phi_delta_expand_constant>)**2)"
CELL_LOCAL <vof_phi_delta_expand_kernel> "<cellvol>/((<vof_convolve_dist^2>*<vof_convolve_eps^-2>+<vof_phi_delta_expand_constant>)**2)" # multiplication is usually faster than division
# exponential (guassian)
# use constant = 1
#CELL_LOCAL <vof_phi_smooth_kernel> "exp(-<vof_smooth_dist^2>/(<vof_smooth_eps^2>*<vof_phi_smooth_constant>))"
#CELL_LOCAL <vof_phi_delta_expand_kernel> "exp(-<vof_convolve_dist^2>/(<vof_convolve_eps^2>*<vof_phi_delta_expand_constant>))*<cellvol>" # gaussian
NONE_CONSTANT <vof_phi_delta_expand_constant> 1.0d0
# exponential + sqrt
# use constant = 1
#CELL_LOCAL <vof_phi_smooth_kernel> "exp(-sqrt(<vof_smooth_dist^2>/<vof_smooth_eps^2>)/<vof_phi_smooth_constant>)"
# hyperbolic based on separation rather than distance
# requires constant ~ 0.1 for power = 1
#CELL_LOCAL <vof_phi_smooth_kernel> "1.d0/((<separation>+<vof_phi_smooth_constant>)**<vof_phi_smooth_power>)"
# with <vof_phi_smooth_constant> 0.125d0 stable, but currents could be smaller
# with <vof_phi_smooth_constant> 0.25d0 interface is too jaggered
#CELL_LOCAL <vof_phi_smooth_kernel> "1.d0/(<separation>+<vof_phi_smooth_constant>)"

# a mask of where theta_expanded is defined, which is based on the previous timestep mask, but expanded a little
# also define a mask of where variables are changed
CELL_DERIVED <vof_phi_delta_mask> "cellif(<vof_phi_delta_mask_plus[r=1]>,cellmax[maxseparation=1](<vof_interface_mask>,region=<all cells>),0.d0)"
# define a smoothing kernel, which is also used in smooth_normals.arb
CELL_TRANSIENT <vof_phi_delta_mask[r=1]> "1.d0" "<vof_phi_delta_mask>" ON <all cells>
CELL_TRANSIENT <vof_phi_delta_mask_plus[r=1]> "" "cellmax(<vof_phi_delta_mask[r=1]>,region=<adjacentcellicells>)" ON <all cells>

# now do the convolving
CELL_CONSTANT <vof_phi_delta_expand_denominator> "cellsum[maxseparation=1](<vof_phi_delta_expand_kernel>,region=<all cells>)" ON <all cells>
# now defaults to unsmoothed variable where convolved mask isn't present
CELL_DERIVED <vof_phi_delta> "cellif(<vof_phi_delta_mask>,cellsum[maxseparation=1](<vof_phi>*<vof_phi_delta_expand_kernel>,region=<all cells>)/<vof_phi_delta_expand_denominator>,<vof_phi>)" ON <all cells>
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/convolve_variable_constant.arb
#--------------------------------------------------------
#NONE_CONSTANT <vof_phi_delta_expand_constant> 0.5d0

# for structured uniform meshes, seems to be that <vof_phi_delta_expand_constant> can be approx equal to 1 (or even a bit larger) without significant limitation by maxseparation
# if the constant becomes much larger than the maxseparation then the simulation becomes unstable
# so use maxseparation to set constant here, and control size of delta region (and hence magnitude of errors) by maxseparation
#NONE_CONSTANT <vof_phi_delta_expand_constant> "1+1.d0"
NONE_CONSTANT <vof_phi_delta_expand_constant> "1"
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/expand_phi_delta.arb
#--------------------------------------------------------

# delta is discretised dirac delta function used in the surface tension force
# create <vof_phi_delta_f>, <vof_delta> and associated mask from <vof_phi_delta>
#INCLUDE "delta"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/delta.arb without any search/replace combinations
# here we create the delta function that is used to
#  1) apply the surface tension force
#  2) weighting in the kappa_f interpolation

# interpolate to faces for use in creating delta function
#FACE_DERIVED <vof_phi_delta_f> "faceave(<vof_phi_delta>)" ON <all faces> # double limited incase averaging kernels are a bit skewy (eg, on poor unstructured meshes)
# for consistency with pressure discretisation must be interpolated the same way, except here also bounded
FACE_DERIVED <vof_phi_delta_f> "facemax(facemin(faceave(<vof_phi_delta>),1.d0),0.d0)" ON <all faces> # double limited incase averaging kernels are a bit skewy (eg, on poor unstructured meshes)
#FACE_DERIVED <vof_phi_delta_f> "faceave[adjacentcells](<vof_phi_delta>)" ON <all faces> # in theory, NO NO NO

CELL_DERIVED <vof_delta[l=1]> "celldivgrad[l=1](<vof_phi_delta_f>)" ON <all cells>
CELL_DERIVED <vof_delta[l=2]> "celldivgrad[l=2](<vof_phi_delta_f>)" ON <all cells>
#CELL_DERIVED <vof_delta[l=3]> "celldivgrad[l=3](<vof_phi_delta_f>)" ON <all cells>

CELL_DERIVED <vof_delta_mag> "sqrt(dot(<vof_delta[l=:]>,<vof_delta[l=:]>))" ON <all cells>
# now precalculate a mask which defines where delta is nonzero, noting that delta is a gradient of phi
CELL_DERIVED <vof_delta_mask> "cellif(<vof_delta_mag>-<vof_phigrad_tol>,1.d0,0.d0)" ON <all cells>

# instead now define mask based on possible region of influence - nah
#CELL_DERIVED <vof_delta_mag> "cellmax(sqrt(dot(<vof_delta[l=:]>,<vof_delta[l=:]>)),<vof_phigrad_tol>)" ON <all cells>
#FACE_DERIVED <vof_phi_delta_f_mask> "cellmax(<vof_phi_delta_mask>,region=<facekernelregion[l=0]>)" ON <all faces>
#CELL_DERIVED <vof_delta_mask> "facemax(<vof_phi_delta_f_mask>,region=<celljfaces>)" ON <all cells>


FACE_LOCAL <vof_delta_f> "facegrad[dxunit](<vof_phi_delta>)" ON <all faces>
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/delta.arb
#--------------------------------------------------------

# now calculate <vof_phigrad[l=:]> which is used for both curvature calculation and (explicitly) for advection calculation
# also create <vof_phigrad_mask> and <vof_phigrad_mag>
# use the delta function normals directly
#INCLUDE "normals_delta"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/normals_delta.arb without any search/replace combinations
# phigrad is the based normal orientation used to calculate curvature, and also to to advection
# phigrad is only defined near the interface, within the <vof_phigrad_mask>

# based on delta
CELL_DERIVED <vof_phigrad[l=1]> "<vof_delta[l=1]>" ON <all cells> output
CELL_DERIVED <vof_phigrad[l=2]> "<vof_delta[l=2]>" ON <all cells>
#CELL_DERIVED <vof_phigrad[l=3]> "<vof_delta[l=3]>" ON <all cells>
CELL_DERIVED <vof_phigrad_mag> "<vof_delta_mag>" ON <all cells>
CELL_DERIVED <vof_phigrad_mask> "<vof_delta_mask>" ON <all cells>
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/normals_delta.arb
#--------------------------------------------------------

# otherwise first define <vof_phi_normal> using
#INCLUDE "phi_normal" # to set it equal to <vof_phi>
# or
#INCLUDE "phi_normal" R "<vof_phi>" W "<vof_phi_delta>" R "<vof_phi_interface_mask>" W "<vof_phi_delta_mask>" # to set it equal to <vof_phi_delta>
# or
#INCLUDE "expand_phi_normal" # to create if using expansion of <vof_phi>
# and then calculate normals using
#INCLUDE "normals_cellgrad"
# or by differential convolution - NO NO NO
#INCLUDE "normals_convolution" R "<<maxseparation>>" W "1" # maxseparation controls thickness of delta region, and hence also magnitude of currents - smoothing constant is now linked to this parameter


# TODO
# try calculating normals_delta here, with appropriate mask considerations - is this stable?
# ALSO
# does averaging by angle actually make the calculation more accurate?  Or more stable further away from interface?
# should averaging by angle be used in kappa_cyl_f calculation?
# are smoothing lengths large enough - should maximum length be limited by maximum distance that exists within kernel, but still same area to first separation level?

# expand the normals (<vof_phigrad>) to enable curvature calculation
# create <vof_phigrad_expand_unit[l=:]> and <vof_phigrad_expand_mask>, and also save explicit versions of both
# for 2D only (right now), average the angle of the normals, so having to only do a single convolution
#INCLUDE "expand_normals_angle"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/expand_normals_angle.arb without any search/replace combinations
# here we calculate the expand normals by averaging the angle of the normal, rather than its components

#INCLUDE "normals_unit"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/normals_unit.arb without any search/replace combinations
# define unit normals (needed for advection in the next step only?)
CELL_DERIVED <vof_phigrad_unit[l=1]> "cellif(<vof_phigrad_mask>,<vof_phigrad[l=1]>/<vof_phigrad_mag>,0.d0)" ON <all cells> output
CELL_DERIVED <vof_phigrad_unit[l=2]> "cellif(<vof_phigrad_mask>,<vof_phigrad[l=2]>/<vof_phigrad_mag>,0.d0)" ON <all cells>
#CELL_DERIVED <vof_phigrad_unit[l=3]> "cellif(<vof_phigrad_mask>,<vof_phigrad[l=3]>/<vof_phigrad_mag>,0.d0)" ON <all cells>

# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/normals_unit.arb
#--------------------------------------------------------

# on the <vof_phigrad_mask>, calculate the angle on the interface, <vof_theta>
# 2d only averaging
CELL_DERIVED <vof_theta> "cellif(<vof_phigrad_mask>,atan2(<vof_phigrad_unit[l=2]>,<vof_phigrad_unit[l=1]>),0.d0)" ON <all cells> output
#CELL_DERIVED <vof_theta> "cellif(<vof_phigrad_mask>,<pi>/4.d0,0.d0)" ON <all cells> output # test on reflection
#CELL_DERIVED <vof_theta> "atan2(<cellx[l=2]>,<cellx[l=1]>)-<pi>" ON <all cells> output

# now to expand theta using convolution

# the size of this expansion is really dependent on the size of the kernel used to calculate <vof_kappa_f>, although, as long as this minimum size is satisfied, could also be additionally increased to decrease erroneous current magnitude (although I favour working on <vof_phi_delta> instead)
#GENERAL_REPLACEMENTS R "<<maxseparation>>" W "3,faceseparation"
#GENERAL_REPLACEMENTS R "3,faceseparation" W "5,faceseparation"
#GENERAL_REPLACEMENTS R "3,faceseparation" W "4"

# weight using phigrad mask and mag
#INCLUDE "convolve_variable_dynamic" R "<vof_variable_default>" W "0.d0" R "<vof_variable_convolve_constant>" W "<vof_phigrad_expand_constant>" R "<vof_variable>" W "<vof_theta_relative>" R "<vof_variable_convolve>" W "<vof_theta_relative_expand>"  R "<vof_variable_mask>" W "<vof_phigrad_mask>" R "<vof_variable_convolve" W "<vof_phigrad_expand" R "<vof_variable" W "<vof_phigrad"
#CELL_LOCAL <vof_phigrad_expand_weight> "<vof_phigrad_mag>"

# weight using delta mask and mag
#INCLUDE "convolve_variable_dynamic" R "<vof_variable_default>" W "0.d0" R "<vof_variable_convolve_constant>" W "<vof_phigrad_expand_constant>" R "<vof_variable>" W "<vof_theta_relative>" R "<vof_variable_convolve>" W "<vof_theta_relative_expand>"  R "<vof_variable_mask>" W "<vof_delta_mask>" R "<vof_variable_convolve" W "<vof_phigrad_expand" R "<vof_variable" W "<vof_phigrad"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/convolve_variable_dynamic.arb with the following search/replace combinations: replace <vof_variable_default> with 0.d0: replace <vof_variable_convolve_constant> with <vof_phigrad_expand_constant>: replace <vof_variable> with <vof_theta_relative>: replace <vof_variable_convolve> with <vof_theta_relative_expand>: replace <vof_variable_mask> with <vof_delta_mask>: replace <vof_variable_convolve with <vof_phigrad_expand: replace <vof_variable with <vof_phigrad
# use this convolution where the weighting (ie, denominator) is constant for all time

#INCLUDE "convolve_variable_constant" R "CELL_CONSTANT <vof_variable_convolve_denominator>" W "CELL_DERIVED <vof_variable_convolve_denominator>"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/convolve_variable_constant.arb with the following search/replace combinations: replace CELL_CONSTANT <vof_variable_convolve_denominator> with CELL_DERIVED <vof_variable_convolve_denominator>
# convolving (smoothing or taking derivative) of <vof_theta_relative> based on a single separation loop
# needs <vof_delta_mask> set and produces <vof_theta_relative_expand> and <vof_phigrad_expand_mask[r=0 and 1]>
# needs a local of <vof_phigrad_expand_weight> set afterwards too if required (defaults to 1)

# needs the following set:
#GENERAL_REPLACEMENTS R "3,faceseparation" W "3" # which can also have other options such as 4,faceseparation
#GENERAL_REPLACEMENTS R "<vof_phigrad" W "<vof_phi"
#GENERAL_REPLACEMENTS R "<<dynamic_variable>>" W "DERIVED" or "CONSTANT" depending on whether weight function depends on unknowns or is constant
#GENERAL_REPLACEMENTS R "0.d0" W "0.d0" or give it a value - this is the value given to the <vof_theta_relative_expand> outside of the <vof_phigrad_expand_mask>

# general convolution setup, same for every
# find normalised distance between cell in separation loop and cell centre
#CELL_LOCAL <vof_convolve_dist^2> "dot(<celltoseparationicellr[l=:]>,<celltoseparationicellr[l=:]>)"
CELL_LOCAL <vof_convolve_dist^2> "<celltoseparationicellrsquared>"
#CELL_CONSTANT <vof_convolve_eps_centre^2> "cellmin(cellmin(<celldxmin>,region=<adjacentcellicells>),2.d0*<celldxkernel>)**2" ON <all cells>
CELL_CONSTANT <vof_convolve_eps_centre^-2> "cellmin(cellmin(<celldxmin>,region=<adjacentcellicells>),2.d0*<celldxkernel>)**(-2)" ON <all cells>
CELL_LOCAL <vof_convolve_eps^-2> "cellfromcellave[separationcentre](<vof_convolve_eps_centre^-2>)" ON <all cells>

# define kernels here
# hyperbolic
#CELL_LOCAL <vof_phi_smooth_kernel> "1.d0/(<vof_smooth_dist^2>/<vof_smooth_eps^2>+<vof_phi_smooth_constant>)"
#CELL_LOCAL <vof_phigrad_expand_kernel> "1.d0/(<vof_convolve_dist^2>/<vof_convolve_eps^2>+<vof_phigrad_expand_constant>/5.d0)*<cellvol>"
# hyperbolic + sqrt
#CELL_LOCAL <vof_phi_smooth_kernel> "1.d0/(sqrt(<vof_smooth_dist^2>/<vof_smooth_eps^2>)+<vof_phi_smooth_constant>)"
#CELL_LOCAL <vof_phigrad_expand_kernel> "1.d0/(sqrt(<vof_convolve_dist^2>/<vof_convolve_eps^2>)+<vof_phigrad_expand_constant>/5.d0)*<cellvol>"
# hyperbolic + squared
#CELL_LOCAL <vof_phigrad_expand_kernel> "1.d0/((<vof_convolve_dist^2>/<vof_convolve_eps^2>)^2+<vof_phigrad_expand_constant>/2.d0)*<cellvol>"
#CELL_LOCAL <vof_phigrad_expand_kernel> "<cellvol>/((<vof_convolve_dist^2>/<vof_convolve_eps^2>+<vof_phigrad_expand_constant>)**2)"
CELL_LOCAL <vof_phigrad_expand_kernel> "<cellvol>/((<vof_convolve_dist^2>*<vof_convolve_eps^-2>+<vof_phigrad_expand_constant>)**2)" # multiplication is usually faster than division
# exponential (guassian)
# use constant = 1
#CELL_LOCAL <vof_phi_smooth_kernel> "exp(-<vof_smooth_dist^2>/(<vof_smooth_eps^2>*<vof_phi_smooth_constant>))"
#CELL_LOCAL <vof_phigrad_expand_kernel> "exp(-<vof_convolve_dist^2>/(<vof_convolve_eps^2>*<vof_phigrad_expand_constant>))*<cellvol>" # gaussian
NONE_CONSTANT <vof_phigrad_expand_constant> 1.0d0
# exponential + sqrt
# use constant = 1
#CELL_LOCAL <vof_phi_smooth_kernel> "exp(-sqrt(<vof_smooth_dist^2>/<vof_smooth_eps^2>)/<vof_phi_smooth_constant>)"
# hyperbolic based on separation rather than distance
# requires constant ~ 0.1 for power = 1
#CELL_LOCAL <vof_phi_smooth_kernel> "1.d0/((<separation>+<vof_phi_smooth_constant>)**<vof_phi_smooth_power>)"
# with <vof_phi_smooth_constant> 0.125d0 stable, but currents could be smaller
# with <vof_phi_smooth_constant> 0.25d0 interface is too jaggered
#CELL_LOCAL <vof_phi_smooth_kernel> "1.d0/(<separation>+<vof_phi_smooth_constant>)"

# a mask of where theta_expanded is defined, which is based on the previous timestep mask, but expanded a little
# also define a mask of where variables are changed
CELL_DERIVED <vof_phigrad_expand_mask> "cellif(<vof_phigrad_expand_mask_plus[r=1]>,cellmax[maxseparation=3,faceseparation](<vof_delta_mask>,region=<all cells>),0.d0)"
# define a smoothing kernel, which is also used in smooth_normals.arb
CELL_TRANSIENT <vof_phigrad_expand_mask[r=1]> "1.d0" "<vof_phigrad_expand_mask>" ON <all cells>
CELL_TRANSIENT <vof_phigrad_expand_mask_plus[r=1]> "" "cellmax(<vof_phigrad_expand_mask[r=1]>,region=<adjacentcellicells>)" ON <all cells>

# now do the convolving
CELL_DERIVED <vof_phigrad_expand_denominator> "cellsum[maxseparation=3,faceseparation](<vof_phigrad_expand_kernel>,region=<all cells>)" ON <all cells>
# now defaults to unsmoothed variable where convolved mask isn't present
CELL_DERIVED <vof_theta_relative_expand> "cellif(<vof_phigrad_expand_mask>,cellsum[maxseparation=3,faceseparation](<vof_theta_relative>*<vof_phigrad_expand_kernel>,region=<all cells>)/<vof_phigrad_expand_denominator>,0.d0)" ON <all cells>
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/convolve_variable_constant.arb
#--------------------------------------------------------

CELL_LOCAL <vof_phigrad_expand_weight> "1.d0" # set this to how the convolving should be weighted
CELL_DERIVED <vof_phigrad_expand_denominator> "cellif(<vof_phigrad_expand_mask>,cellsum[maxseparation=3,faceseparation](cellif(<vof_delta_mask>,<vof_phigrad_expand_kernel>*<vof_phigrad_expand_weight>,0.d0),region=<all cells>),0.d0)" ON <all cells> output
# now defaults to unsmoothed variable where convolved mask isn't present
CELL_DERIVED <vof_theta_relative_expand> "cellif(<vof_phigrad_expand_mask>,cellsum[maxseparation=3,faceseparation](cellif(<vof_delta_mask>,<vof_theta_relative>*<vof_phigrad_expand_kernel>*<vof_phigrad_expand_weight>,0.d0),region=<all cells>)/<vof_phigrad_expand_denominator>,0.d0)" ON <all cells> output
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/convolve_variable_dynamic.arb
#--------------------------------------------------------
CELL_LOCAL <vof_phigrad_expand_weight> "<vof_delta_mag>"

# weight using delta and phigrad product mag and mask
#INCLUDE "convolve_variable_dynamic" R "<vof_variable_default>" W "0.d0" R "<vof_variable_convolve_constant>" W "<vof_phigrad_expand_constant>" R "<vof_variable>" W "<vof_theta_relative>" R "<vof_variable_convolve>" W "<vof_theta_relative_expand>"  R "<vof_variable_mask>" W "(<vof_delta_mask>*<vof_phigrad_mask>)" R "<vof_variable_convolve" W "<vof_phigrad_expand" R "<vof_variable" W "<vof_phigrad"
#CELL_LOCAL <vof_phigrad_expand_weight> "<vof_delta_mag>*<vof_phigrad_mag>"
#CELL_LOCAL <vof_phigrad_expand_weight> "sqrt(<vof_delta_mag>*<vof_phigrad_mag>)"

NONE_CONSTANT <vof_phigrad_expand_constant> 2.0d0

# calculate theta in separation cell relative to previous theta in central cell, accounting for reflections
CELL_LOCAL <vof_theta_relative> "cellboundangle(atan2(<celltoseparationicellreflect[l=2]>*sin(<vof_theta>),<celltoseparationicellreflect[l=1]>*cos(<vof_theta>))-cellfromcellave[separationcentre](<vof_theta_base>))"
# calculate expanded theta by averaging difference from central cell previous theta
CELL_DERIVED <vof_theta_expand> "cellif(<vof_phigrad_expand_mask>,cellboundangle(<vof_theta_relative_expand>+<vof_theta_base>),0.d0)" ON <all cells>

CELL_TRANSIENT <vof_theta_expand[r=1]> "atan2(<cellx[l=2]>,<cellx[l=1]>)-<pi>" "<vof_theta_expand>" ON <all cells>

# have to find a base angle around which to do the averaging for each cell
# if there was no angle here previously, find angle from surrounding cells (cheapish)
CELL_TRANSIENT <vof_theta_base> "<vof_theta_base_ave>" "cellif(<vof_phigrad_expand_mask[r=1]>,<vof_theta_expand[r=1]>,<vof_theta_base_ave>)" ON <all cells>
CELL_LOCAL <vof_theta_base_ave_n[l=1]> "cellsum[reflect=1](cos(<vof_theta_expand[r=1]>)*<vof_phigrad_expand_mask[r=1]>,region=<cellicells>)/cellmax(cellsum(<vof_phigrad_expand_mask[r=1]>,region=<cellicells>),1.d0)"
CELL_LOCAL <vof_theta_base_ave_n[l=2]> "cellsum[reflect=2](sin(<vof_theta_expand[r=1]>)*<vof_phigrad_expand_mask[r=1]>,region=<cellicells>)/cellmax(cellsum(<vof_phigrad_expand_mask[r=1]>,region=<cellicells>),1.d0)"
CELL_LOCAL <vof_theta_base_ave> "atan2(<vof_theta_base_ave_n[l=2]>,<vof_theta_base_ave_n[l=1]>)"

# finally define some unit vectors from these
CELL_DERIVED <vof_phigrad_expand_unit[l=1]> "cellif(<vof_phigrad_expand_mask>,cos(<vof_theta_expand>),0.d0)" ON <all cells> output
CELL_DERIVED <vof_phigrad_expand_unit[l=2]> "cellif(<vof_phigrad_expand_mask>,sin(<vof_theta_expand>),0.d0)" ON <all cells>

# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/expand_normals_angle.arb
#--------------------------------------------------------
# alternatively, average each component of the normals, which is more expensive but also works in 3D
#INCLUDE "expand_normals_component"

# calculate the curvature
#INCLUDE "curvature_angle_facegrad_based"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/curvature_angle_facegrad_based.arb without any search/replace combinations
# within this file we calculate the curvature based on facegrad around faces

# doing cartesian and cylindrical curvatures separately

FACE_LOCAL <vof_delta_mask_f> "cellmax(<vof_delta_mask>,region=<adjacentfaceicells>)" ON <all faces>
FACE_LOCAL <vof_kappa_cart_f> "-(facegrad[l=1,reflect=1](<vof_phigrad_expand_unit[l=1]>)+facegrad[l=2,reflect=2](<vof_phigrad_expand_unit[l=2]>)+facegrad[l=3,reflect=3](<vof_phigrad_expand_unit[l=3]>))" ON <all faces>
# two methods of calculating the cylindrical (separate) curvature
# average the normal component, and then divide by the radius, noting that the normal component is an odd function so must be reflected
##FACE_LOCAL <vof_kappa_cyl_f> "-faceave[reflect=0](<vof_phigrad_expand_unit[l=0]>)/1.d0" ON <all faces> # won't work on centreline, so instead use twice carteisan curvature there
# otherwise, around centreline, both the normal component and radius are odd functions, so one divided by the other becomes an even function, so does not need reflection around the centreline
#FACE_LOCAL <vof_kappa_cyl_f> "-faceave(<vof_phigrad_expand_unit[l=0]>/1.d0)" ON <all faces> # won't work on centreline, so instead use twice carteisan curvature there
# an alternative to calculating the cartesian and cylindrical components separately is to calculate them together using cylindrical divergence operator
# need to devise coding way to cancel reflection of gradient operator in the radial direction, as both the normal component and radius_c are odd functions in this direction around the centreline
# seems to be slightly more accurate than calculating the cartesian and cylindrical curvatures separately
# eg, if radial direction = 1 you would use the following which has no reflect on the first facegrad:
# TODO: implement system variable <facefromicellreflect[l=?]> and put <facefromicellreflect[l=0]> in each derivative
##FACE_LOCAL <vof_kappa_totcyl_f> "-(facegrad[l=1](<vof_phigrad_expand_unit[l=1]>*1.d0)+facegrad[l=2,reflect=2](<vof_phigrad_expand_unit[l=2]>*1.d0)+facegrad[l=3,reflect=3](<vof_phigrad_expand_unit[l=3]>*1.d0))/1.d0" ON <all faces>

FACE_DERIVED <vof_kappa_f> "faceif(<vof_delta_mask_f>,<vof_kappa_cart_f>,0.d0)" ON <all faces> output
##FACE_DERIVED <vof_kappa_f> "faceif(<vof_delta_mask_f>,faceif(1.d0-1.d-6*<facedx>,<vof_kappa_cart_f>+<vof_kappa_cyl_f>,2.d0*<vof_kappa_cart_f>),0.d0)" ON <all faces> output
#FACE_DERIVED <vof_kappa_f> "faceif(<vof_delta_mask_f>,<vof_kappa_cart_f>+<vof_kappa_cyl_f>,0.d0)" ON <all faces> output
##FACE_DERIVED <vof_kappa_f> "faceif(<vof_delta_mask_f>,faceif(1.d0-1.d-6*<facedx>,<vof_kappa_totcyl_f>,2.d0*<vof_kappa_cart_f>),0.d0)" ON <all faces> output

#CELL_DERIVED <vof_kappa_c> "cellif(<vof_delta_mask>,<vof_kappa_f>,0.d0)" ON <all cells> output
# now weight using <vof_delta_f> magnitude limited by minimum <vof_phigrad_tol>
CELL_DERIVED <vof_kappa_c> "cellif(<vof_delta_mask>,facesum(<vof_kappa_f>*facemax(abs(<vof_delta_f>),default=<vof_phigrad_tol>),region=<celljfaces>)/facesum(facemax(abs(<vof_delta_f>),default=<vof_phigrad_tol>),region=<celljfaces>),0.d0)" ON <all cells> output
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/curvature_angle_facegrad_based.arb
#--------------------------------------------------------

#INCLUDE "setup_phi_angle_based"
#INCLUDE "smooth_phi" R "3,faceseparation" W "3,faceseparation"
#INCLUDE "normals_angle_based" R "<vof_phi_lim>" W "<vof_phi_smooth>"

#INCLUDE "setup_phi"
#INCLUDE "normals_normal_based"
#INCLUDE "curvature_delta_weighted"
#INCLUDE "curvature_angle_based"
#INCLUDE "curvature_angle_celldiv_based"

# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/interface_geometry_2D.arb
#--------------------------------------------------------
# for 3D include the following which expands the unit normals using their components:
#INCLUDE "interface_geometry"

# and now move back to the fluid mesh
#INCLUDE "cancel_free_surface_replacements"
#INCLUDE "fluid_replacements"

#INCLUDE "force" # force done back on the fluid mesh
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/force.arb without any search/replace combinations
# within this file we calculate the cell centred surface force and face centred force used in the <u_f> interpolation

# this creates the delta function which is used here and also in the kappa_f interpolation (so may have been previously included)
# included again incase a difference curvature interpolation is employed
#INCLUDE "delta"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/delta.arb without any search/replace combinations
# here we create the delta function that is used to
#  1) apply the surface tension force
#  2) weighting in the kappa_f interpolation

# interpolate to faces for use in creating delta function
#FACE_DERIVED <vof_phi_delta_f> "faceave(<vof_phi_delta>)" ON <all faces> # double limited incase averaging kernels are a bit skewy (eg, on poor unstructured meshes)
# for consistency with pressure discretisation must be interpolated the same way, except here also bounded
FACE_DERIVED <vof_phi_delta_f> "facemax(facemin(faceave(<vof_phi_delta>),1.d0),0.d0)" ON <all faces> # double limited incase averaging kernels are a bit skewy (eg, on poor unstructured meshes)
#FACE_DERIVED <vof_phi_delta_f> "faceave[adjacentcells](<vof_phi_delta>)" ON <all faces> # in theory, NO NO NO

CELL_DERIVED <vof_delta[l=1]> "celldivgrad[l=1](<vof_phi_delta_f>)" ON <all cells>
CELL_DERIVED <vof_delta[l=2]> "celldivgrad[l=2](<vof_phi_delta_f>)" ON <all cells>
#CELL_DERIVED <vof_delta[l=3]> "celldivgrad[l=3](<vof_phi_delta_f>)" ON <all cells>

CELL_DERIVED <vof_delta_mag> "sqrt(dot(<vof_delta[l=:]>,<vof_delta[l=:]>))" ON <all cells>
# now precalculate a mask which defines where delta is nonzero, noting that delta is a gradient of phi
CELL_DERIVED <vof_delta_mask> "cellif(<vof_delta_mag>-<vof_phigrad_tol>,1.d0,0.d0)" ON <all cells>

# instead now define mask based on possible region of influence - nah
#CELL_DERIVED <vof_delta_mag> "cellmax(sqrt(dot(<vof_delta[l=:]>,<vof_delta[l=:]>)),<vof_phigrad_tol>)" ON <all cells>
#FACE_DERIVED <vof_phi_delta_f_mask> "cellmax(<vof_phi_delta_mask>,region=<facekernelregion[l=0]>)" ON <all faces>
#CELL_DERIVED <vof_delta_mask> "facemax(<vof_phi_delta_f_mask>,region=<celljfaces>)" ON <all cells>


FACE_LOCAL <vof_delta_f> "facegrad[dxunit](<vof_phi_delta>)" ON <all faces>
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/delta.arb
#--------------------------------------------------------

CELL_LOCAL <vof_F_c[l=1]> "<vof_kappa_c>*<vof_delta[l=1]>" ON <all cells>
CELL_LOCAL <vof_F_c[l=2]> "<vof_kappa_c>*<vof_delta[l=2]>" ON <all cells>
#CELL_LOCAL <vof_F_c[l=3]> "<vof_kappa_c>*<vof_delta[l=3]>" ON <all cells>

# differencing type used here must match that in the p_error calc
FACE_LOCAL <vof_F_f> "<vof_kappa_f>*<vof_delta_f>" ON <all faces>
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/force.arb
#--------------------------------------------------------

# calculate <u_f> using rhie-chow type interpolation, including a contribution from the surface tension force term
#INCLUDE_ROOT "navier_stokes"
# INFO: setting include root directory to navier_stokes
# nonuniform
#INCLUDE "total_stress" R "<mu_f>" W "<vof_mu_harmonic_f>"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/total_stress.arb with the following search/replace combinations: replace <mu_f> with <vof_mu_harmonic_f>
# total stress tensor
#INCLUDE "u_gradient_tensor"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/u_gradient_tensor.arb without any search/replace combinations
# a tensor of face centred gradients that respects any reflections
# used in the total stress and boundary conditions now
# as per conventional tensor notation, the first index is the derivative direction, and the second is the velocity direction
               FACE_DERIVED <ugrad_f[l=1,1]> "facegrad[l=1,reflect=1](<u[l=1]>)" ON <all faces>
FACE_DERIVED <ugrad_f[l=1,2]> "facegrad[l=1,reflect=2](<u[l=2]>)" ON <all faces>
#FACE_DERIVED <ugrad_f[l=1,3]> "facegrad[l=1,](<u[l=3]>)" ON <all faces>
FACE_DERIVED <ugrad_f[l=2,1]> "facegrad[l=2,reflect=1](<u[l=1]>)" ON <all faces>
               FACE_DERIVED <ugrad_f[l=2,2]> "facegrad[l=2,reflect=2](<u[l=2]>)" ON <all faces>
#FACE_DERIVED <ugrad_f[l=2,3]> "facegrad[l=2,](<u[l=3]>)" ON <all faces>
#FACE_DERIVED <ugrad_f[l=3,1]> "facegrad[l=3,reflect=1](<u[l=1]>)" ON <all faces>
#FACE_DERIVED <ugrad_f[l=3,2]> "facegrad[l=3,reflect=2](<u[l=2]>)" ON <all faces>
#               FACE_DERIVED <ugrad_f[l=3,3]> "facegrad[l=3,](<u[l=3]>)" ON <all faces>

# now at the same time calculate the velocity divergence (numerical) on each face
#FACE_DERIVED <udiv_f> "<ugrad_f[l=1,1]>+<ugrad_f[l=2,2]>+<ugrad_f[l=3,3]>" ON <all faces>
# this is a now a placeholder for where this should be calculated
# to include this contribution just include u_divergence_face somewhere after this file and <udiv_f> will be correctly calculated
FACE_DERIVED <udiv_f> "0.d0" ON <all faces>
# INCLUDE FINISHED for ../templates/navier_stokes/u_gradient_tensor.arb
#--------------------------------------------------------

# no both cartesian and cylindrical stresses don't include pressure
# without the numerical velocity divergence
# FACE_LOCAL <tau[l=1,1]> "- <vof_mu_harmonic_f>*2.d0*<ugrad_f[l=1,1]>" ON <all faces>
# FACE_LOCAL <tau[l=2,2]> "- <vof_mu_harmonic_f>*2.d0*<ugrad_f[l=2,2]>" ON <all faces>
## FACE_LOCAL <tau[l=3,3]> "- <vof_mu_harmonic_f>*2.d0*<ugrad_f[l=3,3]>" ON <all faces>
# with the numerical velocity divergence (although it is generally set to zero in u_gradient_tensor anyway)
 FACE_LOCAL <tau[l=1,1]> "- <vof_mu_harmonic_f>*2.d0*(<ugrad_f[l=1,1]>-<udiv_f>/3.d0)" ON <all faces>
 FACE_LOCAL <tau[l=2,2]> "- <vof_mu_harmonic_f>*2.d0*(<ugrad_f[l=2,2]>-<udiv_f>/3.d0)" ON <all faces>
# FACE_LOCAL <tau[l=3,3]> "- <vof_mu_harmonic_f>*2.d0*(<ugrad_f[l=3,3]>-<udiv_f>/3.d0)" ON <all faces>
FACE_LOCAL <tau[l=1,2]> "- <vof_mu_harmonic_f>*(<ugrad_f[l=1,2]>+<ugrad_f[l=2,1]>)" ON <all faces>
#FACE_LOCAL <tau[l=1,3]> "- <vof_mu_harmonic_f>*(<ugrad_f[l=1,3]>+<ugrad_f[l=3,1]>)" ON <all faces>
#FACE_LOCAL <tau[l=2,3]> "- <vof_mu_harmonic_f>*(<ugrad_f[l=2,3]>+<ugrad_f[l=3,2]>)" ON <all faces>
FACE_LOCAL <tau[l=2,1]> "<tau[l=1,2]>" ON <all faces>
#FACE_LOCAL <tau[l=3,1]> "<tau[l=1,3]>" ON <all faces>
#FACE_LOCAL <tau[l=3,2]> "<tau[l=2,3]>" ON <all faces>
# INCLUDE FINISHED for ../templates/navier_stokes/total_stress.arb
#--------------------------------------------------------
#INCLUDE "advection_flux" R "<rho_f>" W "<vof_rho_f>" R "<mu_f>" W "<vof_mu_f>"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/advection_flux.arb with the following search/replace combinations: replace <rho_f> with <vof_rho_f>: replace <mu_f> with <vof_mu_f>
# uses a rhie-chow type interpolation method to calculate the fluid flux (velocity) over and in the direction of each face

#INCLUDE "p_error"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/p_error.arb without any search/replace combinations
# a Rhie-Chow-type velocity interpolation is applied to the face flux velocities
# pressure gradient calculated via a divergence (consistent with momentum conservation) (on boundary cells values from the adjacent domain cells will be used)

#INCLUDE "dynamic_force" # cell centred dynamic force
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/dynamic_force.arb without any search/replace combinations
# dynamic force is the pressure force that could cause fluid movement
# it is added directly to the momentum equations, and used in calculating p_error used in the face velocity interpolation
# dynamic force now has the physically correct sign!

FACE_DERIVED <p_f> "faceave(<p>)" ON <all faces>
CELL_DERIVED <dynamic_force_c[l=1]> "-celldivgrad[l=1](<p_f>)" ON <all cells>
CELL_DERIVED <dynamic_force_c[l=2]> "-celldivgrad[l=2](<p_f>)" ON <all cells>
#CELL_DERIVED <dynamic_force_c[l=3]> "-celldivgrad[l=3](<p_f>)" ON <all cells>
# interpolation to face centres (for velocity correction) could be done using normal, adjacentcells or adjacentcellsevenweighting, but they're all about the same so choose the computationally simplest
FACE_LOCAL <dynamic_force_c_f[l=1]> "faceave[reflect=1,adjacentcells](<dynamic_force_c[l=1]>)"
FACE_LOCAL <dynamic_force_c_f[l=2]> "faceave[reflect=2,adjacentcells](<dynamic_force_c[l=2]>)"
#FACE_LOCAL <dynamic_force_c_f[l=3]> "faceave[,adjacentcells](<dynamic_force_c[l=3]>)"
# INCLUDE FINISHED for ../templates/navier_stokes/dynamic_force.arb
#--------------------------------------------------------
FACE_LOCAL <dynamic_force_f> "-facegrad[dxunit](<p>)" ON <all faces> # now defined on <all faces> to allow use as a BC
FACE_DERIVED <p_error> "-(<dynamic_force_f> - dot(<dynamic_force_c_f[l=:]>,<facedxunit[l=:]>))*dot(<facenorm[l=:]>,<facedxunit[l=:]>)" ON <domain faces>
# INCLUDE FINISHED for ../templates/navier_stokes/p_error.arb
#--------------------------------------------------------
#INCLUDE "u_f"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/u_f.arb without any search/replace combinations
# calculate the Rhie-Chow type velocity correction, only applied (nonzero) on the domain faces
FACE_LOCAL <u_f_vect[l=1]> "faceave[reflect=1](<u[l=1]>)"
FACE_LOCAL <u_f_vect[l=2]> "faceave[reflect=2](<u[l=2]>)"
#FACE_LOCAL <u_f_vect[l=3]> "faceave[](<u[l=3]>)"
FACE_DERIVED <u_f_{raw}> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" ON <all faces> # volume (velocity) transport
FACE_LOCAL <eps_p> "abs(<p_error>)" ON <domain faces>
FACE_LOCAL <sign_p> "signum(<p_error>)" ON <domain faces>

# advection limiter
# alternative v0.5 method based on average velocity magnitude
#CELL_DERIVED <u_mag2> "dot(<u[l=:]>,<u[l=:]>)" ON <all cells>
#FACE_DERIVED <u_mag2_f> "facemax(<u_mag2>,0.d0)" ON <domain faces>
#FACE_LOCAL <u_mf_{adv}> "-sqrt(<u_mag2_f>)+sqrt(<u_mag2_f>+<eps_p>*<facedx>/<vof_rho_f>)" ON <domain faces>
# pre v0.5 method based on component of velocity in direction of face normal
FACE_LOCAL <u_mf_{adv}> "-abs(<u_f_{raw}>)+sqrt(<u_f_{raw}>^2+<eps_p>*<facedx>/<rho>)" ON <domain faces>
#FACE_LOCAL <u_mf_{adv}> "sqrt(<eps_p>*<facedx>/<rho>)" ON <domain faces>

# viscous limiter
# this didn't seem to work
#FACE_LOCAL <u_mf_{vis}> "<eps_p>*<facedx>^2/<vof_mu_f>" ON <domain faces>
## additional contribution to velocity interpolation from cylindrical hoop-stress term
##FACE_LOCAL <u_mf_{vis}> "facemin(<eps_p>*<facedx>^2/<vof_mu_f>,<eps_p>*1.d0^2/(2.d0*<vof_mu_f>))" ON <domain faces>
FACE_LOCAL <u_mf_{vis}> "<eps_p>*<facedx>^2/<vof_mu_f>" ON <domain faces>

# this file now does both steady-state and transient using transient comments string replacements, which are set in constants.arb

# transient limiter
# this is the equivalent time that the limiter has been moving in the one direction
# noting that the variables (<u_f_{correction}> and <eps>) here are previous timestep ones
#FACE_TRANSIENT <t_{Rhie-Chow}[r=1]> "0.d0" "abs(<u_f_{correction}>)*<rho>/facemax(<eps_p>*<C_{Rhie-Chow}>,1.d-20)" ON <domain faces>
# need to save previous pressure error sign
#FACE_TRANSIENT <sign_p[r=1]> "0.d0" "<sign_p>" ON <domain faces>
#FACE_LOCAL <u_mf_{transient}> "<eps_p>*(faceif(<sign_p>*<sign_p[r=1]>,<t_{Rhie-Chow}[r=1]>,0.d0)+<dt>)/<rho>" ON <domain faces>

# combined limiter
##FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>*facemin(facemin(<u_mf_{adv}>,<u_mf_{vis}>),<u_mf_{transient}>)" ON <domain faces>
#FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>*<u_mf_{transient}>" ON <domain faces>
#FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>/(1./<u_mf_{transient}>+1./<u_mf_{adv}>+1./<u_mf_{vis}>)" ON <domain faces>
FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>*facemin(<u_mf_{adv}>,<u_mf_{vis}>)" ON <domain faces>
#FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>/(1./<u_mf_{adv}>+1./<u_mf_{vis}>)" ON <domain faces>
#FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>*<u_mf_{vis}>" ON <domain faces>
#FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>*<u_mf_{adv}>" ON <domain faces>

# final face velocity
FACE_DERIVED <u_f> "<u_f_{raw}>+faceif(facedelta(<domain faces>),<u_f_{correction}>,0.d0)" ON <all faces> # volume (velocity) transport

#FACE_OUTPUT <advection correction limited> "faceif(<u_mf_{adv}>-<u_mf_{vis}>,0.d0,1.d0)" ON <domain faces> # is 1 where advection component is limiting velocity correction
# INCLUDE FINISHED for ../templates/navier_stokes/u_f.arb
#--------------------------------------------------------
# INCLUDE FINISHED for ../templates/navier_stokes/advection_flux.arb
#--------------------------------------------------------
# uniform
#INCLUDE "total_stress"
#INCLUDE "advection_flux"

#INCLUDE_ROOT "volume_of_fluid"
# INFO: setting include root directory to volume_of_fluid
#INCLUDE "p_error"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/p_error.arb without any search/replace combinations
# standard lines to overwrite dynamic_force_c and dynamic_force_f from navier_stokes p_error_facegrad file to include surface tension force in p_error calculation

CELL_DERIVED <dynamic_force_c[l=1]> "-(celldivgrad[l=1](<p_f>)-<sigma>*<vof_F_c[l=1]>)" ON <all cells>
CELL_DERIVED <dynamic_force_c[l=2]> "-(celldivgrad[l=2](<p_f>)-<sigma>*<vof_F_c[l=2]>)" ON <all cells>
#CELL_DERIVED <dynamic_force_c[l=3]> "-(celldivgrad[l=3](<p_f>)-<sigma>*<vof_F_c[l=3]>)" ON <all cells>
# differencing has to be consistent with that used for <vof_F_f>
# now on all faces to allow use as a BC too
FACE_LOCAL <dynamic_force_f> "-(facegrad[dxunit](<p>)-<sigma>*<vof_F_f>)" ON <all faces>
#FACE_LOCAL <dynamic_force_f> "-(facegrad(<p>)-<sigma>*<vof_F_f>)" ON <all faces>

# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/p_error.arb
#--------------------------------------------------------
#INCLUDE "equation" # all phi advection done on fluid mesh
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/equation.arb without any search/replace combinations
# here we advect <vof> using the implicit <u_f> and explicit <vof_phi[r=1]>

# these unit normals are carried over from the previous timestep curvature calculation
CELL_TRANSIENT <vof_phigrad_unit[l=1,r=1]> "0.d0" "<vof_phigrad_unit[l=1]>" ON <all cells>
CELL_TRANSIENT <vof_phigrad_unit[l=2,r=1]> "0.d0" "<vof_phigrad_unit[l=2]>" ON <all cells>

# calculate the position of the interface in each cell, captured using the scalar d
# exact matches area within polygon to phi value exactly and gives better results, but only works for 2D
CELL_TRANSIENT <vof_d[r=1]> "" "cellvofd[exact](phi=<vof_phi[r=1]>,normal[l=1]=<vof_phigrad_unit[l=1,r=1]>,normal[l=2]=<vof_phigrad_unit[l=2,r=1]>,phitol=<vof_phi_tol>)" ON <all cells> output
# lineartwo used linear interpolation between the cell extremes and cell centre, so is cheaper (as it doesn't involve polygon constructions) but is less accurate - works in 3D though
# this tends to leave material behind when normal is orientated with one of the boundaries
#CELL_TRANSIENT <vof_d[r=1]> "" "cellvofd[lineartwo](phi=<vof_phi[r=1]>,normal[l=1]=<vof_phigrad_unit[l=1,r=1]>,normal[l=2]=<vof_phigrad_unit[l=2,r=1]>,phitol=<vof_phi_tol>)" ON <all cells> output

# based on this position (d), calculate the flux values of phi at each face
# option 1): use built-in function facevofphi
# this function is only dependent on the current unknowns through the flux variable <u_f>, so no derivative is required, but it does need to keep being re-evaluated (as <u_f> is a decision variable)
# although this is listed as a previous timestep variable [r=1], only partly true as also depends on current <u_f>
FACE_DERIVED <vof_phi_f[r=1]> "facevofphi[noderivative,linearone](phi=<vof_phi[r=1]>,d=<vof_d[r=1]>,flux=<u_f>,normal[l=1]=<vof_phigrad_unit[l=1,r=1]>,normal[l=2]=<vof_phigrad_unit[l=2,r=1]>,phitol=<vof_phi_tol>)" ON <all faces> output
# option 2): or use more accurate (for 2D only though) templates solution
# these files probably need updating as of 030714
#INCLUDE "facevofphi_linearone_2D_advected_vector_explicit" R "<facevofphi_n[l=" W "<vof_phigrad_unit[r=1,l=" R "<facevofphi_d>" W "<vof_d[r=1]>" R "<facevofphi_phi>" W "<phi[r=1]>" R "<facevofphi_f[r=1]>" W "<vof_phi_f[r=1]>" R "<facevofphi_phi>" W "<vof_phi[r=1]>" R "<facevofphi_phitol>" W "<vof_phi_tol>"

#CELL_DERIVED <vof_phi_adjust[r=1]> "cellvofphiadjust[noderivative](phi[r=1]=<vof_phi[r=1]>,phif=<vof_phi_f[r=1]>,flux=<u_f>,dt=<dt>)" ON <all cells> output
# cellvofphiadjust now supports derivative calculation too for implicit flux (but not phif or phi[r=1])
CELL_DERIVED <vof_phi_adjust[r=1]> "cellvofphiadjust(phi[r=1]=<vof_phi[r=1]>,phif=<vof_phi_f[r=1]>,flux=<u_f>,dt=<dt>)" ON <all cells> output,newtstepmax=50
#CELL_DERIVED <vof_phi_adjust[r=1]> "cellvofphiadjust(phi[r=1]=<vof_phi[r=1]>,phif=<vof_phi_f[r=1]>,flux=1.d0*<u_f>/faceave[lastcell](1.d0),dt=<dt>)" ON <all cells> output,newtstepmax=50
FACE_DERIVED <vof_phi_f_adjusted[r=1]> "facemax(facemin(<vof_phi_f[r=1]>+faceif(<u_f>,faceave[downcell](<vof_phi_adjust[r=1]>),faceave[upcell](<vof_phi_adjust[r=1]>)),1.d0),0.d0)" ON <all faces> output

#CELL_TRANSIENT <vof_phi_advected> "<vof[r=1]>-<dt>*celldiv(<vof_phi_f_adjusted[r=1]>*<u_f[r=1]>)" ON <all cells> nooutput
# note: guarding against destabilising effects of non-zero divergence enroute to convergence
#CELL_DERIVED <vof_phi_advected> "<vof_phi[r=1]>-<dt>*celldiv((<vof_phi_f_adjusted[r=1]>-faceave[lastcell](<vof_phi>))*<u_f>)" ON <all cells> nooutput
#CELL_EQUATION <vof_equation_domain> "<vof_phi>-<vof_phi_advected>" ON <domain>

#CELL_EQUATION <vof_equation_domain> "(<vof_phi>-<vof_phi[r=1]>)/<dt> + celldiv(<vof_phi_f_adjusted[r=1]>*<u_f>)" ON <domain> nooutput
##CELL_EQUATION <vof_equation_domain> "(<vof_phi>-<vof_phi[r=1]>)/<dt> + celldiv(1.d0*<vof_phi_f_adjusted[r=1]>*<u_f>)/1.d0" ON <domain> nooutput
CELL_EQUATION <vof_equation_domain> "(<vof_phi>-<vof_phi[r=1]>)/<dt> + celldiv((<vof_phi_f_adjusted[r=1]>-faceave[lastcell](<vof_phi[r=1]>))*<u_f>)" ON <domain> nooutput
#CELL_EQUATION <vof_equation_domain> "(<vof_phi>-<vof_phi[r=1]>)/<dt> + celldiv(1.d0*(<vof_phi_f_adjusted[r=1]>-faceave[lastcell](<vof_phi[r=1]>))*<u_f>)/1.d0" ON <domain> nooutput
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/equation.arb
#--------------------------------------------------------

#INCLUDE_ROOT "navier_stokes"
# INFO: setting include root directory to navier_stokes
# nonuniform
#INCLUDE "momentum_flux_transient_constant_rho" R "<rho>" W "<vof_rho_advection_f[r=1]>"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/momentum_flux_transient_constant_rho.arb with the following search/replace combinations: replace <rho> with <vof_rho_advection_f[r=1]>
#INCLUDE "momentum_flux_steady_state_constant_rho"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/momentum_flux_steady_state_constant_rho.arb without any search/replace combinations
# flux of momentum over and in the direction of each face

# flux now split to allow easier overwriting of the advection component
# default is for steady-state (or fully implicit) with constant rho
FACE_LOCAL <J_advection_f[l=1]> "<vof_rho_advection_f[r=1]>*faceave[advection,reflect=1](<u[l=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <all faces>
FACE_LOCAL <J_advection_f[l=2]> "<vof_rho_advection_f[r=1]>*faceave[advection,reflect=2](<u[l=2]>,<u_f>,<adv_limiter>)*<u_f>" ON <all faces>
#FACE_LOCAL <J_advection_f[l=3]> "<vof_rho_advection_f[r=1]>*faceave[advection,](<u[l=3]>,<u_f>,<adv_limiter>)*<u_f>" ON <all faces>

FACE_DERIVED <J_f[l=1]> "dot(<facenorm[l=:]>,<tau[l=:,1]>)+<J_advection_f[l=1]>" ON <all faces> # component of momentum transport from stress and advection
FACE_DERIVED <J_f[l=2]> "dot(<facenorm[l=:]>,<tau[l=:,2]>)+<J_advection_f[l=2]>" ON <all faces> # component of momentum transport from stress and advection
#FACE_DERIVED <J_f[l=3]> "dot(<facenorm[l=:]>,<tau[l=:,3]>)+<J_advection_f[l=3]>" ON <all faces> # component of momentum transport from stress and advection
# INCLUDE FINISHED for ../templates/navier_stokes/momentum_flux_steady_state_constant_rho.arb
#--------------------------------------------------------
FACE_LOCAL <J_advection_f[l=1]> "<vof_rho_advection_f[r=1]>*faceave[advection,reflect=1](<u[l=1,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <all faces>
FACE_LOCAL <J_advection_f[l=2]> "<vof_rho_advection_f[r=1]>*faceave[advection,reflect=2](<u[l=2,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <all faces>
#FACE_LOCAL <J_advection_f[l=3]> "<vof_rho_advection_f[r=1]>*faceave[advection,](<u[l=3,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <all faces>
# INCLUDE FINISHED for ../templates/navier_stokes/momentum_flux_transient_constant_rho.arb
#--------------------------------------------------------
#INCLUDE "conservation_incompressible_transient_varying_rho" R "<rho>" W "<vof_rho_c>" R "<rho[r=1]>" W "<vof_rho_c[r=1]>" R "<mu>" W "<vof_mu_c>"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/conservation_incompressible_transient_varying_rho.arb with the following search/replace combinations: replace <rho> with <vof_rho_c>: replace <rho[r=1]> with <vof_rho_c[r=1]>: replace <mu> with <vof_mu_c>
# conservation equations solved over each domain cell (finite volume method)

# cartesian
CELL_EQUATION <continuity> "celldiv(<u_f>)" ON <domain> # continuity
CELL_EQUATION <momentum[l=1]> "(<vof_rho_c>*<u[l=1]>-<vof_rho_c[r=1]>*<u[l=1,r=1]>)/<dt>+celldiv(<J_f[l=1]>)-<dynamic_force_c[l=1]>" ON <domain> # momentum component
CELL_EQUATION <momentum[l=2]> "(<vof_rho_c>*<u[l=2]>-<vof_rho_c[r=1]>*<u[l=2,r=1]>)/<dt>+celldiv(<J_f[l=2]>)-<dynamic_force_c[l=2]>" ON <domain> # momentum component
#CELL_EQUATION <momentum[l=3]> "(<vof_rho_c>*<u[l=3]>-<vof_rho_c[r=1]>*<u[l=3,r=1]>)/<dt>+celldiv(<J_f[l=3]>)-<dynamic_force_c[l=3]>" ON <domain> # momentum component

# cylindrical
#CELL_EQUATION <continuity> "celldiv(1.d0*<u_f>)/1.d0" ON <domain> # continuity
##CELL_EQUATION <momentum[l=1]> "celldiv(1.d0*<J_f[l=1]>)/1.d0-<dynamic_force_c[l=1]>" ON <domain> # momentum component
##CELL_EQUATION <momentum[l=2]> "celldiv(1.d0*<J_f[l=2]>)/1.d0-<dynamic_force_c[l=2]>" ON <domain> # momentum component
###CELL_EQUATION <momentum[l=3]> "celldiv(1.d0*<J_f[l=3]>)/1.d0-<dynamic_force_c[l=3]>" ON <domain> # momentum component
# these also include the hoop stress terms when <<radiusdim?flag>> is appropriately set
#CELL_EQUATION <momentum[l=1]> "(<vof_rho_c>*<u[l=1]>-<vof_rho_c[r=1]>*<u[l=1,r=1]>)/<dt>+celldiv(1.d0*<J_f[l=1]>)/1.d0-<dynamic_force_c[l=1]>+0*2.d0*<u[l=1]>*<vof_mu_c>/(<cellx[l=1]>**2)" ON <domain> # momentum component
#CELL_EQUATION <momentum[l=2]> "(<vof_rho_c>*<u[l=2]>-<vof_rho_c[r=1]>*<u[l=2,r=1]>)/<dt>+celldiv(1.d0*<J_f[l=2]>)/1.d0-<dynamic_force_c[l=2]>+0*2.d0*<u[l=2]>*<vof_mu_c>/(<cellx[l=2]>**2)" ON <domain> # momentum component
##CELL_EQUATION <momentum[l=3]> "(<vof_rho_c>*<u[l=3]>-<vof_rho_c[r=1]>*<u[l=3,r=1]>)/<dt>+celldiv(1.d0*<J_f[l=3]>)/1.d0-<dynamic_force_c[l=3]>+0*2.d0*<u[l=3]>*<vof_mu_c>/(<cellx[l=3]>**2)" ON <domain> # momentum component
# INCLUDE FINISHED for ../templates/navier_stokes/conservation_incompressible_transient_varying_rho.arb
#--------------------------------------------------------
# uniform
#INCLUDE "momentum_flux_transient_constant_rho"
#INCLUDE "conservation_incompressible_transient_constant_rho"

#CELL_DERIVED <vof_phi_adjust[r=1]> "0.d0"

# fluid boundary conditions on nonslip walls
#INCLUDE_ROOT "volume_of_fluid"
# INFO: setting include root directory to volume_of_fluid
#INCLUDE "walls_nonwetting" # NB: BC applied on fluid walls
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/free_surface/volume_of_fluid/walls_nonwetting.arb without any search/replace combinations
# boundary equations for walls
# here the continuous phase completely wets the wall (contact angle = 180degrees), disperse does not (contact angle = 0degrees)
FACE_EQUATION <vof_equation_walls> "<vof_phi>" ON <walls>
# INCLUDE FINISHED for ../templates/free_surface/volume_of_fluid/walls_nonwetting.arb
#--------------------------------------------------------
#INCLUDE_ROOT "navier_stokes"
# INFO: setting include root directory to navier_stokes
#INCLUDE "walls_p_set"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/walls_p_set.arb without any search/replace combinations
# same as walls, but we have one face which is used to set pressure
# uses the two extra face regions which are contained within <walls>, <walls sans one face> and <one face>
#INCLUDE "p_extrapolation" R "<region>" W "<walls>" R "<equation>" W "<p_walls>"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/p_extrapolation.arb with the following search/replace combinations: replace <region> with <walls>: replace <equation> with <p_walls>
FACE_EQUATION <p_walls> "<dynamic_force_f>" ON <walls> # pressure gradient next to wall set so that dynamic pressure gradient inext to wall is zero
# INCLUDE FINISHED for ../templates/navier_stokes/p_extrapolation.arb
#--------------------------------------------------------
#INCLUDE "noflux" R "<region>" W "<walls sans one face>" R "<equation>" W "<noflux_walls>"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/noflux.arb with the following search/replace combinations: replace <region> with <walls sans one face>: replace <equation> with <noflux_walls>
FACE_EQUATION <noflux_walls> "<u_f>" ON <walls sans one face> # no flux normal to region
# INCLUDE FINISHED for ../templates/navier_stokes/noflux.arb
#--------------------------------------------------------
#INCLUDE "noslip" R "<region>" W "<walls>" R "<equation>" W "<noslip_walls>"
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# the following is INCLUDED from ../templates/navier_stokes/noslip.arb with the following search/replace combinations: replace <region> with <walls>: replace <equation> with <noslip_walls>
FACE_EQUATION <equation1> "dot(<u_f_vect[l=:]>,<facetang1[l=:]>)" ON <walls> # no component tangential to the face
#FACE_EQUATION <equation2> "dot(<u_f_vect[l=:]>,<facetang2[l=:]>)" ON <walls> # no component tangential to the face in the second tangential direction
# INCLUDE FINISHED for ../templates/navier_stokes/noslip.arb
#--------------------------------------------------------
FACE_EQUATION <one face p set> "<p>" ON <one face>
# INCLUDE FINISHED for ../templates/navier_stokes/walls_p_set.arb
#--------------------------------------------------------

#-------------------------------------------------------------------
NONE_OUTPUT <integrated volume> "cellsum(<vof_phi>*<cellvol>,<domain>)"
#NONE_OUTPUT <integrated volume> "cellsum(<vof_phi>*1.d0*<cellvol>,<domain>)"

NONE_OUTPUT <centroid[l=1]> "cellsum(<cellvol>*<cellx[l=1]>*<vof_phi>,region=<domain>)/cellsum(<cellvol>*<vof_phi>,region=<domain>)"
NONE_OUTPUT <centroid[l=2]> "cellsum(<cellvol>*<cellx[l=2]>*<vof_phi>,region=<domain>)/cellsum(<cellvol>*<vof_phi>,region=<domain>)"
NONE_OUTPUT <stretch[l=1]> "sqrt(cellsum(<cellvol>*(<cellx[l=1]>-<centroid[l=1]>)^2*<vof_phi>,region=<domain>)/cellsum(<cellvol>*<vof_phi>,region=<domain>))"
NONE_OUTPUT <stretch[l=2]> "sqrt(cellsum(<cellvol>*(<cellx[l=2]>-<centroid[l=2]>)^2*<vof_phi>,region=<domain>)/cellsum(<cellvol>*<vof_phi>,region=<domain>))"

FACE_OUTPUT <u_f_vector[l=1,r=1]> "<u_f[r=1]>*<facenorm[l=1]>" ON <all faces>
FACE_OUTPUT <u_f_vector[l=2,r=1]> "<u_f[r=1]>*<facenorm[l=2]>" ON <all faces>
FACE_OUTPUT <u_f_vector[l=1,r=0]> "<u_f[r=0]>*<facenorm[l=1]>" ON <all faces>
FACE_OUTPUT <u_f_vector[l=2,r=0]> "<u_f[r=0]>*<facenorm[l=2]>" ON <all faces>

NONE_OUTPUT <u_f_max> "facemax(abs(<u_f>),region=<all faces>)"
NONE_OUTPUT <phi error> "sqrt(cellsum((<vof_phi>-<vof_phi_initial_saved>)**2*<cellvol>,region=<domain>)/cellsum(<cellvol>,region=<domain>))"

NONE_OUTPUT <vof_phi_max domain> "cellmax(<vof_phi>,region=<domain>)"
NONE_OUTPUT <vof_phi_min domain> "cellmin(<vof_phi>,region=<domain>)"
NONE_OUTPUT <vof_phi_max all cells> "cellmax(<vof_phi>,region=<all cells>)"
NONE_OUTPUT <vof_phi_min all cells> "cellmin(<vof_phi>,region=<all cells>)"
NONE_OUTPUT <vof_phi_adjust_max> "cellmax(<vof_phi_adjust[r=1]>,region=<all cells>)"
NONE_OUTPUT <vof_phi_adjust_min> "cellmin(<vof_phi_adjust[r=1]>,region=<all cells>)"
NONE_OUTPUT <vof_phi_error domain> "nonemax(abs(<vof_phi_max domain>-1.d0),abs(<vof_phi_min domain>))"
NONE_OUTPUT <vof_phi_error all cells> "nonemax(abs(<vof_phi_max all cells>-1.d0),abs(<vof_phi_min all cells>))"

# save maximum and minimum velocities for t > t_save say
NONE_CONSTANT <t_save> 20.d0
NONE_LOCAL <u_f_max_local> "facemax(abs(<u_f>),region=<all faces>)"
NONE_TRANSIENT <u_f_max_max> "0.d0" "noneif(<t>-<t_save>,nonemax(<u_f_max_local>,<u_f_max_max[r=1]>),<u_f_max_max[r=1]>)" output
NONE_TRANSIENT <u_f_max_max[r=1]> "" "<u_f_max_max>"
NONE_TRANSIENT <u_f_max_min> "1.d2" "noneif(<t>-<t_save>,nonemin(<u_f_max_local>,<u_f_max_min[r=1]>),<u_f_max_min[r=1]>)" output
NONE_TRANSIENT <u_f_max_min[r=1]> "" "<u_f_max_min>"

#-------------------------------------------------------------------
# specify outputs for some variables

VARIABLE <vof_F_c[l=1]> output
VARIABLE <CFL[r=1]> stepoutput
#VARIABLE <vof_fs_phi_smoothed> output
#VARIABLE <vof_fs_phigrad_unit[l=1]> output

# nonuniform
VARIABLE <vof_rho_advection_f[r=1]> output
VARIABLE <vof_rho_c[r=1]> output
VARIABLE <vof_rho_c[r=0]> output
VARIABLE <vof_rho_f> output
VARIABLE <vof_mu_f> output

# by default surface tension and property changes are turned off after 30 newtsteps (via <vof_phi_lim>), and <vof_phi_adjust[r=1]> changes after 50
#VARIABLE <vof_phi_adjust[r=1]> newtstepmax=30
#VARIABLE <vof_phi_lim> newtstepmax=50
#-------------------------------------------------------------------
# INCLUDE FINISHED for ../oscillating_volume_of_fluid_drop_in_quadrant.arb
#--------------------------------------------------------
##################################################################################
