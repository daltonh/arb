MARKDOWN
A Rhie-Chow-type velocity interpolation is applied to the face flux velocities, and this requires the difference between the facecentred dynamic force (<dynamic_force_f>) and the averaged component of the cell centred dynamic force (<dynamic_force_c[l=:]>), <p_error>
END_MARKDOWN

INCLUDE "dynamic_force" # calculate the cell centred dynamic force

# seems that using <dynamic_force_c_f[l=:]> usually consumes more memory and takes more time to compute, so remove it by default by including the following
# in the far off future if nobody complains <dynamic_force_c_f[l=:]> may just disappear into the night
# to bring back <dynamic_force_c_f[l=:]> set this string to 1 to turn this back on
GENERAL_REPLACEMENTS D "<<dynamicforcecf>>" W "0"

# for evaluating the face centred dynamic force there are three options: dxunit, facegrad and facegradadjacentcells
# right now the default is dxunit, which works well, but implies that u_f_{correction} is not aligned with facenorm (noting that only the component of the correction is applied)
# facegrad works but is not as effective in damping checkerboarding
# facegradadjacentcells also works but the implications re directions aren't as clear as the above two options
GENERAL_REPLACEMENTS D "<<dynamicforcefmethod>>" W "dxunit"
#GENERAL_REPLACEMENTS D "<<dynamicforcefmethod>>" W "facegrad"
#GENERAL_REPLACEMENTS D "<<dynamicforcefmethod>>" W "facegradadjacentcells"

# calculate <dynamic_force_c_f[l=:]> if requested
# interpolation to face centres (for velocity correction) could be done using normal, adjacentcells or adjacentcellsevenweighting, but they're all about the same so choose the computationally simplest
IF <<dynamicforcecf>>
  <<dim1comment>>FACE_LOCAL <dynamic_force_c_f[l=1]> "faceave[<<reflect=1>>,adjacentcells](<dynamic_force_c[l=1]>)"
  <<dim2comment>>FACE_LOCAL <dynamic_force_c_f[l=2]> "faceave[<<reflect=2>>,adjacentcells](<dynamic_force_c[l=2]>)"
  <<dim3comment>>FACE_LOCAL <dynamic_force_c_f[l=3]> "faceave[<<reflect=3>>,adjacentcells](<dynamic_force_c[l=3]>)"
END_IF

#{{ print "IN p_error.arb\n".string_debug(); }}

IF {{ return string_test('<<dynamicforcefmethod>>','dxunit'); }}
# dxunit method
  FACE_LOCAL <dynamic_force_f> "-facegrad[dxunit](<p>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
  FACE_CONSTANT <dot_facenorm_facedxunit> "dot(<facenorm[l=:]>,<facedxunit[l=:]>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
# dxunit + dynamicforcecf
  IF <<dynamicforcecf>>
    FACE_DERIVED <p_error> "(-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facedxunit[l=:]>))*<dot_facenorm_facedxunit>" ON <domainfaces>
  ELSE
# dxunit - dynamicforcecf
# lastface is required when averaging the normal when we have periodic gluing, as we require the normal to be orientated relative to the original face, rather than its glued counterpart - this is now the default when cycling through the region adjacentfaceicells, which is used by faceave[adjacentcells]
# for reflect gluing, <p_error> is zero anyway
#   FACE_DERIVED <p_error> "faceif(<facereflectnorm>,(-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <domainfaces>
# need to fix code for adjacentdomaincells for this line to work
#   FACE_DERIVED <p_error> "faceif(<facereflectnorm>,(-<dynamic_force_f>+faceave[adjacentdomaincells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <domainfaces>
# workaround, explicit code
    FACE_DERIVED <p_error> "faceif(<facereflectnorm>,(-<dynamic_force_f>+faceif(facedelta(region=<boundaries>),faceave[downcell](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))),faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>)))))*<dot_facenorm_facedxunit>,0.d0)" ON <domainfaces>
  END_IF

ELSE_IF {{ return string_test('<<dynamicforcefmethod>>','facegrad'); }}

# facegrad method
  FACE_LOCAL <dynamic_force_f> "-facegrad(<p>)" ON <allfaces>
  IF <<dynamicforcecf>>
# facegrad + dynamicforcecf
    FACE_DERIVED <p_error> "-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facenorm[l=:]>)" ON <domainfaces>
  ELSE
# facegrad - dynamicforcecf
    FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
  END_IF

ELSE_IF {{ return string_test('<<dynamicforcefmethod>>','facegradadjacentcells'); }}
# adjacentcells method
  FACE_LOCAL <dynamic_force_f> "-facegrad[adjacentcells](<p>)" ON <allfaces>
  IF <<dynamicforcecf>>
# facegradadjacentcells + dynamicforcecf
    FACE_DERIVED <p_error> "-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facenorm[l=:]>)" ON <domainfaces>
  ELSE
# facegradadjacentcells - dynamicforcecf
#   FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
    FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentdomaincells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
  END_IF

ELSE
  ERROR 'No valid dynamicforcefmethod is chosen in the navier_stokes/p_error template file: string currently set as <<dynamicforcefmethod>>'
END_IF
