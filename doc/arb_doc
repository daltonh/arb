#!/bin/bash
#
# file arb_doc
#
# Copyright 2009-2017 Dalton Harvie (daltonh@unimelb.edu.au)
# 
# This file is part of arb finite volume solver, referred to as `arb'.
# 
# arb is a software package designed to solve arbitrary partial
# differential equations on unstructured meshes using the finite volume
# method.  Primarily it consists of fortran source code, perl source
# code and shell scripts.  arb replies on certain third party software
# to run, most notably the computer algebra system maxima
# <http://maxima.sourceforge.net/> which is released under the GNU GPL.
# 
# The original copyright of arb is held by Dalton Harvie, however the
# project is now under collaborative development.
# 
# arb is released under the GNU GPL.  arb is free software: you can
# redistribute it and/or modify it under the terms of the GNU General
# Public License (version 3) as published by the Free Software Foundation.
# You should have received a copy of the GNU General Public Licence
# along with arb (see file licence/gpl.txt after unpacking).  If not,
# see <http://www.gnu.org/licences/>.
# 
# arb is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public Licence
# for more details.
# 
# For full details of arb's licence see the licence directory.
# 
# The current homepage for the arb finite volume solver project is
# <http://people.eng.unimelb.edu.au/daltonh/downloads/arb>.
#
#-------------------------------------------------------------------------
#
# a script to create and update an instance of the arb manual
# daltonh, 2/9/17
#
# see usage function for help
#
# exit status:
# 0: successful
# 1: failed
# 
#-------------------------------------------------------------------------------
# usage function
function usage () {
  echo

  echo "HELP/USAGE: arb_doc [options]";
  echo
  echo "Possible options (consistent with long-form command line syntax (--), words are separated by -, and a preceeding --no- negates an option) :";
  echo "  --root: name of root location to be fed to html pages, either an html root or a file directory (no trailing slash, default $arb_dir/doc/html)"
  echo "  --update: whether to recreate the tree (default)";
  echo "  --no-update: do not recreate the tree";
  echo "  --content: file directory that contains the content, in primarily markdown index.md files (no trailing slash, default $arb_dir/doc/content)"
  echo "  --html: file directory that the html contents will be written to (no trailing slash, default $root_dir).  Note, also sets root_var to this directory (full path)."
  echo "  --help|-h: display this HELP INFO";
  echo;
  exit 1;
}
#-------------------------------------------------------------------------------
# function to dereference symlinks and find the real path of a file
# call with the (possibly symlinked) file (not a directory)
# result is returned in (global) variable real_path - no not any more
# now called as a="$(resolve_real_path "$a")";
function resolve_real_path {
# real_path=$1;
  real_path="$(cd "$(dirname "$1")" && pwd -P)/$(basename "$1")"
  next_path=`readlink $real_path`;
  while [ -n "$next_path" ] ; do
    real_path="$(dirname "$real_path")/$next_path";
    next_path=`readlink $real_path`;
  done
# simplify directory links
  real_path="$(sanitise_filename "$real_path")";
# now return this as a string
  echo "$real_path";
  unset next_path;
  unset real_path;
}
#-------------------------------------------------------------------------------
# idea from http://stackoverflow.com/questions/4774054/reliable-way-for-a-bash-script-to-get-the-full-path-to-itself
function sanitise_filename {
  echo "$(cd "$(dirname "$1")" && pwd -P)/$(basename "$1")";
}
function sanitise_dirname {
  echo "$(cd "$1" && pwd -P)";
}
#-------------------------------------------------------------------------------
# main script:

#---------------------------
# define some default variables, directories and flags to say what has to be done

working_dir=`pwd -P`; # directory from which the script is run
# get the real path to the arb script with any symlinks resolved/dereferenced
arb_script="${BASH_SOURCE[0]}";
arb_script="$(resolve_real_path "$arb_script")"; # the result of resolve_real_path is held in this global variable
doc_dir="$(dirname "$arb_script")"; # directory that holds this arb script, which determines...
arb_dir="${doc_dir%"/doc"}"; # arb root directory, known as arb_dir, with no trailing slash
# setup other arb related directory references and check on their existence
src_dir="$arb_dir/src";
misc_dir="$arb_dir/misc";
templates_dir="$arb_dir/templates";
examples_dir="$arb_dir/examples";
file_separator="##################################################################################"
# check that all of the directories are present in the arb_dir
#echo "working_dir = $working_dir";
#echo "arb_script = $arb_script";
#echo "doc_dir = $doc_dir";
#echo "arb_dir = $arb_dir";
if [ ! -d "$src_dir" ] ; then echo "ERROR: cannot find the arb src directory that corresponds to this arb script.  Possibly the arb directory $arb_dir has been corrupted, or alternatively the arb script has been moved/copied out of the arb directory (if you want to refer to the arb script outside of its arb directory, create a soft link to it, which will be dereferenced when the script is called)."; usage; fi;
if [ ! -d "$misc_dir" ] ; then echo "ERROR: cannot find the arb misc directory that corresponds to this arb script.  Possibly the arb directory $arb_dir has been corrupted, or alternatively the arb script has been moved/copied out of the arb directory (if you want to refer to the arb script outside of its arb directory, create a soft link to it, which will be dereferenced when the script is called)."; usage; fi;
if [ ! -d "$templates_dir" ] ; then echo "ERROR: cannot find the arb templates directory that corresponds to this arb script.  Possibly the arb directory $arb_dir has been corrupted, or alternatively the arb script has been moved/copied out of the arb directory (if you want to refer to the arb script outside of its arb directory, create a soft link to it, which will be dereferenced when the script is called)."; usage; fi;
if [ ! -d "$examples_dir" ] ; then echo "ERROR: cannot find the arb examples directory that corresponds to this arb script.  Possibly the arb directory $arb_dir has been corrupted, or alternatively the arb script has been moved/copied out of the arb directory (if you want to refer to the arb script outside of its arb directory, create a soft link to it, which will be dereferenced when the script is called)."; usage; fi;

errorstatus=0;

echo "arb_doc script for creating the manual";
echo
echo "INFO: for usage options, try arb_doc --help";
echo "INFO: arb_dir = $arb_dir"
#echo "INFO: working_dir = $working_dir"
#echo "INFO: output_dir = $output_dir"

# oclean=0;
# ocleancompile=0;
# ocleansetup=0;
# osetup=1;
# ocompile=1;
# orun=1;
# oquiet=0;
# ocontinue=0;
# odebug=0;
# oomp=0; # 0 means no omp, 1 means compile with omp support
# oopt=1; # default is optimsation level 1
# oilp="off";
# opardiso="present";
# osuitesparse="present"; # default is to enable/download this solver
# omgmres="not present"; # default is to not enable/download this solver
# osparse="not present"; # default is to not enable/download this solver
# oprocesslogging=0; # a value greater than 0 means that process statistics will be logged at this interval (s)
# compiler="default";
# unset arbfiles; # the input files that will be passed to setup_equations.pl - unset array first
# unset externals; # a list of external fortran files that will be included in equation_module.f90
# externals=( `ls "$src_dir/"*_functions.f90 2> /dev/null` ); # all functions files within the src directory get included by default, now as absolute pathnames

# set default variables and locations
root_var=$arb_dir/doc/html;
oupdate=1;
content_dir=$arb_dir/doc/content;
html_dir=$arb_dir/doc/html;

#---------------------------
# loop through options and update any variables
until [ -z "$1" ];
do
  case $1 in
    "--root") # get root location fed to html pages
      shift;
      if [ -n "$1" ]; then root_var="$1"; else echo "ERROR: root location not found after option"; usage; fi;
      ;;
    "--update") oupdate=1;;
    "--no-update") oupdate=0;;
    "--content") # get content file directory
      shift;
      if [ -n "$1" ]; then content_dir="$1"; else echo "ERROR: content directory not found after option"; usage; fi;
      ;;
    "--html") # get html file directory
      shift;
      if [ -n "$1" ]; then html_dir="$(sanitise_dirname "$1")"; root_var=$html_dir; else echo "ERROR: html directory not found after option"; usage; fi;
      ;;
    "--help"|"-h") usage;;
    "--"*|"-"*) echo "ERROR: unknown option $1 passed to arb_doc"; usage;;
    *) echo "ERROR: unknown command line entry $1"; usage;;
  esac
  shift;
done ;

echo "INFO: root_var = $root_var"
echo "INFO: oupdate = $oupdate"
echo "INFO: content_dir = $content_dir"
echo "INFO: html_dir = $html_dir"

#---------------------------
if [ $oupdate -eq 1 ] ; then
#------------------------------------------------------------
# sanity checks and create directories
# TODO: check that directories don't have trailing slashes

  if [ ! -d "$content_dir" ] ; then echo "ERROR: cannot find the content directory."; usage; fi;

# use rsync to mirror directory structure and all non-md files

  echo "INFO: rsyncing content_dir to html_dir"
  rsync -au --progress --exclude "index.html" "$content_dir/" $html_dir;

# assemble makeline and make
# use the file via -f
  makeline="make -f $doc_dir/src/makefile arbdir=\"$arb_dir\" docdir=\"$doc_dir\" rootvar=\"$root_var\" contentdir=\"$content_dir\" htmldir=\"$html_dir\"";
  echo "INFO: running make using commands: $makeline"; echo
  eval $makeline;

#------------------------------------------------------------
fi ;
exit $errorstatus ;
# done
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
# # set the output directory if it hasn't been set already
# # and make sure that they are absolute path names
# # note, existence of these directories tested later
# if [ -z "$output_dir" ] ; then # -z means empty
#   output_dir="$working_dir/output";
# elif [[ $output_dir != /* ]] ; then
#   output_dir="$working_dir/$output_dir";
# fi;
# # the previous_output_dir and previous_build_dir are only set if needed
# if [ -n "$previous_output_dir" ] ; then
#   if [[ $previous_output_dir != /* ]] ; then
#     previous_output_dir="$working_dir/$previous_output_dir";
#   fi;
#   previous_build_dir="$previous_output_dir/build";
# fi;

# build_dir="$output_dir/build";
# arb_executable="$build_dir/arb";

# # location where previously run output files will be stored
# previous_run="$output_dir/previous";

# # memory log file
# processlogfile="$output_dir/output_process_log.csv";

# # quiet output file
# scroutput="$output_dir/output.scr";

# # location of ooc temp files for out of core intel pardiso solver
# mkl_pardiso_ooc_dir="$build_dir/intel_pardiso_ooc";

# # check that pardiso licence path is absolute
# if [[ $PARDISO_LIC_PATH != /* ]] ; then
#   PARDISO_LIC_PATH="$working_dir/$PARDISO_LIC_PATH";
# fi;

# # note, *_files_to_delete is processed before files_to_keep
# output_files_to_delete=(
#   'debug*.msh'
#   '*_warnings.txt'
#   '*_details.txt'
# ); # relative to output directory
# working_files_to_delete=(
#   'fort.*'
#   'kill'
#   'stop*'
#   'halt'
#   'dump*'
# ); # relative to working directory
# output_files_to_keep=(
#   'output*.txt'
#   'output*.csv'
#   'output*.scr'
#   'output*.stat'
#   '*.msh'
#   '*.vtk'
#   '*.dat'
# ); # relative to output directory

# #------------------
# # export any variables that are required upstream, just in case they haven't been before
# # OSTYPE and MACHTYPE are now set directly within make using uname output
# export MKL_PARDISO_OOC_PATH
# export MKL_HOME
# export MKLROOT
# export PARDISO_LIC_PATH
# export LD_LIBRARY_PATH
# export DYLD_LIBRARY_PATH
# export OMP_STACKSIZE
# export KMP_STACKSIZE

# #---------------------------
# # ready output directory and structure for writing

# # create it if it doesn't already exist
# if [ ! -d "$output_dir" ] ; then mkdir "$output_dir" ; fi ;
# # cp new .gitignore in the output directory if it isn't there already
# if [ ! -e "$output_dir/.gitignore" ] ; then cp -p "$misc_dir/git/gitignore_empty_directory" "$output_dir/.gitignore" >/dev/null 2>/dev/null  ; fi ;

# # create build_dir if it doesn't already exist
# if [ ! -d "$build_dir" ] ; then mkdir -p "$build_dir" ; fi ;

# # if previous_output_dir has been specified, then copy contents of its build directory over to this new one
# if [ -n "$previous_build_dir" ] ; then
#   rm -r "$build_dir/"* >/dev/null 2>/dev/null ;
#   if [ ! -d "$previous_build_dir" ] ; then
#     echo "WARNING: previous build directory $previous_build_dir does not exist.  Not using previous build data.";
#   else
#     cp -Rp "$previous_build_dir" "$output_dir/" >/dev/null 2>/dev/null ; # preserve properties, now copying over subdirectories
#     cp -Rp "$previous_output_dir/setup_data" "$output_dir/" >/dev/null 2>/dev/null ; # also copy over setup_data directories
#     cp -Rp "$previous_output_dir/setup_data_incomplete" "$output_dir/" >/dev/null 2>/dev/null ; # also copy over setup_data directories
#   fi;
# fi;
# # and link to the makefile
# if [ -e "$build_dir/makefile" ] || [ -L "$build_dir/makefile" ] ; then rm -f "$build_dir/makefile" >/dev/null 2>/dev/null ; fi ;
# ln -s "$src_dir/makefile" "$build_dir/" >/dev/null 2>/dev/null ;

# # create intel pardiso ooc temp directory (within build_dir) and clear its contents
# if [ ! -d "$mkl_pardiso_ooc_dir" ] ; then mkdir -p "$mkl_pardiso_ooc_dir" ; fi ;
# rm "$mkl_pardiso_ooc_dir/*" >/dev/null 2>/dev/null ;

# # delete output and working directory files that are to be lost, noting that glob may not expand to anything (so remove quietly)
# for i in ${working_files_to_delete[@]} ; do rm $i >/dev/null 2>/dev/null ; done ;
# ( cd "$output_dir"; # open subshell to limit cd scope
#   for i in ${output_files_to_delete[@]} ; do rm $i >/dev/null 2>/dev/null ; done ;
# )

# # keep copy of previous output within the output dir
# # make previous directory and/or clear it out
# if [ ! -d "$previous_run" ] ; then mkdir -p "$previous_run" ; fi ;
# rm "$previous_run/"* >/dev/null 2>/dev/null ;
# # place old output and gmsh files in previous_run directory that are needed to restart the run
# (
#   cd "$output_dir"; # open subshell to limit cd scope (on newline due to vim highlighting error)
#   for i in ${output_files_to_keep[@]} ; do # don't quote string here as want globs to expand
#     if [ $ocontinue -eq 0 -o -n "$previous_output_dir" ] ; then
#       mv "$i" "$previous_run/" >/dev/null 2>/dev/null ;
#     else
#       cp -pR "$i" "$previous_run/" >/dev/null 2>/dev/null ;
#     fi ;
#   done ;
# )

# # if we are restarting from a previous output and continue is on, copy over files
# if [ -n "$previous_output_dir" -a $ocontinue -eq 1 ] ; then # -n means that string is defined
#   ( cd "$previous_output_dir";
#   for i in ${output_files_to_keep[@]} ; do
#     cp -pR "$i" "$output_dir/" >/dev/null 2>/dev/null ;
#   done ;
#   )
# fi;

# #---------------------------
# # now that output directory is ready for writing redirect stdout and stderr to output.scr
# if [ $oquiet -eq 1 ] ; then
#   exec >> "$scroutput" 2>&1;
# fi

# # now that quiet option has been dealt with, announce our arrival and list options etc
# echo "arb finite volume solver (see http://people.eng.unimelb.edu.au/daltonh/downloads/arb/)";
# echo
# echo "INFO: for usage options, try ./arb --help";
# echo "INFO: for licence see $arb_dir/licence";
# echo "INFO: script run with options: clean=$oclean, clean-setup=$ocleansetup, clean-compile=$ocleancompile, setup=$osetup, compile=$ocompile, run=$orun, quiet=$oquiet, continue=$ocontinue, debug=$odebug, compiler=$compiler, debugger=$debugger, omp=$oomp, opt=$oopt, process-logging=$oprocesslogging";
# echo "INFO: arb_dir = $arb_dir"
# echo "INFO: working_dir = $working_dir"
# echo "INFO: output_dir = $output_dir"
# if [ -n "$previous_output_dir" ] ; then echo "INFO: previous_output_dir = $previous_output_dir"; fi;
# echo "INFO: environment variable DYLD_LIBRARY_PATH = $DYLD_LIBRARY_PATH"
# echo "INFO: environment variable OMP_NUM_THREADS = $OMP_NUM_THREADS"
# if [ -n "${OMP_NUM_THREADS}" ] ; then echo "INFO: arb will be run with $OMP_NUM_THREADS omp threads" ; fi ;

# # check for input files.  If none have been set, then use any *.arb files that exist in the working directory, and failing that, any *.in files
# if [ -z "${arbfiles[0]}" ] ; then arbfiles=( `ls *.arb 2> /dev/null` ); fi ;
# if [ -z "${arbfiles[0]}" ] ; then arbfiles=( `ls *.in 2> /dev/null` ); fi ;
# echo "INFO: arb input files to be used: ${arbfiles[@]}" ;

# # construct root_input.arb file which consists of include statements to the user's input files, in the order that they are given to this script
# root_input_file="$build_dir/root_input.arb";
# rm "$root_input_file" >/dev/null 2>/dev/null ;
# echo "# root_input.arb file created by the arb script" >"$root_input_file" ;
# echo "$file_separator" >>"$root_input_file" ;
# # cycle through each external file including them in the root_input, so that setup_equations can decide whether they are required, and if so, whether they have changed since previously
# echo "# the following external fortran files were found by the arb script and are available for inclusion: ${externals[@]}" >>"$root_input_file";
# for file in "${externals[@]}" ; do
#   if [ ! -e "$file" ] ; then echo "ERROR: the external fortran file $file does not exist"; exit 1; fi;
#   echo "EXTERNALS \"$file\"" >>"$root_input_file" ;
# done
# echo "$file_separator" >>"$root_input_file" ;
# echo "# the following working directory files found by the arb script: ${arbfiles[@]}" >>"$root_input_file" ;
# for file in "${arbfiles[@]}" ; do
#   if [[ $file == *'.in' ]]; then echo "WARNING: the 'in' suffix on arb input files has been depreciated.  For future compatibility replace the suffix on $file with 'arb'."; fi
#   echo "INCLUDE_WORKING \"$file\"" >>"$root_input_file" ;
#   echo "$file_separator" >>"$root_input_file" ;
# done
# echo "INFO: the file $root_input_file has been created" ;

# # move to build directory
# echo "INFO: moving to build directory"
# cd "$build_dir";

# ###############################################
# # do clean operations first (which don't need directories or other variables specified)
# if [ $oclean -eq 1 ] ; then
# # do a complete clean if requested
#   make clean;
#   if [ "$?" -ne 0 ] ; then
#     echo "ERROR: problem cleaning files from the build directory" ;
#     cd "$working_dir";
#     exit 1 ;
#   fi ;
# else
#   if [ $ocleansetup -eq 1 ] ; then
#     make clean_setup;
#     if [ "$?" -ne 0 ] ; then
#       echo "ERROR: problem cleaning setup files from the build directory" ;
#       cd "$working_dir";
#       exit 1 ;
#     fi ;
#   fi ;
#   if [ $ocleancompile -eq 1 ] ; then
#     make clean_compile;
#     if [ "$?" -ne 0 ] ; then
#       echo "ERROR: problem cleaning compilation files from the build directory" ;
#       cd "$working_dir";
#       exit 1 ;
#     fi ;
#   fi
# fi

# ###############################################
# # compile if necessary, checking that options used last time are consistent with this time
# if [ $ocompile -eq 1 -o $osetup -eq 1 ] ; then

#   echo "INFO: compiling or setting up the arb executable"

# # if compilation is required then need to find compiler
#   if [ $ocompile -eq 1 ] ; then
#   # try intel compiler first
#     if [ $compiler = "intel" -o $compiler = "default" ] ; then
#       if which ifort >/dev/null 2>/dev/null ; then
#         echo "INFO: found intel compiler at `which ifort`";
#         compiler="intel";
#   # find version of intel compiler
#         intel_version=`ifort -v 2>&1`; # this should give us the version as 'ifort version 12.1.2' say - NB, this is output to stderr, so we redirect this to stdout
#         intel_version=${intel_version#ifort version }; # remove shortest string from the front giving '12.1.2'
#         intel_version=${intel_version#Version }; # format for version 11 was slightly different to versions 12 and 13 (thanks intel!)
#         intel_version=${intel_version%%.*}; # remove longest string from the back giving '12' or '11' or '13'
#         if [ "${#intel_version}" -gt 2 -o "${#intel_version}" -lt 1 ] ; then
#           echo "INFO: intel compiler version incorrectly identified as |$intel_version|";
#           echo "INFO: length of intel compiler ${#intel_version}";
#           echo "WARNING: set the variable intel_version manually in the makefile to be consistent with the output of 'ifort -v'";
#           unset intel_version
#         else
#           echo "INFO: intel compiler version identified as $intel_version";
#         fi
#       else
#         if [ $compiler = "intel" ] ; then
#           echo "ERROR: requested intel compiler is not in the path" ;
#           cd "$working_dir"; exit 1;
#         fi
#       fi
#     fi
#   # try gnu compiler second
#     if [ $compiler = "gnu" -o $compiler = "default" ] ; then
#       if which gfortran >/dev/null 2>/dev/null; then
#         echo "INFO: found gfortran compiler at `which gfortran`";
#         compiler="gnu";
#       else
#         if [ $compiler = "gnu" ] ; then
#           echo "ERROR: requested gnu compiler is not in the path" ;
#           cd "$working_dir"; exit 1;
#         fi
#       fi
#     fi
#   # if nothing is found 
#     if [ $compiler = "default" ] ; then
#       echo "ERROR: no compiler is present";
#       cd "$working_dir"; exit 1;
#     elif [ ! $compiler = "intel" -a ! $compiler = "gnu" ] ; then
#       echo "ERROR: unknown requested compiler $compiler";
#       cd "$working_dir"; exit 1;
#     fi

#     if [ ! $compiler = "intel" ] ; then
#       oilp="off"; # long integers only implemented for ifort right now
#     fi

#   # check to see what compiler was used last time, and if different, make clean
#   # check to see whether debugging was used last time, and if different, make clean
#   # check to see whether open mp was used last time, and if different, make clean
#     if [ ! -e last_compiler_was_$compiler -o ! -e last_compile_had_debugging_$odebug -o ! -e last_compile_had_omp_$oomp -o ! -e last_compile_had_opt_$oopt -o ! -e last_compile_had_ilp_$oilp ] ; then
#       echo "INFO: cleaning of compilation files required as compile options different from previous run";
#       make compiler=$compiler clean_compile;
#       if [ "$?" -ne 0 ] ; then
#         echo "ERROR: problem cleaning compilation files from the build directory due to different compilation options" ;
#         cd "$working_dir"; exit 1 ;
#       fi ;
#     fi

# # check to see whether the arb directory is the same as last time too, and if not, we'll have to clean setup too
#     if [ -e last_arb_dir ] ; then
#       last_arb_dir=`cat last_arb_dir`;
#       if [ ! "$arb_dir" = "$last_arb_dir" ] ; then
#         echo "INFO: cleaning of compilation and setup files required as arb directory has changed since the last run:";
#         echo "      arb_dir = $arb_dir"
#         echo "      last_arb_dir = $last_arb_dir"
#         make compiler=$compiler clean;
#         if [ "$?" -ne 0 ] ; then
#           echo "ERROR: problem cleaning files from the build directory due to a different arb directory being used" ;
#           cd "$working_dir"; exit 1 ;
#         fi ;
#       fi ;
#     fi

#   # record options used this time
#     touch last_compiler_was_$compiler ;
#     touch last_compile_had_debugging_$odebug ;
#     touch last_compile_had_omp_$oomp ;
#     touch last_compile_had_opt_$oopt ;
#     touch last_compile_had_ilp_$oilp ;
#     echo $arb_dir >last_arb_dir;

#   fi

# # assemble makeline and make
#   makeline="make opt=$oopt ilp=$oilp pardiso_from_arb=\"$opardiso\" suitesparse_from_arb=\"$osuitesparse\" mgmres_from_arb=\"$omgmres\" sparse_from_arb=\"$osparse\" arb_dir=\"$arb_dir\" working_dir=\"$working_dir\" output_dir=\"$output_dir\"";
#   if [ $osetup -eq 0 ] ; then
#     makeline="$makeline compile_only" ;
#   else
#     if which maxima >/dev/null ; then
#       echo "INFO: found maxima at `which maxima`";
#     else
#       echo "ERROR: maxima is not in the path - is it installed?" ;
#       cd "$working_dir"; exit 1;
#     fi
#     if [ $ocompile -eq 0 ] ; then
#       makeline="$makeline setup_only" ;
#     fi ;
#   fi ;
#   if [ $odebug -eq 1 ] ; then makeline="$makeline debug=on" ; fi ;
#   if [ $oomp -eq 1 ] ; then makeline="$makeline omp=on" ; fi ; # if omp is greater than 1 then use open mp
#   if [ -n "${intel_version}" ] ; then makeline="$makeline intel_version=$intel_version" ; fi ;

# # echo "makeline = $makeline";

#   makeline="$makeline compiler=$compiler";
#   echo "INFO: running make using commands: $makeline"; echo
#   eval $makeline;

#   if [ "$?" -ne 0 ] ; then
#     echo "ERROR: problem compiling/setting up arb using make" ;
#     cd "$working_dir"; exit 1 ;
#   else
#     echo "INFO: arb make/setup successful" ;
#   fi ;
#   echo

# fi ;

# # move back to working directory
# echo "INFO: moving back to working directory"
# cd "$working_dir";

# ###############################################
# # finally run program
# if [ $orun -eq 1 ] ; then

#   echo "INFO: running arb executable"; echo

#   if [ ! -e $arb_executable ] ; then
#     echo "ERROR: arb executable does not exist" ;
#     exit 1 ;
#   fi

#   if [ ! $debugger = "none" ] ; then # debugger specifies purely what environment code is to run, and is now strictly separate to odebug
#     if [ $debugger = "default" ] ; then
#       if [ $compiler = "gnu" ] ; then # if debugger is not explicitly set, set it to be consistent with the compiler
#         debugger="gdb";
#       else
#         debugger="idb";
#       fi;
#     fi;
#     if [ $debugger = "gdb" ] ; then # macports now uses ggdb to refer to gdb, so try this if gdb isn't found
#       if ! which $debugger >/dev/null ; then
#         debugger="ggdb";
#       fi;
#     fi;
#     if which $debugger >/dev/null ; then
#       echo "INFO: found $debugger at `which $debugger`";
#     else
#       echo "ERROR: $debugger is not in the path - is it installed?" ;
#       exit 1;
#     fi
#     if [ $debugger = "valgrind" ]; then
#       $debugger $arb_executable --track-origins=yes --leak-check=full -v;
#     else
#       $debugger -q -ex run $arb_executable;
#     fi
#   else
#     if [ $oprocesslogging -eq 0 ] ; then
#       $arb_executable; # standard invocation
#       if [ $? -ne 0 ] ; then errorstatus=2; fi # pickup exit status, noting that a nonzero value means that the code did not converge
#     else # invocation of job while logging process statistics
#       set -m; # need to enable job control within bash to allow backgrounding and foregrounding of arb process
#       $arb_executable & # initially placing arb in the background, so that we can get pid and use it to start memory logger
#       arbpid=$!; # $! reports pid of the last backgrounded job, in this case the build/arb process
#       echo "INFO: arb pid is $arbpid";
#       logprocess $arbpid $oprocesslogging $processlogfile & # logprocess in the background
#       fg 1 >/dev/null; # now pull job back into the foreground so that killing the script also kills the subprocess (arb)
#       if [ $? -ne 0 ] ; then errorstatus=2; fi
#       sleep $(($oprocesslogging+1)); # have to wait for a logging interval after the job has finished so that output.scr is still there when logging command writes to it (batcher may move it immediately when arb script ends)
#     fi;
#   fi ;
#   echo "INFO: finishing running arb";
# fi ;
