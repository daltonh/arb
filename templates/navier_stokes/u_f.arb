# calculate the Rhie-Chow type velocity correction, only applied (nonzero) on the domain faces
<<dim1comment>>FACE_LOCAL <u_f_vect[l=1]> "faceave[<<reflect=1>>](<u[l=1]>)"
<<dim2comment>>FACE_LOCAL <u_f_vect[l=2]> "faceave[<<reflect=2>>](<u[l=2]>)"
<<dim3comment>>FACE_LOCAL <u_f_vect[l=3]> "faceave[<<reflect=3>>](<u[l=3]>)"
FACE_DERIVED <u_f_{raw}> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" ON <all faces> # volume (velocity) transport
FACE_LOCAL <eps_p> "abs(<p_error>)" ON <domain faces>
FACE_LOCAL <sign_p> "signum(<p_error>)" ON <domain faces>

# advection limiter
# alternative v0.5 method based on average velocity magnitude
#CELL_DERIVED <u_mag2> "dot(<u[l=:]>,<u[l=:]>)" ON <all cells>
#FACE_DERIVED <u_mag2_f> "facemax(<u_mag2>,0.d0)" ON <domain faces>
#FACE_LOCAL <u_mf_{adv}> "-sqrt(<u_mag2_f>)+sqrt(<u_mag2_f>+<eps_p>*<facedx>/<rho_f>)" ON <domain faces>
# pre v0.5 method based on component of velocity in direction of face normal
FACE_LOCAL <u_mf_{adv}> "-abs(<u_f_{raw}>)+sqrt(<u_f_{raw}>^2+<eps_p>*<facedx>/<rho_f>)" ON <domain faces>
#FACE_LOCAL <u_mf_{adv}> "sqrt(<eps_p>*<facedx>/<rho_f>)" ON <domain faces>

# viscous limiter
# this didn't seem to work
#<<cartesiancomment>>FACE_LOCAL <u_mf_{vis}> "<eps_p>*<facedx>^2/<mu_f>" ON <domain faces>
## additional contribution to velocity interpolation from cylindrical hoop-stress term
#<<cylindricalcomment>>FACE_LOCAL <u_mf_{vis}> "facemin(<eps_p>*<facedx>^2/<mu_f>,<eps_p>*<<radius_f>>^2/(2.d0*<mu_f>))" ON <domain faces>
FACE_LOCAL <u_mf_{vis}> "<eps_p>*<facedx>^2/<mu_f>" ON <domain faces>

# this file now does both steady-state and transient using transient comments string replacements, which are set in constants.arb

# transient limiter
# this is the equivalent time that the limiter has been moving in the one direction
# noting that the variables (<u_f_{correction}> and <eps>) here are previous timestep ones
<<transientnavierstokescomment>>FACE_TRANSIENT <t_{Rhie-Chow}[r=1]> "0.d0" "abs(<u_f_{correction}>)*<rho_f>/facemax(<eps_p>*<C_{Rhie-Chow}>,1.d-20)" ON <domain faces>
# need to save previous pressure error sign
<<transientnavierstokescomment>>FACE_TRANSIENT <sign_p[r=1]> "0.d0" "<sign_p>" ON <domain faces>
<<transientnavierstokescomment>>FACE_LOCAL <u_mf_{transient}> "<eps_p>*(faceif(<sign_p>*<sign_p[r=1]>,<t_{Rhie-Chow}[r=1]>,0.d0)+<dt>)/<rho_f>" ON <domain faces>

# combined limiter, using one of two possible methods
# use a straight minimum of the three or two correction velocities
#<<transientnavierstokescomment>>FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>*facemin(facemin(<u_mf_{adv}>,<u_mf_{vis}>),<u_mf_{transient}>)" ON <domain faces>
#<<steadystatenavierstokescomment>>FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>*facemin(<u_mf_{adv}>,<u_mf_{vis}>)" ON <domain faces>
# alternatively, average the reciprocal of the three of two correction velocities
# in pre v0.53 these weren't limited using <tinyish> which could case a problem if one is zero
<<transientnavierstokescomment>>FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>/(1.d0/facemax(<u_mf_{transient}>,<tinyish>)+1.d0/facemax(<u_mf_{adv}>,<tinyish>)+1.d0/facemax(<u_mf_{vis}>,<tinyish>))" ON <domain faces>
<<steadystatenavierstokescomment>>FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>/(1.d0/facemax(<u_mf_{adv}>,<tinyish>)+1.d0/facemax(<u_mf_{vis}>,<tinyish>))" ON <domain faces>
# it isn't clear which of the above two methods is better: the reciprocal version can be slightly more expensive to calculate, but as it varies more continuously, can (sometimes, possibly, etc etc) lead to slightly faster overall simulation times.  Doesn't seem to be much in it though.
# unfortunately in versions around v0.52 the steady-state and transient cases were accidentally handled using different methods (transient with reciprocal averaging, steady-state with straight minimum)
# for debugging set the correction velocity to be solely only one of the three possibilities
#FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>*<u_mf_{transient}>" ON <domain faces>
#FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>*<u_mf_{vis}>" ON <domain faces>
#FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<sign_p>*<u_mf_{adv}>" ON <domain faces>

# final face velocity
FACE_DERIVED <u_f> "<u_f_{raw}>+faceif(facedelta(<domain faces>),<u_f_{correction}>,0.d0)" ON <all faces> # volume (velocity) transport

#FACE_OUTPUT <advection correction limited> "faceif(<u_mf_{adv}>-<u_mf_{vis}>,0.d0,1.d0)" ON <domain faces> # is 1 where advection component is limiting velocity correction
