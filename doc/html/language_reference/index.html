<!-- INFO from assembler: markdown_filename = /Users/daltonh/codes/arb/development/arb_doc/current/doc/html/language_reference/index.md: arb version = 0.57 -->
<!-- pre comments -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> <meta http-equiv="Content-Style-Type" content="text/css" /> <meta name="generator" content="pandoc" />
<title></title>
  <style type="text/css">code{white-space: pre;}</style>
  
<link rel="stylesheet" href="/Users/daltonh/codes/arb/development/arb_doc/current/doc/html/css/arb_body.css" type="text/css" /> <link rel="stylesheet" href="/Users/daltonh/codes/arb/development/arb_doc/current/doc/html/css/arb_main.css" type="text/css" />
</head>
<body>
<div id="container">
<!-- add a blank left margin here-->
<!--<div id=leftcolumn></div>-->
<div id="maincolumn">
<!-- pre comments -->

<h1>Expression Language Reference</h1>
<p><em>There’s lots missing in this section. The examples files are currently the best guide as to the language syntax.</em></p>
<p>The expression language refers to the psuedo-mathematical language that is used to represent each variable’s expression. arb uses the symbolic algebra program ‘maxima’ to parse this language and convert these expressions into executable (fortran), so any mathematical operators supported by ‘maxima’ are able to be used in this language. In addition to maxima’s features, the expression language also supports a number of discretisation operators that allow spatially varying (multiphysics) problems to be expressed in scalar arithmetic. The discretisation operators are particularly suited to solving transport problems using the Finite Volume Method.</p>
<h2>Discretisation Operators</h2>
<h3>General Notes</h3>
<p>Discretisation operators produce a single value from the arguments that are contained within their parentheses (). They also accept options, contained within square brackets [], and placed between the operator name and any parentheses. Operators are (by convention) typed lowercase (although should parse in uppercase) and contain no underscores.</p>
<pre >
<span style="color: #808080;">operator[option1,option2,...](</span><span style="color: #808080;">&lt;argument1&gt;</span><span style="color: #808080;">,</span><span style="color: #808080;">&lt;argument2&gt;</span><span style="color: #808080;">,...)</span>
</pre>

<p>Example <code>facegrad</code> and <code>celldiv</code> operators contained within variable definitions:</p>
<pre >
<span style="color: #5F5FD7; font-weight: bold;">FACE_OUTPUT</span> <span style="color: #808080;">&lt;phigrad&gt;</span> <span style="color: #808080;">&quot;</span><span style="color: #5F8787;">facegrad[</span><span style="color: #008787; font-weight: bold;">adjacentcells</span><span style="color: #5F8787;">]</span><span style="color: #808080;">(</span><span style="color: #808080;">&lt;phi&gt;</span><span style="color: #808080;">)</span><span style="color: #808080;">&quot;</span> <span style="color: #5F5FD7; font-weight: bold;">ON</span> <span style="color: #8700D7;">&lt;allfaces&gt;</span> <span style="color: #87D7D7;"># operator is facegrad, argument is &lt;phi&gt; and a single option of adjacentcells is specified</span>
<span style="color: #5F5FD7; font-weight: bold;">CELL_EQUATION</span> <span style="color: #808080;">&lt;continuity&gt;</span> <span style="color: #808080;">&quot;</span><span style="color: #5F8787;">celldiv</span><span style="color: #808080;">(</span><span style="color: #808080;">&lt;u_f&gt;</span><span style="color: #808080;">)</span><span style="color: #808080;">&quot;</span> <span style="color: #5F5FD7; font-weight: bold;">ON</span> <span style="color: #8700D7;">&lt;domain&gt;</span> <span style="color: #87D7D7;"># operator is celldiv acting on single argument of &lt;u_f&gt;</span>
</pre>

<h3>Operator Centering</h3>
<p>The centring of most operators corresponds to the first syllable of the operator.</p>
<p>Following the rule is celldiv which is the cell centred divergence of a face centred quantity. This operator is cell centred and must be used in this context, hence its context centring is cell. The content expression passed into (actually its first argument) is face centred however. Similarly, facegrad is the gradient of a cell centred quantity evaluated at a face, so this operator is face (context) centred, but its argument (content) has cell centring.</p>
<pre >
<span style="color: #808080;">&quot;</span><span style="color: #5F8787;">celldiv</span><span style="color: #808080;">(</span><span style="color: #808080;">&lt;u_f&gt;</span><span style="color: #808080;">)</span><span style="color: #808080;">&quot;</span> <span style="color: #87D7D7;"># cell context centring, face argument centring</span>
<span style="color: #808080;">&quot;</span><span style="color: #5F8787;">facegrad</span><span style="color: #808080;">(</span><span style="color: #808080;">&lt;phi&gt;</span><span style="color: #808080;">)</span><span style="color: #808080;">&quot;</span> <span style="color: #87D7D7;"># face context centring, cell argument centring</span>
</pre>

<p>Exceptions to the rule include the loop-type operators, max, min, and sum. For example, cellmax loops through a region of cells finding the maximum value of an expression within those cells. Hence, this operator produces a result which has no centring (none centred) so can be used in any centring context, but its first argument has cell centring.</p>
<pre >
<span style="color: #808080;">&quot;</span><span style="color: #5F8787;">cellmax</span><span style="color: #808080;">(</span><span style="color: #808080;">&lt;phi&gt;</span><span style="color: #808080;">,</span><span style="color: #FFAF00;">0.d0</span><span style="color: #808080;">)</span><span style="color: #808080;">&quot;</span> <span style="color: #87D7D7;"># none context centring, cell centring of the first argument &lt;phi&gt;</span>
<span style="color: #808080;">&quot;</span><span style="color: #5F8787;">facesum</span><span style="color: #808080;">(</span><span style="color: #808080;">&lt;phi_f&gt;</span><span style="color: #808080;">,</span><span style="color: #FFAF00;">0.d0</span><span style="color: #808080;">,</span><span style="color: #8700D7;">&lt;allfaces&gt;</span><span style="color: #808080;">)</span><span style="color: #808080;">&quot;</span> <span style="color: #87D7D7;"># none context centring, face centring of the first argument &lt;phi_f&gt;</span>
</pre>

<h3>Operator Arguments</h3>
<h4>Implicit Operator Arguments</h4>
<p>Each operator accepts a certain number of arguments, however if an argument is not specified then a default value may be used. For example, uses three arguments: an expression that is to evaluated in each cell (, here denoted by a single variable, but more usually an expression of variables), an initial, default expression for the operator (), and the cell centred content region over which the maximum will be calculated (). Using implicit argument notation, operators expect the arguments in a specific order, so expects these three arguments in the manner</p>
<p>If less than the required number of arguments are passed to an operator, then a default value for the omitted arguments will be assumed (or if no defaults are available or are sensible, an error will be flagged). For example, using</p>
<p>sets to (the largest negative double precision number that the processor can store) and to if (for example) the expression was being used in a cell centred context. If in doubt about what the default value for an argument is, specify it!</p>
<h4>Explicit Operator Arguments</h4>
<p>The alternative to the implicit argument notation is to specify the arguments explicitly (similar to argument passing in f90). Using explicit notation the order of the arguments that are passed explicitly is irrelevant, however the order of any arguments that are not explicitly named (and hence specified implicitly) still is. For example, the following will all produce the same result</p>
<p><br /><br /><br /><br /> Note in the last case that although was the second argument in the operator, it was the first implicitly named operator, so would be read correctly. Using a combination of the implicit and explicit passing is often convenient. For example, for the operator, the following form that uses a default value of but performs the maximum comparison over a specified region is handy</p>
<p>Operator options are similar to variable options. Some operators require a dimension, and this dimension (direction) is specified via the options. For example, calculates a gradient in a certain direction dimension using the divergence of a face centred scalar. To find this gradient in the second dimension you use the option :</p>
<p>Some options are quite generic (eg, ), however most are specific to the operator. There is no restriction on the order that options are specified.</p>
<p>Options and operators should be written in lowercase (I have started to make both of these case independent, but no guarantees yet).</p>
<p>Details of individual operators follows. Ultimate details of each operator (including argument order, options etc) can be found in the code file which shows how they are expanded into working code. Use search strings such as within the perl file to find the specific code.</p>
<h3>: Divergence</h3>
<p><em>Summary:</em> Uses Gauss’ theorem to calculate the divergence of a face centred vector component around a cell.</p>
<p><em>Statement:</em></p>
<p><em>Centring:</em></p>
<p>Operator is context cell centred, while is face centred.</p>
<p><em>Details:</em></p>
<p>Using Gauss’ theorem to evaluate divergences around cells is probably the defining characteristic of Finite Volume methods. performs this operation.</p>
<p>Specifically, to discretise the divergence of a face centred vector <span class="math">$\vect[j]{u}$</span> over a cell <span class="math"><em>i</em></span> that sits within the domain, Gauss’ theorem gives <br /><span class="math">$$\begin{aligned}
\frac{1}{\scali[i]{V}} \int_{\scali[i]{V}} \vect{\nabla} \cdot \vect{u} dV &amp; \Rightarrow \frac{1}{\scali[i]{V}} \sum_{j \in \scali[\text{nobcellfaces},i]{\mathbb{J}}} \frac{1}{\scali[j]{S}} \int_{\scali[j]{S}} \vecti[i,j]{N} \cdot \vecti[j]{u} \, dS \\
&amp; = \explain{\sum_{j \in \scali[\text{nobcellfaces},i]{\mathbb{J}}} \frac{\vecti[i,j]{N} \cdot \vecti[j]{n} }{\scali[i]{V}}}{\normalsize\code{celldiv}} \frac{1}{\scali[j]{S}} \int_{\scali[j]{S}} \vecti[j]{n} \cdot \vecti[j]{u} \, dS \nonumber \\
%= \frac{1}{\scal[cell]{V}} \int_{\scal[cell]{S}} \vect[cell]{n} \cdot \vect{u} dS = \frac{1}{\scal[cell]{V}} \sum_j (\vect[cell]{n} \cdot \vecti[j]{n}) (\vect{u} \cdot \vecti[j]{n}) \scali[j]{S} \nonumber \\
&amp; \Rightarrow \code{celldiv(dot(&lt;u[l=:]&gt;,&lt;facenorm[l=:]&gt;))}
\end{aligned}$$</span><br /> where <span class="math">$\scali[i]{V}$</span> and <span class="math">$\scali[j]{S}$</span> are the volume and total surface area of the cell <span class="math"><em>i</em></span> and face <span class="math"><em>j</em></span>, respectively, <span class="math">$\vecti[i,j]{N}$</span> is a unit normal pointing outward from cell <span class="math"><em>i</em></span> but located at face <span class="math"><em>j</em></span>, <span class="math">$\vecti[j]{n}$</span> is a normal associated with face <span class="math"><em>j</em></span>, and the sum is conducted over the set of all face elements that surround cell <span class="math"><em>i</em></span>, denoted by <span class="math">$\scali[\text{nobcellfaces},i]{\mathbb{J}}$</span>. In the equivalent coding the face centred vector <span class="math">$\vecti[j]{u}$</span> is represented by the three component variables , and , and the unit normal associated with the face <span class="math"><em>j</em></span>, <span class="math">$\vecti[j]{n}$</span>, is given by the system component variables , and . Note that as the divergence of a vector results in a scalar, the above operation produces a scalar for each cell it is performed in.</p>
<p>The region used by arb in performing the above sum as represented by <span class="math">$\scali[\text{nobcellfaces},i]{\mathbb{J}}$</span> is (‘no-boundary-cell-faces’). This relative region specifies all faces that surround a given cell, unless that cell is a boundary cell. As boundary cells are not fully surrounded by faces Gauss’ theorem can not be applied. Hence, if the operator is used at a boundary cell then the region is taken relative (moved) to the closest domain cell that is adjacent the boundary cell, so this is where becomes evaluated. Physically it is inadvisable to use an equation that involves a divergence at a boundary cell anyway.</p>
<p><em>Options:</em></p>
<ul>
<li>: No derivatives with respect to the unknown variables for the Newton-Raphson Jacobian are calculated for this operator (and its contents).</li>
</ul>
<p><em>Examples:</em></p>
<pre><code>CELL_EQUATION &lt;continuity&gt; &quot;celldiv(&lt;u_f&gt;)&quot; ON &lt;domain&gt; # continuity equation
CELL_EQUATION &lt;momentum[l=1]&gt; &quot;celldiv(&lt;J_f[l=1]&gt;)&quot; ON &lt;domain&gt; # momentum conservation in direction l=1
CELL_EQUATION &lt;momentum[l=2]&gt; &quot;celldiv(&lt;J_f[l=2]&gt;)&quot; ON &lt;domain&gt; # momentum conservation in direction l=2</code></pre>
<h3>or : Gradient</h3>
<p><em>Summary:</em> Calculates a scalar component of a gradient over a cell or face.</p>
<p><em>Statement:</em></p>
<p><br /> <em>Centring:</em></p>
<p>is context cell centred and is context face centred. In both cases is cell centred.</p>
<p><em>Details:</em></p>
<p>To calculate the gradient of a cell centred scalar <span class="math">$\scali[i]{\phi}$</span> in coodinate direction <span class="math">2</span> in cell <span class="math"><em>i</em></span>, <br /><span class="math">$$\frac{1}{\scali[i]{V}} \int_{\scali[i]{V}} \vecti[2]{e} \cdot \vect{\nabla} \phi dV \Rightarrow \sum_{i' \in \scali[\text{cellcells},i]{\mathbb{I}}} \scali[i,i']{\cellcentred{k}^{(2)}} \scali[i']{\phi} \Rightarrow \code{cellgrad[l=2](phi)} \nonumber$$</span><br /> where <span class="math">$\vecti[2]{e}$</span> is a unit vector in coordinate direction <span class="math">2</span>, <span class="math">$\scali[i,i']{\cellcentred{k}^{(2)}}$</span> is a predetermined kernel for this operation, and <span class="math">$\scali[\text{cellcells},i]{\mathbb{I}}$</span> is the set of all cells in the vicinity of cell <span class="math"><em>i</em></span> that are used by this kernel. Kernels to calculate the cell gradient in the other coordinate directions, that is <span class="math">$\scali[i,i']{\cellcentred{k}^{(1)}}$</span> and <span class="math">$\scali[i,i']{\cellcentred{k}^{(3)}}$</span> also exist.</p>
<p>A gradient of a cell centred quantity evaluated at a face can be calculated similarly, for example <br /><span class="math">$$\frac{1}{\scali[j]{S}} \int_{\scali[j]{S}} \vecti[3]{e} \cdot \vect{\nabla} \phi dS \Rightarrow \sum_{i \in \scali[\text{facecells},j]{\mathbb{I}}} \scali[j,i]{\facecentred{k}^{(3)}} \scali[i]{\phi} \Rightarrow \code{facegrad[l=3](phi)} \nonumber$$</span><br /> Gradients taken in directions relative to the face orientation are also available using the operator. Index <span class="math">4</span> gives the gradient relative to the face’s normal, that is <br /><span class="math">$$\frac{1}{\scali[j]{S}} \int_{\scali[j]{S}} \vecti[j]{n} \cdot \vect{\nabla} \phi dS \Rightarrow \sum_{i \in \scali[\text{facecells},j]{\mathbb{I}}} \scali[j,i]{\facecentred{k}^{(4)}} \scali[i]{\phi} \Rightarrow \code{facegrad[l=4](phi)} \nonumber$$</span><br /> In computational terms the face normal is represented by (,, ). Indices <span class="math">5</span> and <span class="math">6</span> give gradients in the directions of the first and second tangents for each face, respectively, that is <br /><span class="math">$$\frac{1}{\scali[j]{S}} \int_{\scali[j]{S}} \vecti[j]{t}^{(1)} \cdot \vect{\nabla} \phi dS \Rightarrow \sum_{i \in \scali[\text{facecells},j]{\mathbb{I}}} \scali[j,i]{\facecentred{k}^{(5)}} \scali[i]{\phi} \Rightarrow \code{facegrad[l=5](phi)} \nonumber$$</span><br /> and <br /><span class="math">$$\frac{1}{\scali[j]{S}} \int_{\scali[j]{S}} \vecti[j]{t}^{(2)} \cdot \vect{\nabla} \phi dS \Rightarrow \sum_{i \in \scali[\text{facecells},j]{\mathbb{I}}} \scali[j,i]{\facecentred{k}^{(6)}} \scali[i]{\phi} \Rightarrow \code{facegrad[l=6](phi)} \nonumber$$</span><br /> Computationally <span class="math">$\vecti[j]{t}^{(1)}$</span> is represented by (,, ) and <span class="math">$\vecti[j]{t}^{(2)}$</span> by (,, ), respectively. If the face has one dimension then <span class="math">$\vecti[j]{t}^{(1)}$</span> will be directed along the face, and <span class="math">$\vecti[j]{t}^{(2)}$</span> will be normal to both <span class="math">$\vecti[j]{t}^{(1)}$</span> and <span class="math"><em>v</em><em>e</em><em>c</em><em>t</em><em>i</em>[<em>j</em>]<em>n</em></span>. If the face has no or two dimensions (a point or a plane) then there are no preferential directions for these tangents. If no index is specified on the operator then is assumed.</p>
<p><em>Options:</em></p>
<ul>
<li><p>, , etc: This index specifies the direction that the gradient will be taken in. For this index represents the dimension the gradient is taken in and must be specified. For if the index is specified and is <span class="math"> ≤ 3</span>, this specifies the dimension the gradient is taken in. For an index <span class="math"> ≥ 4</span>, the direction is taken relative to the face orientation. specifies a gradient taken in the direction of the face normal, a gradient taken in the direction of the first tangent to the face and in the direction of the second tangent to the face. If the index is not specified for then is assumed — that is, a gradient taken normal to the face.</p></li>
<li><p>for only: Gradient is based on adjacent cells only, but attempts to be in the direction of the face normal (it is only an approximation, but should be accurate for structured meshes). Note, only works for direction — that is, the direction of the face normal.</p></li>
<li><p>for only: Similar to option in that it is based on adjacent cells only, but now it is in the direction of , which is a unit vector pointing from the centre of the cell immediate below the face (in the face’s normal direction) to the centre of the cell immediately above the face. Hence, for unstructured meshes, this gradient is not precisely in the same direction as the true .</p></li>
<li><p>, , etc: This specifies that the contained expression is a component of a vector, and that over any glued reflection boundaries, must be reflected in this direction. These options only need to be specified if the operator is going to be acting over (or next to) a glued, reflection boundary that is reflected in a direction that is the same as the vector’s component direction.</p></li>
<li><p>: As previously.</p></li>
</ul>
<p><em>Examples:</em></p>
<pre><code>FACE_DERIVED &lt;T flux&gt; &quot;-&lt;D&gt;*facegrad(&lt;T&gt;)&quot; ON &lt;all faces&gt; # some type of heat flux occuring across each face
CELL_DERIVED &lt;dpdx[l=1]&gt; &quot;cellgrad[l=1](&lt;p&gt;)&quot; # gradient of pressure in first dimension</code></pre>
<h3>: Interpolation to cell centring</h3>
<p><em>Summary:</em> Interpolates or averages an expression from (mainly) face centring to cell centring.</p>
<p><em>Statement:</em></p>
<p><br /><em>Centring:</em></p>
<p>is context cell centred and generally takes a face centred expression (see option however).</p>
<p><em>Details:</em></p>
<p>Without any options, predefined kernels are used to interpolate the face centred expression from the faces that surround a cell to the centroid of that cell.</p>
<p><em>Options:</em></p>
<ul>
<li><p>: Evaluates at the last face that was referenced in the context of the operator’s position, but treats the result as having cell centring.</p></li>
<li><p>: As above, but moves through glued boundaries to the actual last face that was used (if it was glued).</p></li>
<li><p>: Evaluates at the cell that is adjacent to the last face that was referenced in the context of the operator’s position. In this (exception) case is cell centred. For this case only etc options may be used/necessary as the cell may be on the other side of a glued reflection boundary.</p></li>
<li><p>: As previously.</p></li>
</ul>
<h3>: Interpolation</h3>
<p><em>Summary:</em> Interpolates or averages an expression from cell to face centring.</p>
<p><em>Statement:</em></p>
<p><em>Centring:</em></p>
<p>has face context centring. is cell centred. is face centred. is cell centred.</p>
<p><em>Details:</em></p>
<p>TODO</p>
<p><em>Options:</em></p>
<ul>
<li><p>:</p></li>
<li><p>:</p></li>
<li><p>:</p></li>
<li><p>: As previously.</p></li>
</ul>
<h3>or : Sum</h3>
<p><em>Summary:</em> Performs a sum over a region of either cell or face elements.</p>
<p><em>Statement:</em></p>
<p><br /><br /><br /> <em>Centring:</em></p>
<p>Operators may be cell, face or none centred. Contents of is cell centred, contents of is face centred.</p>
<p><em>Details:</em></p>
<p>This operator sums the contained expression over a region of cell or face elements. If no region is specified, then default regions are applied, defined by:</p>
<p>Operator centring Expression centring Default region ——————- ——————— —————-</p>
<p><em>Options:</em></p>
<ul>
<li>: As previously.</li>
</ul>
<h3>: Gradient evaluated at a cell calculated via a divergence</h3>
<h3>: Gradient limiter for ensuring advection stability</h3>
<h3>, or : If conditional statement</h3>
<h3>or : Product performed over a region of elements</h3>
<h3>, or : Picks the minimum/maximum from a region of elements</h3>
<h3>or : A delta function to identify specific regions</h3>
<h3>or : Link to other regions</h3>
<!-- post comments -->
</div>
<div id="rightheader">
<h1>
arb
</h1>
<h2>
v0.57
</h2>
<h3>
manual
</h3>
</div>
<div id="rightcontents">
<h3>
contents
</h3>
<ul>
<li><a href="/Users/daltonh/codes/arb/development/arb_doc/current/doc/html/index.html">Homepage</a></li>
</ul>
</div>
</div>
</body>
</html>
<!-- post comments -->


