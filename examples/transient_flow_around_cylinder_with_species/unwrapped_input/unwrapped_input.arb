#(comment created during unwrap): new block = resources/test_suite_results/intel/output/build/root_input.arb: sub_block = 0
# root_input.arb file created by the arb script
##################################################################################
# the following external fortran files were found by the arb script and are available for inclusion: /home/daltonh/codes/arb/testsuite/arb_master/src/free_surface_functions.f90
EXTERNALS "/home/daltonh/codes/arb/testsuite/arb_master/src/free_surface_functions.f90"
##################################################################################
# the following working directory files found by the arb script: transient_flow_around_cylinder_with_species.arb
   #(comment created during unwrap): new block = transient_flow_around_cylinder_with_species.arb: sub_block = 0
   #(hash inserted during unwrap)INCLUDE_WORKING "transient_flow_around_cylinder_with_species.arb"
   # arb finite volume solver
   # Copyright 2009,2010 Dalton Harvie (daltonh@unimelb.edu.au)
   #
   # arb is released under the GNU GPL.  For full details see the license directory.
   #
   #-------------------------------------------------------------------
   VERSION 0.59 # the version of syntax used in this file
   
   # the following strings describe the simulation and are passed to the output files
   INFO_TITLE "Transient flow around a cylinder with species transient"
   INFO_DESCRIPTION "Demonstrates transient flow setup as well as transient species transport"
   INFO_DESCRIPTION+ ": large timestep used in this simulation will result in low accuracy, but demonstrate high CFL number ability"
   INFO_AUTHOR "Dalton Harvie"
   INFO_DATE "29/1/15" # interpreted as the start date
   INFO_DATE+ ", 24/9/18"  # interpreted as the last modification date
   
   #-------------------------------------------------------------------
   # system constants
   
   #KERNEL_OPTIONS polynomialorder=1,polynomialaverageorder=1,minimumminw=2.d0
   #KERNEL_OPTIONS minimumminw=1.d0
   #KERNEL_OPTIONS checkminw=.true.,minimumminw=0.8d0 # reducing the minw a bit which will decrease the size of the kernels
   
   # include to examine kernel quality
   #INCLUDE_TEMPLATE "general"
   #INCLUDE "kernel_parameters"
   #-------------------------------------------------------------------
   # geometry
   
   # CELL_REGION/FACE_REGION specified by: <name> "location string" # comments
   # where location string could be: "AT x1 x2 x3" for a single point closest to these coordinates
   # where location string could be: "WITHIN BOX x1_min x2_min x3_min x1_max x2_max x3_max" for all elements within a box defined by the minimum and maximum coordinate values
   # where location string could be: "COMPOUND +<a region>-<another region>" for a + and - compound region list
   # where location string could be: "BOUNDARY OF <a region>" - boundary faces/cells contained within or surrounding <a region>
   # where location string could be: "DOMAIN OF <a region>" - domain faces/cells contained within <a region>
   # where location string could be: "ASSOCIATED WITH <a region>" - faces/cells both contained within and surrounding <a region>
   
   FACE_REGION <slip walls> "compound(<boundaries>-<inlet>-<outlet>-<cylinder>)"
   FACE_REGION <walls> "compound(<cylinder>)"
   NODE_REGION <cylinder nodes> "associatedwith(<cylinder>)"
   FACE_REGION <inlet centreline> "at(0.d0,0.d0,0.d0)" ON <inlet>
   #FACE_REGION <inlet sans centreline> "COMPOUND <inlet>-<inlet centreline>"
   #FACE_REGION <outlet centreline> "AT 0.d0 0.d0 0.d0 PART OF <outlet>"
   #FACE_REGION <outlet sans centreline> "COMPOUND <outlet>-<outlet centreline>"
   CELL_REGION <wake monitor> "at(2.0d0,0.d0,0.d0)" ON <domain>
   
   # MSH_FILE instructs arb to read or write a gmsh file (location is read location - write location will always be within the output directory)
   # output options are: output,centringoutput,meshoutput,centringmeshoutput,nooutput
   # input options are: input,centringinput,meshinput,centringmeshinput,noinput
   # data output format options for CELL centred data (which overwrite individual variable options if specified): elementdata,elementnodedata,elementnodelimiteddata
   # vtk file output options are: vtkoutput,centringvtkoutput,meshvtkoutput,centringmeshvtkoutput,novtkoutput (novtkoutput is the default)
   # dat file output options are: datoutput,centringdatoutput,meshdatoutput,centringmeshdatoutput,nodatoutput (nodatoutput is the default)
   MSH_FILE "transient_flow_around_cylinder_with_species.msh"
   
   #-------------------------------------------------------------------
   # variable definition reference:
   # REGION_LIST <region_1> <region_2> ... <region_n> # comments: line has the ordered names of any regions
   # (CELL_|FACE_)REGION_CONSTANT <name> [multiplier*units] numerical_value_for_region_1 .. value_for_region_n options # comments: sets a constant that varies with region
   # (CELL_|FACE_|NONE_|)CONSTANT <name> [multiplier*units] numerical_value ON <region> options # comments: sets a constant specific to one region or no regions and has the form
   # (CELL_|FACE_|NONE|)CONSTANT <name> [units] "expression (involving only constants)" ON <region> options # comments
   # (CELL_|FACE_|NONE|)TRANSIENT <name> [units] "expression (initial value, optional, evaluated in descending relstep order)" "expression (evaluated in ascending relstep order)" ON <region> options # comments
   # (CELL_|FACE_|NONE|)NEWTIENT <name> [units] "expression (initial value, optional, evaluated in descending relstep order)" "expression (evaluated in ascending relstep order)" ON <region> options # comments
   # (CELL_|FACE_|NONE|)DERIVED <name> [units] "expression" ON <region> options # comments
   # (CELL_|FACE_|NONE|)UNKNOWN <name> [units] "expression (initial value, optional)" ON <region> options # comments
   # (CELL_|FACE_|NONE|)EQUATION <name> [units] "expression (equation equaling zero)" ON <region> options # comments
   # (CELL_|FACE_|NONE|)OUTPUT <name> [units] "expression" ON <region> options # comments
   # (CELL_|FACE_|NONE|)CONDITION <name> [units] "expression" ON <region> options # comments
   # (CELL_|FACE_|NONE|)LOCAL <name> [units] "expression" ON <region> options # comments
   
   # options include (with p=perl and f=fortran indicating which piece of code needs to know the option):
   #p  derivative/noderivative - for DERIVED, EQUATION, LOCAL : do or do not calculate Jacobian derivatives for this variable
   #p  positive/negative/nocheck - for DERIVED, UNKNOWN, EQUATION, LOCAL : check at each iteration that variable is positive/negative
   #f  output/nooutput - for ALL : output compound to msh files
   #f  componentoutput/nocomponentoutput - for ALL : output just this component to msh files
   #f  stepoutput/stepoutputnoupdate/nostepoutput - for ALL : output compound to step file.  The noupdate one does not update the variable when the step file is written (needed for recording when output occurred for example).
   #f  componentstepoutput/componentstepoutputnoupdate/nocomponentstepoutput - for ALL : output just this component to step files
   #f  input/noinput - for CONSTANT, TRANSIENT, UNKNOWN : read in compound from msh files - only these 3 variable types can be read in
   #f  componentinput/nocomponentinput - for CONSTANT, TRANSIENT, UNKNOWN : read in just this component from msh files - only these 3 variable types can be read in
   #f  elementdata,elementnodedata,elementnodelimiteddata - for CELL centred var : data type when writing this compound (unless gmesh overide is specified) (also same for components with prefix component)
   #p  outputcondition,stopcondition,convergencecondition,bellcondition - for CONDITION, type of condition, can have multiple conditions for the one variable
   #f  magnitude=value - for EQUATION, UNKNOWN specifies the initial variable magnitude to be used (rather than being based on the initial variable values) - a negative number will cause the magnitude to be set based upon the initial values (which is the default)
   #f  dynamicmagnitude/staticmagnitude - for EQUATION, UNKNOWN, adjust magnitude of variable dynamically as the simulation progresses, or keep it constant at the initial magnitude
   #f  dynamicmagnitudemultiplier=value - for EQUATION, UNKNOWN, multiplier to use when adjusting magnitude of variable dynamically (=>1.d0, with 1.d0 equivalent to static magnitudes, and large values placing no restriction on the change in magnitude from one newton iteration to the next)
   #   clearoptions - remove all previously (to the left and above the clearoptions word) user-specified options for this variable
   
      #(comment created during unwrap): new block = ../../templates/general/cartesian_x1y2.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE_TEMPLATE "general/cartesian_x1y2" # comment out any references to the third dimension and set the <<dimensions>> list, used in the template files
      #(hash inserted during unwrap)MARKDOWN
      #(hash inserted during unwrap)sets general replacements for cartesian 2D coordinates in the xy plane
      #(hash inserted during unwrap)END_MARKDOWN
      
      
      
   
   # variables etc
   
   # and now also letter size, upon which Re is based
   NONE_CONSTANT <cylinder size> "nodemax(<nodex[l=2]>,region=<cylinder nodes>)-nodemin(<nodex[l=2]>,region=<cylinder nodes>)"
   
   # use templates from the navier_stokes directory to build up problem
   #(hash inserted during unwrap)INCLUDE_TEMPLATE "navier_stokes" # this is the base directory that will be appended to the following files
      #(comment created during unwrap): new block = ../../templates/navier_stokes/constants.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "constants" # specify physical and numerical constants
      # physical data
      CONSTANT <mu> [Pa.s] 1.d-3 # viscosity of liquid
      CONSTANT <rho> [kg/m^3] 1.d0 # density
      CONSTANT <u_av> [m/s] 1.d0 # required average inlet velocity (if used, sets flowrate through inlet)
      
      #-------------
      # set default strings using the following template file, which sets up a steady-state solution to the navier-stokes equations, with uniform viscosity and density
      # see below for appropriate statements to change these decisions
      # these strings are used throughout the navier_stokes template files
      # strings can also be set when calling the template files using per-file replacements, although this isn't the standard way of implementing these settings
         #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "default_string_replacements"
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
         #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)Some of these use both comment and flag type variables, requires three things to be set for each option
         #(hash inserted during unwrap)END_MARKDOWN
         
         
         
         # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
         
         
         
         # previously pressure extrapolation on any walls was accomplished by setting <dynamic_force_f> to zero.  Other options are rhiechow and zeroperror
         
         #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "zeroperror"
         #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "rhiechow"
      
      # use the following to setup a transient simulation
      #GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "" R "<<steadystatenavierstokescomment>>" W "#" R "<<transientnavierstokes>>" W "1"
      
      # could set the transient status based on what type of arb simulation it is, but inadvisable really as there are many instances when only a partial-transient simulation is desired
      #<<transientcomment>>GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "" R "<<steadystatenavierstokescomment>>" W "#" R "<<transientnavierstokes>>" W "1"
      #<<steadystatecomment>>GENERAL_REPLACEMENTS R "<<transientnavierstokescomment>>" W "#" R "<<steadystatenavierstokescomment>>" W "" R "<<transientnavierstokes>>" W "0"
      
      # use the following to specify the stokes equations
      #GENERAL_REPLACEMENTS R "<<stokescomment>>" W "" R "<<navierstokescomment>>" W "#" R "<<stokes>>" W "1"
      
      # use the following to specify nonuniform viscosity
      #GENERAL_REPLACEMENTS R "<<uniformviscositycomment>>" W "#" R "<<nonuniformviscositycomment>>" W "" R "<<uniformviscosity>>" W "0"
      
      # use the following to specify nonuniform density
      #GENERAL_REPLACEMENTS R "<<uniformdensitycomment>>" W "#" R "<<nonuniformdensitycomment>>" W "" R "<<uniformdensity>>" W "0"
      
      # use the following to implement rhie-chow type pressure interpolation on the walls and at fully-developed ports (default is off)
      #GENERAL_REPLACEMENTS R "<<pextrapolationrhiechow>>" W "1"
      #-------------
      
      # numerical data
      CONSTANT <C_{Rhie-Chow}> [] 1.0d+0 # multiplier for Rhie-Chow-type velocity interpolation
      CONSTANT <adv_limiter> [] 1.d0 # multiplier used to limit gradients when calculating advection fluxes
      
      # find an estimate of the domain size using general template
      #(hash inserted during unwrap)INCLUDE_TEMPLATE "general"
         #(comment created during unwrap): new block = ../../templates/general/domain_lengthscale.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "domain_lengthscale" # this will find the none constant <a_lengthscale>
         # find an estimate of the domain size
         # here we use the maximum domain length in each dimension
         # previously used a more accurate but expensive formulation (see minimum_face_boundary_distance)
            #(comment created during unwrap): new block = ../../templates/general/domain_lengths.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "domain_lengths" # this will find a constant vector domain length in each dimension
            # based on node locations, here we calculate the maximum length of the domain in each dimension
            # these loops could be conducted over <boundarynodes>, but although cheaper, this will break if the domain has no boundaries (ie, fully periodic)
            # as this is only a single loop through each node this isn't an expensive calculation anyway (unlike the levelset-based minimum boundary distance)
            NONE_CONSTANT <nodexmax[l=1]> "nodemax(<nodex[l=1]>,region=<allnodes>)"
            NONE_CONSTANT <nodexmax[l=2]> "nodemax(<nodex[l=2]>,region=<allnodes>)"
            #NONE_CONSTANT <nodexmax[l=3]> "nodemax(<nodex[l=3]>,region=<allnodes>)"
            NONE_CONSTANT <nodexmin[l=1]> "nodemin(<nodex[l=1]>,region=<allnodes>)"
            NONE_CONSTANT <nodexmin[l=2]> "nodemin(<nodex[l=2]>,region=<allnodes>)"
            #NONE_CONSTANT <nodexmin[l=3]> "nodemin(<nodex[l=3]>,region=<allnodes>)"
            NONE_CONSTANT <domain_length[l=1]> "<nodexmax[l=1]>-<nodexmin[l=1]>"
            NONE_CONSTANT <domain_length[l=2]> "<nodexmax[l=2]>-<nodexmin[l=2]>"
            #NONE_CONSTANT <domain_length[l=3]> "<nodexmax[l=3]>-<nodexmin[l=3]>"
         # this is based on a vector from the minimum to the maximum coordinates
         #NONE_CONSTANT <a_lengthscale> "sqrt(nonemax(dot(<domain_length[l=:]>,<domain_length[l=:]>),0.d0))"
         # this is based on the maximum domain length over the three dimensions
         NONE_CONSTANT <a_lengthscale> "nonemax(<domain_length[l=1]>,nonemax(<domain_length[l=2]>,<domain_length[l=3]>))"
      
      # for reference calculate some nondimensional quantities
      # these should be overwritten by real nondimensional quantities if this is a nondimensional problem
      CONSTANT <Re> "<u_av>*<rho>*<a_lengthscale>/<mu>" # Reynolds number
      #(comment created during unwrap): new block = transient_flow_around_cylinder_with_species.arb: sub_block = 1
      #(hash inserted during unwrap)IF 0 # dynamic timestepping
         #(comment created during unwrap): new block = transient_flow_around_cylinder_with_species.arb: sub_block = 2
         #(hash inserted during unwrap)IF 0 # implicit timestepping
         #(hash inserted during unwrap)INCLUDE "transient_implicit_setup" # a dynamic timestep to keep the CFL number at a specified level - implicit timestepping
         #(comment created during unwrap): new block = transient_flow_around_cylinder_with_species.arb: sub_block = 2
         #(hash inserted during unwrap)ELSE
         #(hash inserted during unwrap)INCLUDE "transient_dynamic_setup" # a dynamic timestep to keep the CFL number at a specified level - explicit timestepping
         #(hash inserted during unwrap)END_IF
      #(comment created during unwrap): new block = transient_flow_around_cylinder_with_species.arb: sub_block = 1
      #(hash inserted during unwrap)ELSE
         #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_constant_setup.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "transient_constant_setup" # a constant timestep
         # use this file to initial a transient Navier-Stokes simulation using constant timestepping
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/transient_all_setup.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE_LOCAL "transient_all_setup"
            # setup things needed for transient flow
            # this file works for either dynamic or constant timestepping
            # designed to be called by either transient_constant_setup (linked to transient_setup) or transient_dynamic_setup
            # string replacements default to constant timestepping, or if dynamic timestepping is specified, explicit dynamic timestepping
            # choice should be made by general replacements set from the calling files
            
            # <dt_initial> is used to set the intial timestep during dynamic timestepping or constant timestep otherwise
            
            CONSTANT <t_end> [] 1.d2 # time for simulation to stop
            CONSTANT <celldxave> "cellsum(<celldxmax>,region=<domain>)/cellsum(1.d0,region=<domain>)" # average cell dimension
            CONSTANT <CFL_initial> 1.d-2 # enter a CFL number to set the initial timestep (roughly) - depending on the geometry of cells and non-uniformity of mesh, this may significantly underestimate the actual CFL that results - ie, you may need to choose a smaller number 
            CONSTANT <dt_initial> [] "<CFL_initial>*<celldxave>/<u_av>" # initial timestep based on cell dimension, expecting a velocity of magnitude <u_av>
            CONSTANT <CFL_out> 10.d0 # one way of entering the time between output is based on how many times a cell should be flushed between output, based on the average inlet velocity
            CONSTANT <dt_out> [] "<CFL_out>*<celldxave>/<u_av>" # initial timestep based on cell dimension, expecting a velocity of magnitude <u_av>
            #CONSTANT <dt_out> [] "<t_end>/50.d0" # time between output
            
            # transient bits
            GENERAL_OPTIONS transientsimulation
            
            
            # the default is for constant as opposed to dynamic timestepping
            
            
            #---------------------------------------------------------------------------------------------------------
            # dynamic timestepping
            
            # by default there is a explicit newtstep timestep limitation - to remove it reverse the following string replacement
            
            
            # dynamic timestep constants
            #CONSTANT <dt_increase> 1.2d0
            #CONSTANT <dt_decrease> 0.7d0
            #CONSTANT <dt_max> "<dt_initial>*1.d4"
            #CONSTANT <dt_min> "<dt_initial>*1.d-3"
            #CONSTANT <CFL_max> 0.25d0
            #CONSTANT <newtstepdtlimiterlow> 4.d0 # explicitly calculated timestep is only increased if <newtstep[r=1]> is <= than this value
            #CONSTANT <newtstepdtlimiterhigh> 8.d0 # explicitly calculated timestep is decreased if <newtstep[r=1]> is > than this value
            #NONE_TRANSIENT <newtstep[r=1]> "0.d0" "<newtstep>" # we save the previous timestep <newtstep> for the above explicit timestep calculation
            #NONE_TRANSIENT <dt_newtstep_increase[r=1]> "1.d0" "noneif(<newtstep[r=1]>-<newtstepdtlimiterhigh>,<dt_decrease>,noneif(<newtstep[r=1]>-<newtstepdtlimiterlow>,1.d0,<dt_increase>))" # apply this to the previous timestep to keep newtstep roughly between high/low ranges
            ##NONE_LOCAL <dt_newtstep_increase[r=1]> "<dt_increase>" # placeholder for nonnewtsteplimited timestepping
            
            # the default is for explicit timestepping, but implicit can also be enabled by reversing the following strings
            
            
            #NONE_TRANSIENT <dt[r=1]> "<dt_initial>" "<dt>" stepoutput
            #FACE_TRANSIENT <u_f[r=1]> "0.d0" "<u_f>" ON <allfaces> # don't actually need this for implicit timestepping, but it is used in input files for some of the problems for output, so in the interests of not breaking things...
            
            # explicit
            # use CFL_number template, but make the calculation explicit - ie, based on r=1 values
            #INCLUDE "CFL_number" R "<CFL local/dt>" W "<CFL local/dt[r=1]>" R "<u_f>" W "<u_f[r=1]>" R "<CFL local>" W "<CFL local[r=1]>" R "<dt>" W "<dt[r=1]>" R "NONE_OUTPUT <CFL>" W 'NONE_TRANSIENT <CFL[r=1]> ""'
            #<<dynamictimestepcomment>><<explicittimestepcomment>>NONE_TRANSIENT <CFL[r=1]> "" "cellmax(<CFL local[r=1]>,region=<domain>)" output,stepoutput
            #NONE_TRANSIENT <CFL[r=1]> output,stepoutput
            #NONE_TRANSIENT <dt[r=0]> "<dt_initial>" "nonemax(nonemin(nonemin(<dt_newtstep_increase[r=1]>,<CFL_max>/nonemax(<CFL[r=1]>,<tiny>))*<dt[r=1]>,<dt_max>),<dt_min>)" stepoutput,input
            
            # implicit
            # note, a newtstepmax may be applied to <dt_target> within u_f.arb (unfortunately this must be done after <u_f> derived has been calculated, hence, newtstepmax can't be applied here)
            ##INCLUDE "CFL_number"
            ##NONE_UNKNOWN <dt[r=0]> "<dt_initial>" stepoutput,input
            # straight minimum
            # advantage of straight minimum is that provided convergence is achieved the CFL constraint will be rigorously obeyed
            ##NONE_LOCAL <dt_target> "nonemax(nonemin(nonemin(<dt_newtstep_increase[r=1]>*<dt[r=1]>,<CFL_max>/cellmax(<CFL local/dt>,default=<tiny>,region=<domain>)),<dt_max>),<dt_min>)"
            # harmonically averaged, for smoother convergence than the straight minimum which can bounce around
            # disadvantage of the particular harmonic function used is for a factor of two (see below) the dt could be up to twice what the CFL criterion dictates, but using a factor of one can unreasonably decrease timestep below the CFL limit for many timestep combinations
            #<<dynamictimestepcomment>><<implicittimestepcomment>>NONE_LOCAL <dt_explicit_target> "nonemax(nonemin(<dt_newtstep_increase[r=1]>*<dt[r=1]>,<dt_max>),<dt_min>)" stepoutput
            #<<dynamictimestepcomment>><<implicittimestepcomment>>NONE_LOCAL <dt_CFL_target> "nonemax(<CFL_max>/cellmax(<CFL local/dt>,default=<tiny>,region=<domain>),<dt_min>)" stepoutput
            # using two factor here which really doesn't respect dt_increase and CFL_max values correctly, but performs best when both timescales are about the same - ie, more thought required
            #<<dynamictimestepcomment>><<implicittimestepcomment>>NONE_LOCAL <dt_target> "2.d0/(1.d0/<dt_explicit_target>+1.d0/<dt_CFL_target>)" stepoutput
            ##NONE_EQUATION <dt implicit equation> "<dt>-<dt_target>"
            
            #---------------------------------------------------------------------------------------------------------
            # constant timestep, next 1 line
            NONE_CONSTANT <dt> "<dt_initial>"
            #---------------------------------------------------------------------------------------------------------
            
            NONE_TRANSIENT <t[r=0]> "0.d0" "<t[r=1]>+<dt[r=0]>" # time
            NONE_TRANSIENT <t[r=1]> "<t>-<dt[r=0]>" "<t>" # time at last step
            NONE_CONDITION <output test> "<t>-<t_out>-<dt_out>+<dt>*1.d-10" outputcondition # this will be true (>0.) whenever we are <dt_out> from last output
            NONE_OUTPUT <t_out> "<t>" stepoutputnoupdate # this will record the time of the last output
            NONE_CONDITION <stop test> "<t>-<t_end>" stopcondition # when this becomes true (>0.) the simulation stops
            
            # the initial values are blank, which means they will be set equal to the r=0 components, which when updated will mean that they will be set to the initial values for the r=0 components
            CELL_TRANSIENT <u[l=1,r=1]> "" "<u[l=1]>" ON <allcells>
            CELL_TRANSIENT <u[l=2,r=1]> "" "<u[l=2]>" ON <allcells>
            #CELL_TRANSIENT <u[l=3,r=1]> "" "<u[l=3]>" ON <allcells>
            
      #(hash inserted during unwrap)END_IF
   #INCLUDE "domain" R "<<ufadvectioncomplex>>" W "1" # equations to be solved within the domain
      #(comment created during unwrap): new block = ../../templates/navier_stokes/domain.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "domain" # equations to be solved within the domain
         #(comment created during unwrap): new block = ../../templates/navier_stokes/unknowns.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "unknowns" # no .arb suffix is required
         # unknown variables used for flow problems
         CELL_UNKNOWN <u[l=1]> [] "0.d0" ON <allcells> magnitude=1.d0 # velocity component
         CELL_UNKNOWN <u[l=2]> [] "0.d0" ON <allcells> magnitude=1.d0 # velocity component
         #CELL_UNKNOWN <u[l=3]> [] "0.d0" ON <allcells> magnitude=1.d0 # velocity component
         CELL_UNKNOWN <p> [] "1.d0" ON <allcells> # pressure
         #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "total_stress"
         # total stress tensor
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_gradient_tensor.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "u_gradient_tensor"
            # a tensor of face centred gradients that respects any reflections
            # used in the total stress and boundary conditions now
            # as per conventional tensor notation, the first index is the derivative direction, and the second is the velocity direction
            FACE_DERIVED <ugrad_f[l=1,1]> "facegrad[l=1,](<u[l=1]>)" ON <allfaces>
            FACE_DERIVED <ugrad_f[l=1,2]> "facegrad[l=1,](<u[l=2]>)" ON <allfaces>
            #FACE_DERIVED <ugrad_f[l=1,3]> "facegrad[l=1,](<u[l=3]>)" ON <allfaces>
            FACE_DERIVED <ugrad_f[l=2,1]> "facegrad[l=2,](<u[l=1]>)" ON <allfaces>
            FACE_DERIVED <ugrad_f[l=2,2]> "facegrad[l=2,](<u[l=2]>)" ON <allfaces>
            #FACE_DERIVED <ugrad_f[l=2,3]> "facegrad[l=2,](<u[l=3]>)" ON <allfaces>
            #FACE_DERIVED <ugrad_f[l=3,1]> "facegrad[l=3,](<u[l=1]>)" ON <allfaces>
            #FACE_DERIVED <ugrad_f[l=3,2]> "facegrad[l=3,](<u[l=2]>)" ON <allfaces>
            #               FACE_DERIVED <ugrad_f[l=3,3]> "facegrad[l=3,](<u[l=3]>)" ON <allfaces>
         
         # if the numerical velocity divergence is to be included in the stress calculation replace this string with an empty character prior to calling this template
         
         # calculate the velocity divergence (numerical) on each face
         #FACE_DERIVED <udiv_f> "<ugrad_f[l=1,1]>+<ugrad_f[l=2,2]>+<ugrad_f[l=3,3]>" ON <allfaces>
         
         # deal with uniform/nonuniform viscosity, allowing for possibility of user setting <mu_f> directly
         # if you want to overwrite <mu_f>, just define it prior to calling this file and your replacement will overwrite the following
         # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1  # this evaluates as true (1) if replacement string '<mu_f>' isn't defined, AND <<uniformviscosity>> is on (1)
            # if we are here then we apply the uniform viscosity substitution, with 'S'='SUBSTITUTE' meaning to replace the value of this string in its previous (above code block here) definition
            #(hash inserted during unwrap)END_IF
         #{{ print "IN template total_stress\n".string_debug; }}
         
         # no both cartesian and cylindrical stresses don't include pressure
         # without the numerical velocity divergence
         FACE_LOCAL <tau[l=1,1]> "-<mu>*2.d0*<ugrad_f[l=1,1]>" ON <allfaces>
         FACE_LOCAL <tau[l=2,2]> "-<mu>*2.d0*<ugrad_f[l=2,2]>" ON <allfaces>
         #FACE_LOCAL <tau[l=3,3]> "-<mu>*2.d0*<ugrad_f[l=3,3]>" ON <allfaces>
         # overwrite these if the numerical velocity divergence is to be included, see <<udivfcomment>> string replacement above
         # Note: "<udiv_f>/3.d0" is specifically replaced in strain_rate_magnitude template
         #FACE_LOCAL <tau[l=1,1]> "-<mu>*2.d0*(<ugrad_f[l=1,1]>-<udiv_f>/3.d0)" ON <allfaces>
         #FACE_LOCAL <tau[l=2,2]> "-<mu>*2.d0*(<ugrad_f[l=2,2]>-<udiv_f>/3.d0)" ON <allfaces>
         ##FACE_LOCAL <tau[l=3,3]> "-<mu>*2.d0*(<ugrad_f[l=3,3]>-<udiv_f>/3.d0)" ON <allfaces>
         FACE_LOCAL <tau[l=1,2]> "-<mu>*(<ugrad_f[l=1,2]>+<ugrad_f[l=2,1]>)" ON <allfaces>
         #FACE_LOCAL <tau[l=1,3]> "-<mu>*(<ugrad_f[l=1,3]>+<ugrad_f[l=3,1]>)" ON <allfaces>
         #FACE_LOCAL <tau[l=2,3]> "-<mu>*(<ugrad_f[l=2,3]>+<ugrad_f[l=3,2]>)" ON <allfaces>
         FACE_LOCAL <tau[l=2,1]> "<tau[l=1,2]>" ON <allfaces>
         #FACE_LOCAL <tau[l=3,1]> "<tau[l=1,3]>" ON <allfaces>
         #FACE_LOCAL <tau[l=3,2]> "<tau[l=2,3]>" ON <allfaces>
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 1
            #(hash inserted during unwrap)IF 0
               #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)VARIABLE <tau[l=0,0]> "<tau[l=0,0]>+<mu>*<u_f_vect[l=0]>/<facex[l=0]>"
               #(hash inserted during unwrap)VARIABLE <tau[l=0,0]> "<tau[l=0,0]>"
               #(comment created during unwrap): new block = ../../templates/navier_stokes/total_stress.arb: sub_block = 2
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)VARIABLE <tau[l=0,0]> "-<mu>*<facex[l=0]>*facegrad[l=0,](<u[l=0]>/<cellx[l=0]>)" OUTPUT
               #(hash inserted during unwrap)VARIABLE <tau[l=0,0]> "<tau[l=0,0]>"  OUTPUT
               #(hash inserted during unwrap)END_IF
            #(hash inserted during unwrap)VARIABLE <tau[l=0,0]> "-<mu>*2.d0*<u_f_vect[l=0]>/<facex[l=0]>"
            #(hash inserted during unwrap)END_IF
         
         
         #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "u_f"
         # interpolate the cell centred velocity to the faces and find the velocity (flux) normal to the face (<u_f>), using a rhie-chow spirited interpolation technique on the domain faces
         
         # check default strings are set
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, requires three things to be set for each option
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
            
            # previously pressure extrapolation on any walls was accomplished by setting <dynamic_force_f> to zero.  Other options are rhiechow and zeroperror
            
            #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "zeroperror"
            #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "rhiechow"
         
         # start by calculating the difference between the local face centred (dynamic) pressure gradient and average of cell centred (dynamic) pressure gradients in the face direction
         # `dynamic' pressure here means the pressure that is able to cause fluid flow, ie, possibly accounting for hydrostatic pressure variations (for example)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "p_error"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)A Rhie-Chow-type velocity interpolation is applied to the face flux velocities, and this requires the difference between the facecentred dynamic force (<dynamic_force_f>) and the averaged component of the cell centred dynamic force (<dynamic_force_c[l=:]>), <p_error>
            #(hash inserted during unwrap)END_MARKDOWN
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/dynamic_force.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "dynamic_force" # calculate the cell centred dynamic force
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)dynamic force is the pressure force that could cause fluid movement
               #(hash inserted during unwrap)it is added directly to the momentum equations, and used in calculating p_error used in the face velocity interpolation
               #(hash inserted during unwrap)dynamic force now has the physically correct sign!
               #(hash inserted during unwrap)The pressure gradient is calculated via a divergence (consistent with momentum conservation) (on boundary cells values from the adjacent domain cells will be used)
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)<dynamic_force_f> is calculated at the same time as <p_error>, within p_error.arb, which this file is called from
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)Other dynamic_force templates (eg, vof, electrokinetics) increment <dynamic_force_c[l=:]> set in this file, as well as <dynamic_force_f>
               #(hash inserted during unwrap)END_MARKDOWN
               
               #FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "p_f"
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Here we average the cell centred pressure <p> to the faces producing <p_f>.  The standard method is to use arithmetic averaging, as in
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)Low order averaging adjacentcell averaging uses a distance weighted average of the adjacent cell values.  Select this by setting
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)High order adjacentcell averaging is as per low order adjacentcell averaging, except that the gradient within each cell is used to get a better estimate of the pressure on each side of the interface.  The amount of gradient used is set by `<p_f_grad_limiter>` which should be between 0.d0 (low order) and 1.d0 after the file is included.  To use this high order averaging set
                  #(hash inserted during unwrap)```arb
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter> 1.d0 # keep this between 0.d0 and 1.d0
                  #(hash inserted during unwrap)```
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  # this is the default pressure interpolation
                  FACE_DERIVED <p_f> "faceave(<p>)" ON <allfaces>
                  
                  # the following are based on averaging from the adjacentcells only, but possibly using high order averaging
                  
                  
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                     #(hash inserted during unwrap)IF 0
                     #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcells](<p>)" output
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 1
                     #(hash inserted during unwrap)ELSE_IF 0
                     #(hash inserted during unwrap)NONE_CONSTANT <p_f_gradient_limiter> 1.d0 # ranging from 1.d0 (highest order) to 0.d0 which will give same as <<pfadjacentcells>> above
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)IF 1
                        #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcells](cellave[lastface](faceave[advection](<p>,<facefromcelldirection>,<p_f_gradient_limiter>)))" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE_IF 0
                        #(hash inserted during unwrap)VARIABLE <p_f> "faceave[adjacentcellsevenweighting](cellave[lastface](faceave[advection](<p>,<facefromcelldirection>,<p_f_gradient_limiter>)))" output
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 2
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)VARIABLE <p_f> "0.5d0*(faceave[advection](<p>,1.d0,<p_f_gradient_limiter>)+faceave[advection](<p>,-1.d0,<p_f_gradient_limiter>))" output
                           #(comment created during unwrap): new block = ../../templates/navier_stokes/p_f.arb: sub_block = 3
                           #(hash inserted during unwrap)IF 1
                           #(hash inserted during unwrap)VARIABLE <p_f> "faceif(facedelta(<boundaries>),<p>,<p_f>)" # special case boundary face pressure value to be equal to boundary cell value.  Without this the boundary pressure will be equally weighted.
                           #(hash inserted during unwrap)END_IF
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)END_IF
               CELL_DERIVED <dynamic_force_c[l=1]> "-celldivgrad[l=1](<p_f>)" ON <allcells>
               CELL_DERIVED <dynamic_force_c[l=2]> "-celldivgrad[l=2](<p_f>)" ON <allcells>
               #CELL_DERIVED <dynamic_force_c[l=3]> "-celldivgrad[l=3](<p_f>)" ON <allcells>
            
            # seems that using <dynamic_force_c_f[l=:]> usually consumes more memory and takes more time to compute, so remove it by default by including the following
            # in the far off future if nobody complains <dynamic_force_c_f[l=:]> may just disappear into the night
            # to bring back <dynamic_force_c_f[l=:]> set this string to 1 to turn this back on
            
            
            # for evaluating the face centred dynamic force there are three options: dxunit, facegrad and facegradadjacentcells
            # right now the default is dxunit, which works well, but implies that u_f_{correction} is not aligned with facenorm (noting that only the component of the correction is applied)
            # facegrad works but is not as effective in damping checkerboarding
            # facegradadjacentcells also works but the implications re directions aren't as clear as the above two options
            
            #GENERAL_REPLACEMENTS D "<<dynamicforcefmethod>>" W "facegrad"
            #GENERAL_REPLACEMENTS D "<<dynamicforcefmethod>>" W "facegradadjacentcells"
            
            # calculate <dynamic_force_c_f[l=:]> if requested
            # interpolation to face centres (for velocity correction) could be done using normal, adjacentcells or adjacentcellsevenweighting, but they're all about the same so choose the computationally simplest
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_c_f[l=1]> "faceave[,adjacentcells](<dynamic_force_c[l=1]>)"
               #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_c_f[l=2]> "faceave[,adjacentcells](<dynamic_force_c[l=2]>)"
               #(hash inserted during unwrap)#FACE_LOCAL <dynamic_force_c_f[l=3]> "faceave[,adjacentcells](<dynamic_force_c[l=3]>)"
               #(hash inserted during unwrap)END_IF
            
            #{{ print "IN p_error.arb\n".string_debug(); }}
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 1
               #(hash inserted during unwrap)IF 1
               # dxunit method
               FACE_LOCAL <dynamic_force_f> "-facegrad[dxunit](<p>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
               FACE_CONSTANT <dot_facenorm_facedxunit> "dot(<facenorm[l=:]>,<facedxunit[l=:]>)" ON <allfaces> # now defined on <allfaces> to allow use as a BC
               # dxunit + dynamicforcecf
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 0
                  #(hash inserted during unwrap)FACE_DERIVED <p_error> "(-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facedxunit[l=:]>))*<dot_facenorm_facedxunit>" ON <domainfaces>
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE
                  # dxunit - dynamicforcecf
                  # lastface is required when averaging the normal when we have periodic gluing, as we require the normal to be orientated relative to the original face, rather than its glued counterpart - this is now the default when cycling through the region adjacentfaceicells, which is used by faceave[adjacentcells]
                  # for reflect gluing, <p_error> is zero anyway
                  #   FACE_DERIVED <p_error> "faceif(<facereflectnorm>,(-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <domainfaces>
                  # need to fix code for adjacentdomaincells for this line to work
                  #   FACE_DERIVED <p_error> "faceif(<facereflectnorm>,(-<dynamic_force_f>+faceave[adjacentdomaincells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))))*<dot_facenorm_facedxunit>,0.d0)" ON <domainfaces>
                  # workaround, explicit code
                  FACE_DERIVED <p_error> "faceif(<facereflectnorm>,(-<dynamic_force_f>+faceif(facedelta(region=<boundaries>),faceave[downcell](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>))),faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facedxunit[l=:]>)))))*<dot_facenorm_facedxunit>,0.d0)" ON <domainfaces>
                  #(hash inserted during unwrap)END_IF
               
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 0
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)# facegrad method
               #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_f> "-facegrad(<p>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 0
                  #(hash inserted during unwrap)# facegrad + dynamicforcecf
                  #(hash inserted during unwrap)FACE_DERIVED <p_error> "-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facenorm[l=:]>)" ON <domainfaces>
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)# facegrad - dynamicforcecf
                  #(hash inserted during unwrap)FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)# adjacentcells method
               #(hash inserted during unwrap)FACE_LOCAL <dynamic_force_f> "-facegrad[adjacentcells](<p>)" ON <allfaces>
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 2
                  #(hash inserted during unwrap)IF 0
                  #(hash inserted during unwrap)# facegradadjacentcells + dynamicforcecf
                  #(hash inserted during unwrap)FACE_DERIVED <p_error> "-<dynamic_force_f>+dot(<dynamic_force_c_f[l=:]>,<facenorm[l=:]>)" ON <domainfaces>
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)# facegradadjacentcells - dynamicforcecf
                  #(hash inserted during unwrap)#   FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentcells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
                  #(hash inserted during unwrap)FACE_DERIVED <p_error> "faceif(<facereflectnorm>,-<dynamic_force_f>+faceave[adjacentdomaincells](dot(<dynamic_force_c[l=:]>,cellave[lastface](<facenorm[l=:]>))),0.d0)" ON <domainfaces>
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/p_error.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR 'No valid dynamicforcefmethod is chosen in the navier_stokes/p_error template file: string currently set as dxunit'
               #(hash inserted during unwrap)END_IF
         
         FACE_LOCAL <u_f_vect[l=1]> "faceave[](<u[l=1]>)"
         FACE_LOCAL <u_f_vect[l=2]> "faceave[](<u[l=2]>)"
         #FACE_LOCAL <u_f_vect[l=3]> "faceave[](<u[l=3]>)"
         FACE_DERIVED <u_f_{raw}> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" ON <allfaces> # volume (velocity) transport
         
         # this file now does both steady-state and transient using transient comments string replacements, which are set in constants.arb
         
         # save old correction velocity for transient calculations
         FACE_TRANSIENT <u_f_{correction}[r=1]> "0.d0" "<u_f_{correction}>" ON <domainfaces>
         
         # assemble <u_f_{correction}>, taking advantage of variable reuse so that only one expression is formed for <u_f_{correction}> (to maximise code efficiency and maxima expression simplifications)
         
         # first assemble demoninator of expression:
         
         # all equation variants here have viscous contribution, so add this first
         # the rf stands for reciprocal and face centred
         # same piece of code as in total_stress to deal with <mu_f> replacement
         # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1  # this evaluates as true (1) if replacement string '<mu_f>' isn't defined, AND <<uniformviscosity>> is on (1)
            # if we are here then we apply the uniform viscosity substitution
            #(hash inserted during unwrap)END_IF
         FACE_LOCAL <u_rf_{vis}> "<mu>/<facedx>^2" ON <allfaces> # incase pextrapolationrhiechow is on, define these locals on allfaces (makes no difference to efficiency as they are locals anyway)
         FACE_DERIVED <u_f_{correction}> "<u_rf_{vis}>" ON <domainfaces>
         
         # advective contribution can be either simple or more complex (set by <<ufadvectioncomplexcomment>>)
         # the default behaviour is to use the simple advective contribution
         
         # include the following line in your input file prior to loading this template file to access the more complex contribution
         #GENERAL_REPLACEMENTS R <<ufadvectioncomplexcomment>> W ""
         
         # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1  # this evaluates as true (1) if replacement string '<rho_f>' isn't defined, AND <<uniformviscosity>> is on (1)
            # if we are here then we apply the uniform density substitution
            #(hash inserted during unwrap)END_IF
         
         # advection term
            #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 1
            #(hash inserted during unwrap)IF 1
            # use this option to base the adv component on the total velocity magnitude, rather than the component over each face
            
            # the old way (pre v0.59) was to use <u_f_{raw}> which is the flux across the face when calculating the advective rhie-chow term
            # the new way (v0.59 and onwards) is based on the total velocity magnitude, so overwrite the string <<ufmagnitude>> with <u_f_vect_magnitude> which is the total magnitude of <u_f_vect[l=:]>
            # initialise variable using the old way, within the applicable block
               #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 2
               #(hash inserted during unwrap)IF 1 # ie, the new way
               # for a transient simulation the previous velocity magnitude is used, consistent with that used in the momentum advection
               # (although this can be overwritten by setting <<ufvectmagnitudetransient>> = 0 directly)
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 1
                  FACE_LOCAL <u_f_vect[l=1,r=1]> "faceave[](<u[l=1,r=1]>)"
                  FACE_LOCAL <u_f_vect[l=2,r=1]> "faceave[](<u[l=2,r=1]>)"
                  #FACE_LOCAL <u_f_vect[l=3,r=1]> "faceave[](<u[l=3,r=1]>)"
                  FACE_TRANSIENT <u_f_vect_magnitude[r=1]> "" "sqrt(facemax(dot(<u_f_vect[l=:,r=1]>,<u_f_vect[l=:,r=1]>),<tinyish>))" ON <allfaces>
                  # S or SUBSTITUTE will redefine variable but in old context, ie, outside of IF block
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 3
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)FACE_LOCAL <u_f_vect_magnitude> "sqrt(facemax(dot(<u_f_vect[l=:]>,<u_f_vect[l=:]>),<tinyish>))" ON <allfaces>
                  #(hash inserted during unwrap)# S or SUBSTITUTE will redefine variable but in old context, ie, outside of IF block
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)END_IF
            # now calculate <u_rf_{adv}>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)# more complex variant, which does not assume generally small correction velocities (and under steady-state conditions is equivalent to what was used pre v0.55) but is more expensive to compute, for what seems like little practical gain.  There is some evidence that the more complex variant can allow steady-state sims to converge more as Re increases, but very very marginal.
               #(hash inserted during unwrap)FACE_LOCAL <eps_p> "facemax(abs(<p_error>),<tinyish>)" ON <allfaces>
               #(hash inserted during unwrap)FACE_LOCAL <u_rf_{adv}> "<eps_p>/(-<u_f_vect_magnitude[r=1]>+sqrt(<u_f_vect_magnitude[r=1]>^2+<eps_p>*<facedx>/<rho>))" ON <allfaces>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f.arb: sub_block = 2
               #(hash inserted during unwrap)ELSE
               # simple advective contribution (which really assumes that locally |<u_f_{raw}>| >> |<u_f_{correction}>|
               FACE_LOCAL <u_rf_{adv}> "2.d0*<rho>*<u_f_vect_magnitude[r=1]>/<facedx>" ON <allfaces>
               #(hash inserted during unwrap)END_IF
            FACE_DERIVED <u_f_{correction}> "<u_f_{correction}>+<u_rf_{adv}>"
            #(hash inserted during unwrap)END_IF
         
         # for transient, add transient component to demoninator, take reciprocal, and add top transient and pressure contributions
         FACE_LOCAL <u_rf_{transient}> "<rho>/<dt>" ON <allfaces>
         FACE_DERIVED <u_f_{correction}> "(-<C_{Rhie-Chow}>*<p_error>+<u_rf_{transient}>*<u_f_{correction}[r=1]>)/(<u_f_{correction}>+<u_rf_{transient}>)"
         # for steady-state just take reciprocal and add pressure contribution
         #FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<p_error>/(<u_f_{correction}>)"
         
         # final face velocity
         FACE_DERIVED <u_f> "<u_f_{raw}>+faceif(facedelta(<domainfaces>),<u_f_{correction}>,0.d0)" ON <allfaces> # volume (velocity) transport
         
         # this section just re-works the implicit timestepping equation to allow a newtstepmax to be applied to <dt_target>
         # save a derived copy of <dt_target> after <u_f> has been calculated so that we can apply newtstepmax to it
         # if <<implicittimestepcomment>> hasn't already been set then set it here (to off) - for on will have already required dynamic timestepping to be on
         
         #NONE_DERIVED <dt_target_derived> "<dt_target>" newtstepmax=10
         #NONE_EQUATION <dt implicit equation> "<dt>-<dt_target_derived>"
         #(comment created during unwrap): new block = ../../templates/navier_stokes/advection_flux.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "advection_flux" # even though this is called for the stokes equations, no terms will be created
         # flux of momentum over and in the direction of each face due to advection
         # which one is chosen depends on the comment strings
         # all require navierstokes equations to be current
         
         # check default strings are set
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, requires three things to be set for each option
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
            
            # previously pressure extrapolation on any walls was accomplished by setting <dynamic_force_f> to zero.  Other options are rhiechow and zeroperror
            
            #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "zeroperror"
            #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "rhiechow"
         
         
         # steady-state and uniform density
         #FACE_LOCAL <J_advection_f[l=1]> "<rho>*faceave[advection,](<u[l=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         #FACE_LOCAL <J_advection_f[l=2]> "<rho>*faceave[advection,](<u[l=2]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         ##FACE_LOCAL <J_advection_f[l=3]> "<rho>*faceave[advection,](<u[l=3]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         # steady-state and varying density
         ##FACE_LOCAL <J_advection_f[l=1]> "faceave[advection,](<rho>*<u[l=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         ##FACE_LOCAL <J_advection_f[l=2]> "faceave[advection,](<rho>*<u[l=2]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         ###FACE_LOCAL <J_advection_f[l=3]> "faceave[advection,](<rho>*<u[l=3]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         # transient and uniform density
         FACE_LOCAL <J_advection_f[l=1]> "<rho>*faceave[advection,](<u[l=1,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         FACE_LOCAL <J_advection_f[l=2]> "<rho>*faceave[advection,](<u[l=2,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         #FACE_LOCAL <J_advection_f[l=3]> "<rho>*faceave[advection,](<u[l=3,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         # transient and varying density
         #FACE_LOCAL <J_advection_f[l=1]> "faceave[advection,](<rho[r=1]>*<u[l=1,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         #FACE_LOCAL <J_advection_f[l=2]> "faceave[advection,](<rho[r=1]>*<u[l=2,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         ##FACE_LOCAL <J_advection_f[l=3]> "faceave[advection,](<rho[r=1]>*<u[l=3,r=1]>,<u_f>,<adv_limiter>)*<u_f>" ON <allfaces>
         #(comment created during unwrap): new block = ../../templates/navier_stokes/momentum_flux.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "momentum_flux"
         # flux of momentum over and in the direction of each face
         
         # check default strings are set
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, requires three things to be set for each option
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
            
            # previously pressure extrapolation on any walls was accomplished by setting <dynamic_force_f> to zero.  Other options are rhiechow and zeroperror
            
            #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "zeroperror"
            #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "rhiechow"
         
         # start by placing in viscous momentum transport, applicable to both the stokes and navier-stokes equations
         FACE_DERIVED <J_f[l=1]> "dot(<facenorm[l=:]>,<tau[l=:,1]>)" ON <allfaces>
         FACE_DERIVED <J_f[l=2]> "dot(<facenorm[l=:]>,<tau[l=:,2]>)" ON <allfaces>
         #FACE_DERIVED <J_f[l=3]> "dot(<facenorm[l=:]>,<tau[l=:,3]>)" ON <allfaces>
         
         # and now add advection momentum transport for just the navier-stokes equations using self-referencing
         VARIABLE <J_f[l=1]> "<J_f[l=1]>+<J_advection_f[l=1]>"
         VARIABLE <J_f[l=2]> "<J_f[l=2]>+<J_advection_f[l=2]>"
         #VARIABLE <J_f[l=3]> "<J_f[l=3]>+<J_advection_f[l=3]>"
         #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "conservation"
         # conservation equations solved over each domain cell (finite volume method)
         
         # check default strings are set
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, requires three things to be set for each option
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
            
            # previously pressure extrapolation on any walls was accomplished by setting <dynamic_force_f> to zero.  Other options are rhiechow and zeroperror
            
            #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "zeroperror"
            #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "rhiechow"
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 1
            #(hash inserted during unwrap)IF 0
            #(hash inserted during unwrap)# old way
            #(hash inserted during unwrap)# cartesian specific
            #(hash inserted during unwrap)CELL_EQUATION <continuity> "celldiv(<u_f>)" ON <domain> # continuity
            #(hash inserted during unwrap)CELL_EQUATION <momentum[l=1]> "celldiv(<J_f[l=1]>)-<dynamic_force_c[l=1]>" ON <domain> # momentum component
            #(hash inserted during unwrap)CELL_EQUATION <momentum[l=2]> "celldiv(<J_f[l=2]>)-<dynamic_force_c[l=2]>" ON <domain> # momentum component
            #(hash inserted during unwrap)#CELL_EQUATION <momentum[l=3]> "celldiv(<J_f[l=3]>)-<dynamic_force_c[l=3]>" ON <domain> # momentum component
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)# cylindrical specific
            #(hash inserted during unwrap)#CELL_EQUATION <continuity> "celldiv(1.d0*<u_f>)/1.d0" ON <domain> # continuity
            #(hash inserted during unwrap)# these also include the hoop stress terms when <<radiusdim?flag>> is appropriately set
            #(hash inserted during unwrap)#CELL_EQUATION <momentum[l=1]> "celldiv(1.d0*<J_f[l=1]>)/1.d0-<dynamic_force_c[l=1]>+0*2.d0*<u[l=1]>*<mu>/(<cellx[l=1]>**2)" ON <domain> # momentum component
            #(hash inserted during unwrap)#CELL_EQUATION <momentum[l=2]> "celldiv(1.d0*<J_f[l=2]>)/1.d0-<dynamic_force_c[l=2]>+0*2.d0*<u[l=2]>*<mu>/(<cellx[l=2]>**2)" ON <domain> # momentum component
            #(hash inserted during unwrap)##CELL_EQUATION <momentum[l=3]> "celldiv(1.d0*<J_f[l=3]>)/1.d0-<dynamic_force_c[l=3]>+0*2.d0*<u[l=3]>*<mu>/(<cellx[l=3]>**2)" ON <domain> # momentum component
            #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 1
            #(hash inserted during unwrap)ELSE
            # compact way, with hoop stress calculated more efficiently
            
            # define cylindrical divergence modifier terms
            
            
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)END_IF
               #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)END_IF
            
            # now create equations
            CELL_EQUATION <continuity> "celldiv(<u_f>)" ON <domain> # continuity
            CELL_EQUATION <momentum[l=1]> "celldiv(<J_f[l=1]>)-<dynamic_force_c[l=1]>" ON <domain> # momentum component
            CELL_EQUATION <momentum[l=2]> "celldiv(<J_f[l=2]>)-<dynamic_force_c[l=2]>" ON <domain> # momentum component
            
            
            # add on hoop stress term separately for cylindrical coordinates
               #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)# perform a check that <<radialdim>> has been correctly defined
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)ERROR 'This is a cylindrical coordinate simulation however the string 0 has not been correctly defined'
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)VARIABLE <momentum[l=0]> "<momentum[l=0]>+2.d0*<u[l=0]>*<mu>/(<cellx[l=0]>**2)"
               #(hash inserted during unwrap)END_IF
            
            #define momentum eqn for azimuthal component
               #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 2
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)# perform a check that <<azimuthaldim>> has been correctly defined
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/conservation.arb: sub_block = 3
                  #(hash inserted during unwrap)IF 
                  #(hash inserted during unwrap)ERROR 'This is a cylindrical coordinate simulation with azimuthal flow however the string 0 has not been correctly defined'
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)VARIABLE <momentum[l=0]> "celldiv(<J_f[l=0]>)+<rho>*<u_f_vect[l=0]>*<u_f_vect[l=0]>/<facex[l=0]>" ON <domain> # momentum component'
               #(hash inserted during unwrap)VARIABLE <momentum[l=0]> "<momentum[l=0]>-<rho>*<u_f_vect[l=0]>**2/<facex[l=0]>"
               #(hash inserted during unwrap)END_IF
            #(hash inserted during unwrap)END_IF
         
         # add transient term which is independent on cartesian or cylindrical coordinates
         VARIABLE <momentum[l=1]> "<rho>*(<u[l=1]>-<u[l=1,r=1]>)/<dt>+<momentum[l=1]>"
         VARIABLE <momentum[l=2]> "<rho>*(<u[l=2]>-<u[l=2,r=1]>)/<dt>+<momentum[l=2]>"
         #VARIABLE <momentum[l=3]> "<rho>*(<u[l=3]>-<u[l=3,r=1]>)/<dt>+<momentum[l=3]>"
         #VARIABLE <momentum[l=1]> "(<rho>*<u[l=1]>-<rho[r=1]>*<u[l=1,r=1]>)/<dt>+<momentum[l=1]>"
         #VARIABLE <momentum[l=2]> "(<rho>*<u[l=2]>-<rho[r=1]>*<u[l=2,r=1]>)/<dt>+<momentum[l=2]>"
         ##VARIABLE <momentum[l=3]> "(<rho>*<u[l=3]>-<rho[r=1]>*<u[l=3,r=1]>)/<dt>+<momentum[l=3]>"
      #(comment created during unwrap): new block = ../../templates/navier_stokes/outlet_p_set.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "outlet_p_set" # outlet BC
         #(comment created during unwrap): new block = ../../templates/navier_stokes/inlet_p_set.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "inlet_p_set" 
         
         # also will need <p_in> to be defined
            #(comment created during unwrap): new block = ../../templates/navier_stokes/inlet_equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "inlet_equations.arb" 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)Sets basic names etc for an outlet region, but does not specify methods
            #(hash inserted during unwrap)END_MARKDOWN
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "boundary_equations" 
               
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, outlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)This has a few variables that can be set:
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)`zerogradu` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
               #(hash inserted during unwrap)`noslip` determines the shear conditions at the boundary
               #(hash inserted during unwrap)`pressure` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `<<boundarymethodvariable>>`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)The defaults specify a fully developed flow through <outlet> with a set flowrate of <u_av> created by varying the uniform <dynamic_force_f> (ie, an outlet).
               #(hash inserted during unwrap)END_MARKDOWN
               
               # First equation is a constraint on normal velocity gradient normal to the boundary
               # by default grad{u}:nn = 0
               #REPLACEMENTS D "<<boundarynormalmethod>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundarynormalmethod>>=rhiechow)
               #REPLACEMENTS D "<<boundarynormalmethod>>" W "zerodynamic"
               #REPLACEMENTS D "<<boundarynormalmethod>>" W "zerogradp"
               #REPLACEMENTS D "<<boundarynormalmethod>>" W "zeroperror"
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 0
                  #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 0
                  #(hash inserted during unwrap)FACE_EQUATION <outlet pextrapolation> "<dynamic_force_f>" ON <outlet>
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 0
                  #(hash inserted during unwrap)FACE_EQUATION <outlet pextrapolation> "<p_error>" ON <outlet>
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 0
                  #(hash inserted during unwrap)FACE_EQUATION <outlet pextrapolation> "facegrad(<p>)" ON <outlet>
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 1
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/u_fully_developed.arb: sub_block = 0
                     #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
                     
                     #(hash inserted during unwrap)MARKDOWN
                     #(hash inserted during unwrap)Sets the gradient of the normal component of velocity normal to a region to zero
                     #(hash inserted during unwrap)END_MARKDOWN
                     
                     #FACE_EQUATION <equation> "facegrad(dot(<u[l=:]>,cellave[lastface](<facenorm[l=:]>)))" ON <region> # normal velocity component is fully developed
                     FACE_EQUATION <outlet fully developed> "ddot(<ugrad_f[l=:,:]>,<facenorm[l=:]>*<facenorm[l=:]>)" ON <outlet> # normal velocity component is fully developed
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: zerogradu"
                  #(hash inserted during unwrap)END_IF
               
               # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
               
               #REPLACEMENTS D "<<boundarytangentmethod>>" W "slip"
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 0
                  #(hash inserted during unwrap)INCLUDE "slip" 
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 1
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
                     #(hash inserted during unwrap)INCLUDE "noslip" 
                     
                     FACE_EQUATION <outlet noslip1> "dot(<u_f_vect[l=:]>,<facetang1[l=:]>)" ON <outlet> # no component tangential to the face
                     #FACE_EQUATION <outlet noslip2> "dot(<u_f_vect[l=:]>,<facetang2[l=:]>)" ON <outlet> # no component tangential to the face in the second tangential direction
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: noslip"
                  #(hash inserted during unwrap)END_IF
               
               # Third equation is a constraint on the velocity or pressure value at the boundary
               # the first three all specify uniform conditions across the boundary:
               #REPLACEMENTS D "<<boundarymethod>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
               #REPLACEMENTS D "<<boundarymethod>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
               #REPLACEMENTS D "<<boundarymethod>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundarymethod>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
               # all of the remaining methods require a single face within the region to be special cased:
               #REPLACEMENTS D "<<boundarymethod>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
               # the following two methods set whatever the <<boundarymethodvariable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundarymethodvariable>>, defaulting to <dynamic_force_f>)
               # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
               #REPLACEMENTS D "<<boundarymethod>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
               
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 1
                  
                  FACE_EQUATION <outlet flowrate equation> "<p_f>-0.d0" ON <outlet> # specified pressure
                  
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 0
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation> "<u_f>+<u_av>" ON <outlet> # specified velocity
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF 
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation> "<u_f>" ON <outlet> # zero velocity
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE_IF  
                  #(hash inserted during unwrap)# all of these boundary methods require the oneface (or centreline) subdomain, so form these first
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
                  #(hash inserted during unwrap)# by default create the single oneface region here
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                     #(hash inserted during unwrap)IF <<boundarycreateoneface>>
                     #(hash inserted during unwrap)INCLUDE "oneface_region"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                     #(hash inserted during unwrap)IF  
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation> "<u_f>" ON <outlet sans centreline> # zero velocity on most of the region
                     #(hash inserted during unwrap)FACE_EQUATION <outlet centreline flowrate equation> "<p_f>" ON <outlet centreline>
                     #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                     #(hash inserted during unwrap)ELSE
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                        #(hash inserted during unwrap)IF 
                        #(hash inserted during unwrap)# for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                        #(hash inserted during unwrap)# to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                        #(hash inserted during unwrap)NONE_DERIVED <outlet u_av_calc> "facesum(-<u_f>*<facearea>,<outlet>)/facesum(<facearea>,<outlet>)" # calculate average velocity directed into the domain
                        #(hash inserted during unwrap)#NONE_DERIVED <outlet u_av_calc> "facesum(-<u_f>*<facearea>*1.d0,<outlet>)/facesum(<facearea>*1.d0,<outlet>)" # calculate average velocity directed into the domain
                        #(hash inserted during unwrap)
                        #(hash inserted during unwrap)# this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                        #(hash inserted during unwrap)NONE_EQUATION <outlet centreline flowrate equation> "<outlet u_av_calc>-<u_av>" # set flowrate through region to give required average velocity
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                        #(hash inserted during unwrap)ELSE_IF 
                        #(hash inserted during unwrap)FACE_EQUATION <outlet centreline flowrate equation> "<p_f>-0.d0" ON <outlet centreline> # set pressure at oneface to <region p>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: pressure"
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)# and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "celldivgrad"
                     #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "facegrad"
                     #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "p"
                     #(hash inserted during unwrap)
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                        #(hash inserted during unwrap)IF 
                        #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                        #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                        #(hash inserted during unwrap)# CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                        #(hash inserted during unwrap)NONE_DERIVED <outlet centreline gradp> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<outlet centreline>)"
                        #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<outlet centreline gradp>" ON <outlet sans centreline> # apply specified pressure over inlet
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                        #(hash inserted during unwrap)ELSE_IF 
                        #(hash inserted during unwrap)NONE_DERIVED <outlet centreline gradp> "facesum(<dynamic_force_f>,region=<outlet centreline>)"
                        #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation> "<dynamic_force_f>-<outlet centreline gradp>" ON <outlet sans centreline>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                        #(hash inserted during unwrap)ELSE_IF 
                        #(hash inserted during unwrap)NONE_DERIVED <outlet centreline gradp> "facesum(facegrad(<p>),region=<outlet centreline>)"
                        #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation> "facegrad(<p>)-<outlet centreline gradp>" ON <outlet sans centreline>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                        #(hash inserted during unwrap)ELSE_IF 
                        #(hash inserted during unwrap)NONE_DERIVED <outlet centreline p> "facesum(<p_f>,region=<outlet centreline>)"
                        #(hash inserted during unwrap)FACE_EQUATION <outlet flowrate equation> "<p_f>-<outlet centreline p>" ON <outlet sans centreline>
                        #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                        #(hash inserted during unwrap)ELSE
                        #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: <<boundarymethodvariable>>"
                        #(hash inserted during unwrap)END_IF
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: pressure"
                  #(hash inserted during unwrap)END_IF
      #(comment created during unwrap): new block = ../../templates/navier_stokes/walls.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "walls" # nonslip walls BC, used on cylinder
         #(comment created during unwrap): new block = ../../templates/navier_stokes/walls_equations.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "walls_equations" 
         
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Sets basic names etc for a wall, but does not specify methods (except for using zerodynamic)
         #(hash inserted during unwrap)END_MARKDOWN
         # set <<boundarynormalmethod>> value to be equatl to <<pextrapolation>>, which is set in default replacement file
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, requires three things to be set for each option
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
            
            # previously pressure extrapolation on any walls was accomplished by setting <dynamic_force_f> to zero.  Other options are rhiechow and zeroperror
            
            #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "zeroperror"
            #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "rhiechow"
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "boundary_equations" 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, inlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)This has a few variables that can be set:
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)`zerodynamic` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
            #(hash inserted during unwrap)`noslip` determines the shear conditions at the boundary
            #(hash inserted during unwrap)`noflux` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `<<boundarymethodvariable>>`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)The defaults specify a fully developed flow through <walls> with a set flowrate of <walls u> created by varying the uniform <dynamic_force_f> (ie, an inlet).
            #(hash inserted during unwrap)END_MARKDOWN
            
            # First equation is a constraint on normal velocity gradient normal to the boundary
            # by default grad{u}:nn = 0
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundarynormalmethod>>=rhiechow)
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "zerodynamic"
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "zerogradp"
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "zeroperror"
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 1
               FACE_EQUATION <walls pextrapolation> "<dynamic_force_f>" ON <walls>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 0
               #(hash inserted during unwrap)FACE_EQUATION <walls pextrapolation> "<p_error>" ON <walls>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)FACE_EQUATION <walls pextrapolation> "facegrad(<p>)" ON <walls>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: zerodynamic"
               #(hash inserted during unwrap)END_IF
            
            # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
            
            #REPLACEMENTS D "<<boundarytangentmethod>>" W "slip"
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)INCLUDE "slip" 
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 1
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "noslip" 
                  
                  FACE_EQUATION <walls noslip1> "dot(<u_f_vect[l=:]>,<facetang1[l=:]>)" ON <walls> # no component tangential to the face
                  #FACE_EQUATION <walls noslip2> "dot(<u_f_vect[l=:]>,<facetang2[l=:]>)" ON <walls> # no component tangential to the face in the second tangential direction
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: noslip"
               #(hash inserted during unwrap)END_IF
            
            # Third equation is a constraint on the velocity or pressure value at the boundary
            # the first three all specify uniform conditions across the boundary:
            #REPLACEMENTS D "<<boundarymethod>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
            #REPLACEMENTS D "<<boundarymethod>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
            #REPLACEMENTS D "<<boundarymethod>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundarymethod>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
            # all of the remaining methods require a single face within the region to be special cased:
            #REPLACEMENTS D "<<boundarymethod>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
            # the following two methods set whatever the <<boundarymethodvariable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundarymethodvariable>>, defaulting to <dynamic_force_f>)
            # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
            #REPLACEMENTS D "<<boundarymethod>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "<p_f>-<walls p>" ON <walls> # specified pressure
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 0
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "<u_f>+<walls u>" ON <walls> # specified velocity
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 1
               
               FACE_EQUATION <walls flowrate equation> "<u_f>" ON <walls> # zero velocity
               
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF  0
               #(hash inserted during unwrap)# all of these boundary methods require the oneface (or centreline) subdomain, so form these first
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)# now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
               #(hash inserted during unwrap)# by default create the single oneface region here
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                  #(hash inserted during unwrap)IF <<boundarycreateoneface>>
                  #(hash inserted during unwrap)INCLUDE "oneface_region"
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                  #(hash inserted during unwrap)IF  
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "<u_f>" ON <walls sans oneface> # zero velocity on most of the region
                  #(hash inserted during unwrap)FACE_EQUATION <walls oneface flowrate equation> "<p_f>" ON <walls oneface>
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)# for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                     #(hash inserted during unwrap)# to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                     #(hash inserted during unwrap)NONE_DERIVED <walls u_av_calc> "facesum(-<u_f>*<facearea>,<walls>)/facesum(<facearea>,<walls>)" # calculate average velocity directed into the domain
                     #(hash inserted during unwrap)#NONE_DERIVED <walls u_av_calc> "facesum(-<u_f>*<facearea>*1.d0,<walls>)/facesum(<facearea>*1.d0,<walls>)" # calculate average velocity directed into the domain
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)# this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                     #(hash inserted during unwrap)NONE_EQUATION <walls oneface flowrate equation> "<walls u_av_calc>-<walls u>" # set flowrate through region to give required average velocity
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <walls oneface flowrate equation> "<p_f>-<walls p>" ON <walls oneface> # set pressure at oneface to <region p>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: noflux"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "celldivgrad"
                  #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "facegrad"
                  #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "p"
                  #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                     #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                     #(hash inserted during unwrap)# CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                     #(hash inserted during unwrap)NONE_DERIVED <walls oneface gradp> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<walls oneface>)"
                     #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<walls oneface gradp>" ON <walls sans oneface> # apply specified pressure over inlet
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_DERIVED <walls oneface gradp> "facesum(<dynamic_force_f>,region=<walls oneface>)"
                     #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "<dynamic_force_f>-<walls oneface gradp>" ON <walls sans oneface>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_DERIVED <walls oneface gradp> "facesum(facegrad(<p>),region=<walls oneface>)"
                     #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "facegrad(<p>)-<walls oneface gradp>" ON <walls sans oneface>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_DERIVED <walls oneface p> "facesum(<p_f>,region=<walls oneface>)"
                     #(hash inserted during unwrap)FACE_EQUATION <walls flowrate equation> "<p_f>-<walls oneface p>" ON <walls sans oneface>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: <<boundarymethodvariable>>"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: noflux"
               #(hash inserted during unwrap)END_IF
      #(comment created during unwrap): new block = ../../templates/navier_stokes/walls_slip.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "walls_slip" 
      # nonslip walls BC, do string replacement that will cover both equation and region names
         #(comment created during unwrap): new block = ../../templates/navier_stokes/walls_equations.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "walls_equations" 
         
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Sets basic names etc for a wall, but does not specify methods (except for using zerodynamic)
         #(hash inserted during unwrap)END_MARKDOWN
         # set <<boundarynormalmethod>> value to be equatl to <<pextrapolation>>, which is set in default replacement file
            #(comment created during unwrap): new block = ../../templates/navier_stokes/default_string_replacements.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "default_string_replacements"
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)These strings are the defaults used by the navier-stokes templates files if not explicitly set by the user
            #(hash inserted during unwrap)They specify a steady-state solution to the navier-stokes equations, with uniform viscosity and density
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)Some of these use both comment and flag type variables, requires three things to be set for each option
            #(hash inserted during unwrap)END_MARKDOWN
            
            
            
            # note, both of these now require the three strings to be set - this is awkward, so instead can set these using the nonuniform_viscosity and nonuniform_density files templates
            
            
            
            # previously pressure extrapolation on any walls was accomplished by setting <dynamic_force_f> to zero.  Other options are rhiechow and zeroperror
            
            #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "zeroperror"
            #GENERAL_REPLACEMENTS D "<<pextrapolation>>" W "rhiechow"
         
            #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "boundary_equations" 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, inlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)This has a few variables that can be set:
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)`zerodynamic` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
            #(hash inserted during unwrap)`slip` determines the shear conditions at the boundary
            #(hash inserted during unwrap)`noflux` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `<<boundarymethodvariable>>`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)The defaults specify a fully developed flow through <slip walls> with a set flowrate of <slip walls u> created by varying the uniform <dynamic_force_f> (ie, an inlet).
            #(hash inserted during unwrap)END_MARKDOWN
            
            # First equation is a constraint on normal velocity gradient normal to the boundary
            # by default grad{u}:nn = 0
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundarynormalmethod>>=rhiechow)
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "zerodynamic"
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "zerogradp"
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "zeroperror"
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 1
               FACE_EQUATION <slip walls pextrapolation> "<dynamic_force_f>" ON <slip walls>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 0
               #(hash inserted during unwrap)FACE_EQUATION <slip walls pextrapolation> "<p_error>" ON <slip walls>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)FACE_EQUATION <slip walls pextrapolation> "facegrad(<p>)" ON <slip walls>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 
               #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: zerodynamic"
               #(hash inserted during unwrap)END_IF
            
            # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
            
            #REPLACEMENTS D "<<boundarytangentmethod>>" W "slip"
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 1
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/slip.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "slip" 
                  
                  #FACE_EQUATION <equation1> "facegrad(dot(<u[l=:]>,cellave[lastface](<facetang1[l=:]>)))" ON <region> # no derivative of component tangential to the face
                  FACE_EQUATION <slip walls slip1> "ddot(<ugrad_f[l=:,:]>,<facetang1[l=:]>*<facenorm[l=:]>)" ON <slip walls> # no derivative of component tangential to the face
                  #<<dim1comment>><<dim2comment>><<dim3comment>>FACE_EQUATION <equation> "facegrad(dot(<u[l=:]>,cellave[lastface](<facetang2[l=:]>)))" ON <region> # no derivative of component tangential to the face, but here in the second tangent direction
                  #FACE_EQUATION <slip walls slip2> "ddot(<ugrad_f[l=:,:]>,<facetang2[l=:]>*<facenorm[l=:]>)" ON <slip walls> # no derivative of component tangential to the face, but here in the second tangent direction
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 0
               #(hash inserted during unwrap)INCLUDE "noslip" 
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: slip"
               #(hash inserted during unwrap)END_IF
            
            # Third equation is a constraint on the velocity or pressure value at the boundary
            # the first three all specify uniform conditions across the boundary:
            #REPLACEMENTS D "<<boundarymethod>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
            #REPLACEMENTS D "<<boundarymethod>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
            #REPLACEMENTS D "<<boundarymethod>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundarymethod>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
            # all of the remaining methods require a single face within the region to be special cased:
            #REPLACEMENTS D "<<boundarymethod>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
            # the following two methods set whatever the <<boundarymethodvariable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundarymethodvariable>>, defaulting to <dynamic_force_f>)
            # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
            #REPLACEMENTS D "<<boundarymethod>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)FACE_EQUATION <slip walls flowrate equation> "<p_f>-<slip walls p>" ON <slip walls> # specified pressure
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 0
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)FACE_EQUATION <slip walls flowrate equation> "<u_f>+<slip walls u>" ON <slip walls> # specified velocity
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 1
               
               FACE_EQUATION <slip walls flowrate equation> "<u_f>" ON <slip walls> # zero velocity
               
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF  0
               #(hash inserted during unwrap)# all of these boundary methods require the oneface (or centreline) subdomain, so form these first
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)# now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
               #(hash inserted during unwrap)# by default create the single oneface region here
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                  #(hash inserted during unwrap)IF <<boundarycreateoneface>>
                  #(hash inserted during unwrap)INCLUDE "oneface_region"
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                  #(hash inserted during unwrap)IF  
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)FACE_EQUATION <slip walls flowrate equation> "<u_f>" ON <slip walls sans oneface> # zero velocity on most of the region
                  #(hash inserted during unwrap)FACE_EQUATION <slip walls oneface flowrate equation> "<p_f>" ON <slip walls oneface>
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)# for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                     #(hash inserted during unwrap)# to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                     #(hash inserted during unwrap)NONE_DERIVED <slip walls u_av_calc> "facesum(-<u_f>*<facearea>,<slip walls>)/facesum(<facearea>,<slip walls>)" # calculate average velocity directed into the domain
                     #(hash inserted during unwrap)#NONE_DERIVED <slip walls u_av_calc> "facesum(-<u_f>*<facearea>*1.d0,<slip walls>)/facesum(<facearea>*1.d0,<slip walls>)" # calculate average velocity directed into the domain
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)# this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                     #(hash inserted during unwrap)NONE_EQUATION <slip walls oneface flowrate equation> "<slip walls u_av_calc>-<slip walls u>" # set flowrate through region to give required average velocity
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <slip walls oneface flowrate equation> "<p_f>-<slip walls p>" ON <slip walls oneface> # set pressure at oneface to <region p>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: noflux"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "celldivgrad"
                  #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "facegrad"
                  #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "p"
                  #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                     #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                     #(hash inserted during unwrap)# CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                     #(hash inserted during unwrap)NONE_DERIVED <slip walls oneface gradp> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<slip walls oneface>)"
                     #(hash inserted during unwrap)FACE_EQUATION <slip walls flowrate equation> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<slip walls oneface gradp>" ON <slip walls sans oneface> # apply specified pressure over inlet
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_DERIVED <slip walls oneface gradp> "facesum(<dynamic_force_f>,region=<slip walls oneface>)"
                     #(hash inserted during unwrap)FACE_EQUATION <slip walls flowrate equation> "<dynamic_force_f>-<slip walls oneface gradp>" ON <slip walls sans oneface>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_DERIVED <slip walls oneface gradp> "facesum(facegrad(<p>),region=<slip walls oneface>)"
                     #(hash inserted during unwrap)FACE_EQUATION <slip walls flowrate equation> "facegrad(<p>)-<slip walls oneface gradp>" ON <slip walls sans oneface>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_DERIVED <slip walls oneface p> "facesum(<p_f>,region=<slip walls oneface>)"
                     #(hash inserted during unwrap)FACE_EQUATION <slip walls flowrate equation> "<p_f>-<slip walls oneface p>" ON <slip walls sans oneface>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: <<boundarymethodvariable>>"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: noflux"
               #(hash inserted during unwrap)END_IF
      #(comment created during unwrap): new block = ../../templates/navier_stokes/inlet_u_set.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "inlet_u_set" # plug flow inlet velocity profile - for inertial problems setting velocity profile directly is more stable than using fully_developed templates
         #(comment created during unwrap): new block = ../../templates/navier_stokes/inlet_equations.arb: sub_block = 0
         #(hash inserted during unwrap)INCLUDE "inlet_equations.arb" 
         
         #(hash inserted during unwrap)MARKDOWN
         #(hash inserted during unwrap)Sets basic names etc for an inlet region, but does not specify methods
         #(hash inserted during unwrap)END_MARKDOWN
            #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "boundary_equations" 
            
            #(hash inserted during unwrap)MARKDOWN
            #(hash inserted during unwrap)Equations for a boundary, now generalised to handle ports or walls.  Generally call this using the wrapper template files, inlet_equations, outlet_equations and wall_equations, generally setting the three method variables:
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)This has a few variables that can be set:
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)`zerogradu` sets some condition normal to the boundary, either a velocity gradient or pressure gradient, or combination
            #(hash inserted during unwrap)`noslip` determines the shear conditions at the boundary
            #(hash inserted during unwrap)`velocity` sets the primary type of boundary condition.  This condition can use a choice of variables determined by `dynamicforce`.  If a oneface region is required or not, then this can be set via `<<boundaryonecreateface>>`
            #(hash inserted during unwrap)
            #(hash inserted during unwrap)The defaults specify a fully developed flow through <inlet> with a set flowrate of <u_av> created by varying the uniform <dynamic_force_f> (ie, an inlet).
            #(hash inserted during unwrap)END_MARKDOWN
            
            # First equation is a constraint on normal velocity gradient normal to the boundary
            # by default grad{u}:nn = 0
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "rhiechow" # a rhie-chow type calculation is used to relate the velocity normal to the boundary and at the boundary to the velocity just inside the domain (<<boundarynormalmethod>>=rhiechow)
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "zerodynamic"
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "zerogradp"
            #REPLACEMENTS D "<<boundarynormalmethod>>" W "zeroperror"
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)INCLUDE "p_extrapolation_rhie_chow" 
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 0
               #(hash inserted during unwrap)FACE_EQUATION <inlet pextrapolation> "<dynamic_force_f>" ON <inlet>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 0
               #(hash inserted during unwrap)FACE_EQUATION <inlet pextrapolation> "<p_error>" ON <inlet>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 0
               #(hash inserted during unwrap)FACE_EQUATION <inlet pextrapolation> "facegrad(<p>)" ON <inlet>
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 1
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/u_fully_developed.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "u_fully_developed" 
                  
                  #(hash inserted during unwrap)MARKDOWN
                  #(hash inserted during unwrap)Sets the gradient of the normal component of velocity normal to a region to zero
                  #(hash inserted during unwrap)END_MARKDOWN
                  
                  #FACE_EQUATION <equation> "facegrad(dot(<u[l=:]>,cellave[lastface](<facenorm[l=:]>)))" ON <region> # normal velocity component is fully developed
                  FACE_EQUATION <inlet fully developed> "ddot(<ugrad_f[l=:,:]>,<facenorm[l=:]>*<facenorm[l=:]>)" ON <inlet> # normal velocity component is fully developed
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR "boundarynormalmethod not known in boundary_equations.arb: zerogradu"
               #(hash inserted during unwrap)END_IF
            
            # Second equation(s) (two here for 3D) is a constraint on the tangential velocity component
            
            #REPLACEMENTS D "<<boundarytangentmethod>>" W "slip"
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)INCLUDE "slip" 
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 1
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/noslip.arb: sub_block = 0
                  #(hash inserted during unwrap)INCLUDE "noslip" 
                  
                  FACE_EQUATION <inlet noslip1> "dot(<u_f_vect[l=:]>,<facetang1[l=:]>)" ON <inlet> # no component tangential to the face
                  #FACE_EQUATION <inlet noslip2> "dot(<u_f_vect[l=:]>,<facetang2[l=:]>)" ON <inlet> # no component tangential to the face in the second tangential direction
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR "boundarytangentmethod not known in boundary_equations.arb: noslip"
               #(hash inserted during unwrap)END_IF
            
            # Third equation is a constraint on the velocity or pressure value at the boundary
            # the first three all specify uniform conditions across the boundary:
            #REPLACEMENTS D "<<boundarymethod>>" W "pressure" # set pressure to <p_f>=<region p> everywhere along the boundary (ie, uniform specified pressure)
            #REPLACEMENTS D "<<boundarymethod>>" W "velocity" # set velocity to <u_f>=<region u> everywhere along the boundary (ie, uniform specified velocity)
            #REPLACEMENTS D "<<boundarymethod>>" W "noflux" # set velocity to 0. everywhere along the boundary, which is equivalent to <<boundarymethod>>="velocity" with <region u> = 0.d0 (ie, <u_f>=0.d0)
            # all of the remaining methods require a single face within the region to be special cased:
            #REPLACEMENTS D "<<boundarymethod>>" W "nofluxpset" # set uniform velocity to 0. across the entire region, except for <region oneface>, which has p set to zero - used for walls within a simulation that otherwise has not absolute pressure value set due to (eg) no inlet or outlet ports
            # the following two methods set whatever the <<boundarymethodvariable>> is to be uniform across the boundary (actually all sans faces are set to oneface), in addition to the following extra condition (so these use <<boundarymethodvariable>>, defaulting to <dynamic_force_f>)
            # set average velocity (flowrate) to <region u> (as well as a uniform <<boundarymethodvariable over the boundary)
            #REPLACEMENTS D "<<boundarymethod>>" W "onefacepressure" # set pressure on oneface to <region p>  (as well as a uniform <<boundarymethodvariable over the boundary) - use on (eg) outlets to anchor pressure, but otherwise allow a uniform (say) dynamic_force across the port which works for (eg) bouyancy problems which have a hydrostatic pressure variation 
            
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)IF 0
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation> "<p_f>-<p_in>" ON <inlet> # specified pressure
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 1
               
               FACE_EQUATION <inlet flowrate equation> "<u_f>+<u_av>" ON <inlet> # specified velocity
               
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF 0
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation> "<u_f>" ON <inlet> # zero velocity
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE_IF  
               #(hash inserted during unwrap)# all of these boundary methods require the oneface (or centreline) subdomain, so form these first
               #(hash inserted during unwrap)
               #(hash inserted during unwrap)# now reference pressure gradient at centreline directly, removing one unknown and equation, but requiring <region sans oneface> and <region region> (from eg oneface_region template)
               #(hash inserted during unwrap)# by default create the single oneface region here
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                  #(hash inserted during unwrap)IF <<boundarycreateoneface>>
                  #(hash inserted during unwrap)INCLUDE "oneface_region"
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                  #(hash inserted during unwrap)IF  
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation> "<u_f>" ON <inlet sans centreline> # zero velocity on most of the region
                  #(hash inserted during unwrap)FACE_EQUATION <inlet centreline flowrate equation> "<p_f>" ON <inlet centreline>
                  #(hash inserted during unwrap)
                  #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 2
                  #(hash inserted during unwrap)ELSE
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)# for a specified flowrate, set some function of pressure to give the required average velocity (ie, a flowrate)
                     #(hash inserted during unwrap)# to do this we need to calculate what the average velocity through the boundary is (positive into the domain here)
                     #(hash inserted during unwrap)NONE_DERIVED <inlet u_av_calc> "facesum(-<u_f>*<facearea>,<inlet>)/facesum(<facearea>,<inlet>)" # calculate average velocity directed into the domain
                     #(hash inserted during unwrap)#NONE_DERIVED <inlet u_av_calc> "facesum(-<u_f>*<facearea>*1.d0,<inlet>)/facesum(<facearea>*1.d0,<inlet>)" # calculate average velocity directed into the domain
                     #(hash inserted during unwrap)
                     #(hash inserted during unwrap)# this is the single equation that needs to be satisfied to set the average velocity of centreline pressure
                     #(hash inserted during unwrap)NONE_EQUATION <inlet centreline flowrate equation> "<inlet u_av_calc>-<u_av>" # set flowrate through region to give required average velocity
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)FACE_EQUATION <inlet centreline flowrate equation> "<p_f>-<p_in>" ON <inlet centreline> # set pressure at oneface to <region p>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: velocity"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# and to do this we let another variable float (a function of pressure), but maintain this variable as uniform across the boundary to constrain the system
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "celldivgrad"
                  #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "facegrad"
                  #(hash inserted during unwrap)# REPLACEMENTS D "<<boundarymethodvariable>>" W "p"
                  #(hash inserted during unwrap)
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)IF 
                     #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=1]> "celldivgrad[l=1](<p_f>)"
                     #(hash inserted during unwrap)CELL_LOCAL <celldivgradp[l=2]> "celldivgrad[l=2](<p_f>)"
                     #(hash inserted during unwrap)# CELL_LOCAL <celldivgradp[l=3]> "celldivgrad[l=3](<p_f>)"
                     #(hash inserted during unwrap)NONE_DERIVED <inlet centreline gradp> "facesum(dot(<celldivgradp[l=:]>,<facenorm[l=:]>),region=<inlet centreline>)"
                     #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation> "dot(<celldivgradp[l=:]>,<facenorm[l=:]>)-<inlet centreline gradp>" ON <inlet sans centreline> # apply specified pressure over inlet
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_DERIVED <inlet centreline gradp> "facesum(<dynamic_force_f>,region=<inlet centreline>)"
                     #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation> "<dynamic_force_f>-<inlet centreline gradp>" ON <inlet sans centreline>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_DERIVED <inlet centreline gradp> "facesum(facegrad(<p>),region=<inlet centreline>)"
                     #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation> "facegrad(<p>)-<inlet centreline gradp>" ON <inlet sans centreline>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE_IF 
                     #(hash inserted during unwrap)NONE_DERIVED <inlet centreline p> "facesum(<p_f>,region=<inlet centreline>)"
                     #(hash inserted during unwrap)FACE_EQUATION <inlet flowrate equation> "<p_f>-<inlet centreline p>" ON <inlet sans centreline>
                     #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 3
                     #(hash inserted during unwrap)ELSE
                     #(hash inserted during unwrap)ERROR "boundarymethodvariable not known in boundary_equations.arb: dynamicforce"
                     #(hash inserted during unwrap)END_IF
                  #(hash inserted during unwrap)
                  #(hash inserted during unwrap)END_IF
               #(hash inserted during unwrap)
               #(comment created during unwrap): new block = ../../templates/navier_stokes/boundary_equations.arb: sub_block = 1
               #(hash inserted during unwrap)ELSE
               #(hash inserted during unwrap)ERROR "boundarymethod not known in boundary_equations.arb: velocity"
               #(hash inserted during unwrap)END_IF
   
   # overwrite the default properties with the following
   NONE_CONSTANT <Re> 5.d+2 # this will be based on the cylinder diameter and plug flow velocity
   CONSTANT <rho> [1] 1.d0 # density
   CONSTANT <u_av> [1] 1.0d0 # average inlet velocity
   CONSTANT <mu> [1] "<rho>*<u_av>*<cylinder size>/<Re>" # viscosity of liquid, NB, whole problem is nondimensional
   
   # and turn some outputs on using the generic VARIABLE statement that picks up the last type and centring
   VARIABLE <u_f_{correction}> output
   VARIABLE <u_f_{raw}> output
   VARIABLE <u_f> output
   VARIABLE <J_f[l=1]> output
   VARIABLE <tau[l=1,1]> output
   
   VARIABLE <p> magnitude=2.d0
   VARIABLE <u[l=1]> magnitude=2.d0
   VARIABLE <u[l=2]> magnitude=2.d0
   
   # some numerical values
   #VARIABLE <adv_limiter> 0.d0 # this is the most stable - ie, first order upwinding on momentum advection
   VARIABLE <adv_limiter> 1.d0 # this is the least stable but quite accurate - ie, high order non-limited upwinding on momentum advection
   CONSTANT <dt_initial> [] 5.d-3 # now taking largish timestep, overwriting the default timestep used in transient_constant_setup which is roughly based on a CFL number
   CONSTANT <dt_out> [] 3.d-1
   
   # some monitoring variables
   NONE_OUTPUT <centreline inlet p> "facesum(<p_f>,region=<inlet centreline>)"
   NONE_OUTPUT <average inlet p> "facesum(<p_f>*<facearea>,region=<inlet>)/facesum(<facearea>,region=<inlet>)"
   CELL_OUTPUT <u mag> "sqrt(dot(<u[l=:]>,<u[l=:]>))" ON <allcells>
   NONE_OUTPUT <u ave[l=1]> "cellsum(<u[l=1]>*<cellvol>,region=<domain>)/cellsum(<cellvol>,region=<domain>)"
   NONE_OUTPUT <u ave[l=2]> "cellsum(<u[l=2]>*<cellvol>,region=<domain>)/cellsum(<cellvol>,region=<domain>)"
   NONE_OUTPUT <u mag ave> "cellsum(<u mag>*<cellvol>,region=<domain>)/cellsum(<cellvol>,region=<domain>)"
   NONE_OUTPUT <u monitor[l=1]> "cellsum(<u[l=1]>,region=<wake monitor>)"
   NONE_OUTPUT <u monitor[l=2]> "cellsum(<u[l=2]>,region=<wake monitor>)"
   NONE_OUTPUT <u mag monitor> "cellsum(<u mag>,region=<wake monitor>)"
      #(comment created during unwrap): new block = ../../templates/navier_stokes/u_f_vector.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "u_f_vector" # output u_f as a vector for visualisation
      # idea here is to just output the face centred advection flux as a vector
      # call with R "<u_f" W "<my_f_component" to change variable being acted upon
      FACE_OUTPUT <u_f_visualise[l=1]> "<u_f>*<facenorm[l=1]>" ON <allfaces>
      FACE_OUTPUT <u_f_visualise[l=2]> "<u_f>*<facenorm[l=2]>" ON <allfaces>
      #FACE_OUTPUT <u_f_visualise[l=3]> "<u_f>*<facenorm[l=3]>" ON <allfaces>
      #(comment created during unwrap): new block = ../../templates/navier_stokes/CFL_number.arb: sub_block = 0
      #(hash inserted during unwrap)INCLUDE "CFL_number" # this calculates the CFL number actually used
      # these lines just output the global CFL number for a transient simulation
      # replace nooutput with output to also output local CFL number
      # <facedivop> is positive if a face normal points outwards from the last cell, so these numbers are based on the total flowrate out of each cell
      CELL_LOCAL <CFL local/dt> "facesum(faceif(<facedivop>*<u_f>,<facedivop>*<u_f>,0.d0),region=<celljfaces>)" ON <domain> nooutput
      #CELL_LOCAL <CFL local/dt> "facesum(faceif(<facedivop>*<u_f>,1.d0*<facedivop>*<u_f>,0.d0),region=<celljfaces>)/1.d0" ON <domain> nooutput
      CELL_LOCAL <CFL local> "<dt>*<CFL local/dt>" ON <domain> nooutput
      NONE_OUTPUT <CFL> "cellmax(<CFL local>,region=<domain>)" output
   
   #-------------------------------------------------------------------
      #(comment created during unwrap): new block = transient_flow_around_cylinder_with_species.arb: sub_block = 1
      #(hash inserted during unwrap)IF 1
      # also track a concentration field, which eminates from the cylinder surface (Dirichlet boundary condition)
      #(hash inserted during unwrap)INCLUDE_TEMPLATE "species_transport"
      
      # the following implements non-limited advection of <c>
         #(comment created during unwrap): new block = transient_flow_around_cylinder_with_species.arb: sub_block = 2
         #(hash inserted during unwrap)IF 0
         #(hash inserted during unwrap)# without any change to <c limiter_species0> this results in first order upwinding of <c>, which is stable, produces bounded results, but is not accurate
         #(hash inserted during unwrap)INCLUDE "equations" 
         #(hash inserted during unwrap)
         #(hash inserted during unwrap)VARIABLE <c limiter_species0> "1.d0" # this will use high order non-limited upwinding, which will cause under and over shoots
         #(comment created during unwrap): new block = transient_flow_around_cylinder_with_species.arb: sub_block = 2
         #(hash inserted during unwrap)ELSE
         # the following implements high order limited advection of <c>, with limits on the gradient found by looking upwind 2 levels of separation from each cell
            #(comment created during unwrap): new block = ../../templates/species_transport/equations.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "equations" 
            # 2 is the default, anymore is probably overboard, but it does demonstrates how to change this separation
               #(comment created during unwrap): new block = ../../templates/species_transport/equations_nonuniform_width.arb: sub_block = 0
               #(hash inserted during unwrap)INCLUDE "equations_nonuniform_width" 
               
               #(hash inserted during unwrap)MARKDOWN
               #(hash inserted during unwrap)Transport equations for a generic species c in a channel that may have nonuniform width, originally developed in the context of doing a4f simulations
               #(hash inserted during unwrap)On entry, replace /species/ by the name of the species that you want to solve (defaulting to species0).
               #(hash inserted during unwrap)For limited advection, make sure that you set <c magnitude_/species/> so that the advection routine works correctly.
               #(hash inserted during unwrap)END_MARKDOWN
               
               # default species name, overwrite with another name on entry
               
               
               # default is that high order advection is used unless this string is overwritten by 0, which then becomes unlimited advection with order dependent on <c_advection_limiter_/species/>
               
               
               # these are all of the ports used in the domain, used for boundary conditions and reported variables
               
               CONSTANT <c_D_species0> [m^2/s] 1.d0 # diffusivity of species
               CONSTANT <c_inlet_conc_species0> [mol/m^3] 1.d0 # inlet concentration of species
               
               CELL_UNKNOWN <c_species0> [mol/m^3] "0.d0" ON <allcells> magnitude=1.d0 # remember to put in characteristic magnitude later in the file if it isn't 1
               CELL_LOCAL <c_pos_species0> [mol/m^3] "cellmax(<c_species0>,default=0.d0)" # may be needed for reactions
               CELL_TRANSIENT <c_species0[r=1]> [mol/m^3] "<c_species0>" "<c_species0>" ON <allcells> # the previous timestep concentration field
               
                  #(comment created during unwrap): new block = ../../templates/species_transport/equations_nonuniform_width.arb: sub_block = 1
                  #(hash inserted during unwrap)IF 1
                     #(comment created during unwrap): new block = ../../templates/species_transport/relative_advection_limiter.arb: sub_block = 0
                     #(hash inserted during unwrap)INCLUDE "relative_advection_limiter" # we use the template file limiters here, rather than the generic limiters
                     #(hash inserted during unwrap)MARKDOWN
                     #(hash inserted during unwrap)Here we setup an implicit relative limiter for <c_/species>, adding the necessary suffixes to all of the variables used in the limiter calculation
                     #(hash inserted during unwrap)END_MARKDOWN
                     
                     #(hash inserted during unwrap)INCLUDE_TEMPLATE "advection_limiters/implicit" 
                     
                     # first do the replacement of <phi
                     
                     
                     # now add the species suffix to all variables used on the advection scheme that are specific to each species
                     # we do this by first defining the variable list <<replacment_variables>> here, so that the scope of this variable is local to this file
                     
                     # the actual values are set by a REPLACEMENT SUBSTITUTE command in the following template file
                        #(comment created during unwrap): new block = ../../templates/advection_limiters/implicit/set_replacement_variables.arb: sub_block = 0
                        #(hash inserted during unwrap)INCLUDE "set_replacement_variables"
                        # here we set <<replacement_variables>> to be a list of all variables used in these implicit advection routines
                        # used when setting suffixes etc
                        # note that a 'SUBSTITUTE' replacement is used, requiring that this variable be in the scope of one of the calling blocks (files)
                        # this is processed as a variablelist, which is space delimited, but does not actually require the quotes
                        
                     
                     
                     
                     #INCLUDE "relative_steady_state_limiter.arb"
                        #(comment created during unwrap): new block = ../../templates/advection_limiters/implicit/relative_transient_limiter.arb: sub_block = 0
                        #(hash inserted during unwrap)INCLUDE "relative_transient_limiter.arb"
                        #--------------------------------------------------------
                        # set <phi upper bound> and <phi lower bound> based on first order upwind results from surrounding cells
                        # the upwind in relative_upwind_limits means that the local bounds on <phi> are calculated using cells that are upwind and upwind again from the local cell
                        
                        # this is the default separation levels to look upwind - as this is a default general replacement, it will be overwritten by any <<upwindseparation>> replacement occuring upstream
                        
                        
                        # calculate the upwind cell-centred phi which will be used to identify relative limits
                           #(comment created during unwrap): new block = ../../templates/advection_limiters/implicit/upwind_phi.arb: sub_block = 0
                           #(hash inserted during unwrap)INCLUDE "upwind_phi"
                           # first calculate the low order face-centred advection values
                           FACE_DERIVED <c_f low order_species0> "faceave[advection](<c_species0>,<u_f>,0.d0)" ON <allfaces>
                           # TODO: need to limit this in cases of zero velocity
                           CELL_DERIVED <c_c low order_species0> "celldiv(faceif(-<facefromcelldirection>*<u_f>,-<u_f>*<c_f low order_species0>,0.d0))/cellmax(celldiv(faceif(<facefromcelldirection>*<u_f>,<u_f>,0.d0)),1.d-10)" ON <allcells> nooutput
                           
                        
                        # now using a separation loop that employs the faceseparationflag to look a number of separation levels upwind of the current cell
                        CELL_DERIVED <c upper bound_species0> "cellmax[maxseparation=2,faceseparation](<c_c low order_species0>,default=<c_c low order_species0>,region=<allcells>,faceseparationflag=-<facefromcelldirection>*<u_f>)" ON <domain> nooutput
                        CELL_DERIVED <c lower bound_species0> "cellmin[maxseparation=2,faceseparation](<c_c low order_species0>,default=<c_c low order_species0>,region=<allcells>,faceseparationflag=-<facefromcelldirection>*<u_f>)" ON <domain> nooutput
                        
                        #--------------------------------------------------------
                        # do all the limiter calcs
                        
                           #(comment created during unwrap): new block = ../../templates/advection_limiters/implicit/limiter.arb: sub_block = 0
                           #(hash inserted during unwrap)INCLUDE "limiter"
                           # vector from centre to face within each cell
                           # these will need <<dim1comment>> etc replaced either with spaces or comments, depending on which dimensions are being solved for
                              #(comment created during unwrap): new block = ../../templates/advection_limiters/implicit/centre_to_face_vector.arb: sub_block = 0
                              #(hash inserted during unwrap)INCLUDE "centre_to_face_vector"
                              # vector to the face from the last cell centre
                              FACE_LOCAL <xc_to_xf[l=1]> "<facex[l=1]>-faceave[lastcell](<cellx[l=1]>)"
                              FACE_LOCAL <xc_to_xf[l=2]> "<facex[l=2]>-faceave[lastcell](<cellx[l=2]>)"
                              #FACE_LOCAL <xc_to_xf[l=3]> "<facex[l=3]>-faceave[lastcell](<cellx[l=3]>)"
                           
                           # calculate <phi limiter kernel> which is only limited to ensure that the kernel components are below certain maximums
                              #(comment created during unwrap): new block = ../../templates/advection_limiters/implicit/kernel_limiter.arb: sub_block = 0
                              #(hash inserted during unwrap)INCLUDE "kernel_limiter"
                              # this limiter ensures that the effective kernels used to calculate the face centred quantities within each cell are below certain maximums
                              # making these numbers smaller will cause the method to become more upwind
                              NONE_CONSTANT <c limiter crosskernel max> 0.45d0 # the maximum multiplier for any cell value that is not the central cell
                              NONE_CONSTANT <c limiter centralkernel max> 0.05d0 # the maximum multiplier for the central cell value
                              CELL_LOCAL <c limiter crosskernel> "cellif(<crosskernel>-<c limiter crosskernel max>,<c limiter crosskernel max>/<crosskernel>,1.d0)"
                              CELL_LOCAL <c limiter centralkernel> "cellif(<centralkernel>-<c limiter centralkernel max>,<c limiter centralkernel max>/<centralkernel>,1.d0)"
                              CELL_CONSTANT <c limiter kernel> "cellmin(<c limiter crosskernel>,<c limiter centralkernel>)" ON <allcells>
                           
                           # calculate cell centred phi gradients
                              #(comment created during unwrap): new block = ../../templates/advection_limiters/implicit/limiter_gradients.arb: sub_block = 0
                              #(hash inserted during unwrap)INCLUDE "limiter_gradients"
                              CELL_DERIVED <c limiter grad_species0[l=1]> "cellgrad[l=1](<c_species0>)*<c limiter kernel>" ON <allcells>
                              CELL_DERIVED <c limiter grad_species0[l=2]> "cellgrad[l=2](<c_species0>)*<c limiter kernel>" ON <allcells>
                              #CELL_DERIVED <c limiter grad_species0[l=3]> "cellgrad[l=3](<c_species0>)*<c limiter kernel>" ON <allcells>
                           
                           # <phi delta> is the change in phi from the lastcell to face centre, based on the unlimited gradient
                           FACE_LOCAL <c delta_species0> "dot(<xc_to_xf[l=:]>,faceave[lastcell](<c limiter grad_species0[l=:]>))"
                           
                           # TODO: write order(<phi>) function to allow the following:
                           #NONE_CONSTANT <phi magnitude> "nonemagnitude(<phi>)" # this function works except that the magnitudes haven't been calculated yet when this constant is evaluated - so in summary, this line doesn't work!
                           NONE_CONSTANT <c magnitude_species0> "cellmax(abs(<c_species0>),region=<allcells>)"
                           NONE_CONSTANT <c eps_species0> "<c magnitude_species0>*1.d-20" # a small phi value, used to guard against divide by zero
                           
                           # this is the maximum absolute <phi delta> value
                           CELL_LOCAL <c deltac_species0> "facemax(abs(<c delta_species0>),default=0.d0,region=<celljfaces>)" ON <domain>
                           CELL_LOCAL <c diff_species0> "cellmin(<c upper bound_species0>-<c_species0>,-(<c lower bound_species0>-<c_species0>))" ON <domain>
                           CELL_LOCAL <c diff bounded_species0> "cellmax(<c diff_species0>,0.d0)" ON <domain>
                           # these numbers control how aggressively the limiter limits and hence the diagonal dominance of the resulting jacobian matrix
                           NONE_CONSTANT <c a> 4.0d0 # determines the gradient of the limiter
                           NONE_CONSTANT <c b> 0.25d0 # between 0 and 1.  Less than 0.5 is probably required for any guarantee of diagonal dominance.  At b=0 all gradients will be limited to some extent.  If b=1 then only gradients that are absolutely going to cause under/overshoots will be limited (but the resulting Jacobian is unlikely to be diagonally dominant for a pure advection problem)
                           CELL_DERIVED <c betar_species0> "<c diff bounded_species0>/(<c deltac_species0>+<c eps_species0>)" ON <domain> nooutput
                           CELL_LOCAL <c limiter domain_species0> "cellif(1.d0-<c b>*<c betar_species0>,<c betar_species0>^2/(<c betar_species0>^2+<c a>*(1.d0-<c b>*<c betar_species0>)^2),1.d0)"
                           CELL_DERIVED <c limiter_species0> "cellif(celldelta(<domain>),<c limiter domain_species0>,0.d0)" ON <allcells>
                           
                           # overwrite various parameters that define how conservative (ie, stable) the limiter is
                              #(comment created during unwrap): new block = ../../templates/advection_limiters/implicit/default_parameters.arb: sub_block = 0
                              #(hash inserted during unwrap)INCLUDE "default_parameters"
                              # these are the parameters that are now standard (v0.50), and included at the end of the limiter file now, overwriting those in limiter.arb and kernel_limiter.arb
                              NONE_CONSTANT <c a> 4.0d0 # determines the gradient of the limiter
                              NONE_CONSTANT <c b> 0.25d0 # between 0 and 1.  Less than 0.5 is probably required for any guarantee of diagonal dominance.  At b=0 all gradients will be limited to some extent.  If b=1 then only gradients that are absolutely going to cause under/overshoots will be limited (but the resulting Jacobian is unlikely to be diagonally dominant for a pure advection problem)
                              NONE_CONSTANT <c limiter crosskernel max> 0.45d0 # the maximum multiplier for any cell value that is not the central cell
                              NONE_CONSTANT <c limiter centralkernel max> 0.05d0 # the maximum multiplier for the central cell value
                        
                        #--------------------------------------------------------
                     #INCLUDE "conservative_parameters"
                     
                     # no need to cancel the suffix replacements again given that the scope is local to this file
                  NONE_CONSTANT <c magnitude_species0> [mol/m^3] 1.d0
                  FACE_DERIVED <c_f_species0> [mol/m^3] "faceave[advection](<c_species0>,<u_f>,<c limiter_species0>,gradient[l=1]=<c limiter grad_species0[l=1]>,gradient[l=2]=<c limiter grad_species0[l=2]>,gradient[l=3]=<c limiter grad_species0[l=3]>)" ON <allfaces> # this represents the concentratino of species c1 that crosses each face (ie, cell boundary) by advection (fluid flow)
                  #(comment created during unwrap): new block = ../../templates/species_transport/equations_nonuniform_width.arb: sub_block = 1
                  #(hash inserted during unwrap)ELSE
                  #(hash inserted during unwrap)# to use low order (or non-limited high order) advection just include the following afterwards
                  #(hash inserted during unwrap)NONE_CONSTANT <c_advection_limiter_species0> 0.d0 # this determines how accurate in time/space the concentration field is.  0=> low accuracy, high stability, bounded, low computational cost: 1=> higher accuracy (assuming that the function is smooth), low stability, greater possibility of over/undershoots (ie, negative values) and slightly higher computational costs.  There are more expensive advection schemes that we can use to give the properties of both if need be.
                  #(hash inserted during unwrap)FACE_DERIVED <c_f_species0> [mol/m^3] "faceave[advection](<c_species0>,<u_f>,<c_advection_limiter_species0>)" ON <allfaces> # this represents the concentratino of species c1 that crosses each face (ie, cell boundary) by advection (fluid flow)
                  #(hash inserted during unwrap)END_IF
               
               FACE_DERIVED <c_j_f_species0> [mol/(m^2.s)] "<c_f_species0>*<u_f>-<c_D_species0>*facegrad(<c_species0>)" ON <allfaces> # this is the flux of species over each cell face, composed of an advection and diffusion component
               CELL_DERIVED <c_source_species0> [mol/(m^3.s)] "0.d0" ON <domain> # this is a source term in the equation, that represents the amount of species that is being generated in each cell (mol/m^3.s).  If reactions are occurring, overwrite this stoichiometry adjusted reaction rates for each reaction that this species is involved in.
               
               # implicit timestepping right now
               # this is the advection/diffusion transport equation being solved
               #CELL_EQUATION <c equation_species0> [mol/(m^3.s)] "celldiv(1.d0*<c_j_f_species0>)/1.d0 - <c_source_species0>" ON <domain>
               CELL_EQUATION <c equation_species0> [mol/(m^3.s)] "(<c_species0>-<c_species0[r=1]>)/<dt> + celldiv(1.d0*<c_j_f_species0>)/1.d0 - <c_source_species0>" ON <domain>
               
               # boundary conditions now
               # walls
               FACE_EQUATION <c walls_species0> "<c_j_f_species0>" ON <walls> # on the walls we set the flux of species c1 into the wall equal to zero
               
               # ports
               # first setup equations for all of the ports being no-flow, and then overwrite specific ones either here or later
               FACE_EQUATION <c inlet equation_species0> '<c_j_f_species0>' ON <inlet>
               NONE_OUTPUT <inlet_area> 'facesum(<facearea>*1.d0,region=<inlet>)'
               NONE_OUTPUT <inlet_flowrate> 'facesum(<facearea>*1.d0*<u_f>,region=<inlet>)'
               NONE_OUTPUT <c ave inlet_species0> 'facesum(<c_species0>*<facearea>*1.d0,region=<inlet>)/nonemax(<inlet_area>,<tinyish>)'
               NONE_OUTPUT <c flux inlet_species0> 'facesum(<c_species0>*<facearea>*1.d0*<u_f>,region=<inlet>)'
               NONE_OUTPUT <c bulk ave inlet_species0> '<c flux inlet_species0>/nonemax(<inlet_flowrate>,<tinyish>)'
               FACE_EQUATION <c outlet equation_species0> '<c_j_f_species0>' ON <outlet>
               NONE_OUTPUT <outlet_area> 'facesum(<facearea>*1.d0,region=<outlet>)'
               NONE_OUTPUT <outlet_flowrate> 'facesum(<facearea>*1.d0*<u_f>,region=<outlet>)'
               NONE_OUTPUT <c ave outlet_species0> 'facesum(<c_species0>*<facearea>*1.d0,region=<outlet>)/nonemax(<outlet_area>,<tinyish>)'
               NONE_OUTPUT <c flux outlet_species0> 'facesum(<c_species0>*<facearea>*1.d0*<u_f>,region=<outlet>)'
               NONE_OUTPUT <c bulk ave outlet_species0> '<c flux outlet_species0>/nonemax(<outlet_flowrate>,<tinyish>)'
               
               
               # overwrite the equations used for the inlet and outlet ports
               # other additional ports will generally need their own equations given after this file is called
               # here are some ideas re how to change the inlet concentration with time
               #NONE_TRANSIENT <c_inlet_/species/> [mol/m^3] "0.d+0" "noneif(-<t>-<t_injection_start>,0.d0,noneif(-<t>+<t_injection_stop>,<c_inlet_conc_/species/>,0.d0))" # injection of species
               #NONE_TRANSIENT <c_inlet_/species/> [mol/m^3] "0.d+0" "noneif(-<t>-<t_injection_start>,0.d0,noneif(-<t>+<t_injection_stop>,<c_inlet_conc_/species/>,0.d0))" # injection of species
               FACE_EQUATION <c inlet equation_species0> "<c_species0>-<c_inlet_conc_species0>" ON <inlet>
               FACE_EQUATION <c outlet equation_species0> "faceif(<u_f>,facegrad(<c_species0>),<c_species0>)" ON <outlet> # boundary condition is zero gradient for outflow, and zero concentration for inflow
               
               # report some averaged and extreme variables
               NONE_OUTPUT <c maximum_species0> [mol/m^3] "cellmax(<c_species0>,region=<allcells>)"
               NONE_OUTPUT <c minimum_species0> [mol/m^3] "cellmin(<c_species0>,region=<allcells>)"
               NONE_OUTPUT <c total_species0> [mol] "cellsum(<c_species0>*<cellvol>*1.d0,region=<domain>)"
               NONE_CONSTANT <total vol> [m^3] "cellsum(<cellvol>*1.d0,region=<domain>)" output
               NONE_OUTPUT <c average_species0> [mol/m^3] "<c total_species0>/<total vol>"
         # further, modify the parameters used in the advection limiting routine to be less conservative (less stable, but more accurate by doing less gradient limiting)
         #(hash inserted during unwrap)INCLUDE_TEMPLATE "advection_limiters/implicit"
            #(comment created during unwrap): new block = ../../templates/advection_limiters/implicit/extreme_parameters.arb: sub_block = 0
            #(hash inserted during unwrap)INCLUDE "extreme_parameters" 
            # set higher accuracy but lower stability advection parameters
            # are are less conservative (ie, less stable) than the default parameters
            NONE_CONSTANT <c a> 1.5d0 # determines the gradient of the limiter
            NONE_CONSTANT <c b> 0.6d0 # between 0 and 1.  Less than 0.5 is probably required for any guarantee of diagonal dominance.  At b=0 all gradients will be limited to some extent.  If b=1 then only gradients that are absolutely going to cause under/overshoots will be limited (but the resulting Jacobian is unlikely to be diagonally dominant for a pure advection problem)
            NONE_CONSTANT <c limiter crosskernel max> 0.5d0 # the maximum multiplier for any cell value that is not the central cell
            NONE_CONSTANT <c limiter centralkernel max> 0.05d0 # the maximum multiplier for the central cell value
         VARIABLE <c limiter_species0> output
         #(hash inserted during unwrap)END_IF
      
      # overwrite some species boundary conditions etc
      FACE_EQUATION <c walls_species0> "<c_species0>-1.d0" ON <walls> # <walls> is the cylinder surface, which has the set concentration
      FACE_EQUATION <c slip walls_species0> "<c_j_f_species0>" ON <slip walls> # whereas on the <slip walls> we use a zero flux condition
      CONSTANT <c_inlet_conc_species0> 0.d0 # nothing coming in
      CONSTANT <c_D_species0> 1.d-2 # small, nonzero diffusivities are the hardest to compute accurately using these boundary conditions, as mesh resolution in the concentration boundary layer becomes critical
      
      # various outlet conditions:
      #FACE_EQUATION <c outlet equation_species0> "faceif(<u_f>,facegrad[adjacentcells](<c_species0>),<c_species0>)" ON <outlet> # boundary condition is zero gradient for outflow, and zero concentration for inflow
      FACE_EQUATION <c outlet equation_species0> "facegrad[adjacentcells](<c_species0>)" ON <outlet> # the most stable type of outlet boundary condition
      #FACE_EQUATION <c outlet equation_species0> "faceif(<u_f>,facegrad(<c_species0>),<c_species0>)" ON <outlet> # boundary condition is zero gradient for outflow, and zero concentration for inflow
      
      # the following can be used as a destruction term
      #NONE_CONSTANT <c_source_factor_species0> 0.1d0
      #VARIABLE <c_source_species0> "-<c_source_factor_species0>*<c_pos_species0>" # including concentration destruction term now
      
      NONE_OUTPUT <c monitor_species0> "cellsum(<c_species0>,region=<wake monitor>)"
      
      #(hash inserted during unwrap)END_IF
   #-------------------------------------------------------------------
   # just for the example problem do a few steps only
   GENERAL_OPTIONS timestepout=2
   #GENERAL_OPTIONS timestepadditional=1 # NB, timestepadditional only guarantees than simulation will run an additional number of timesteps, not that it will stop after this number of timesteps
   GENERAL_OPTIONS timestepmax=4
   #-------------------------------------------------------------------
##################################################################################
