MARKDOWN
Calculate gamma and related properties for a multifluid <<species>> = speciesN, mixture or allsolids.

For each of <<species>>, the following are defined
<u_<<species>>[l=:]> - CELL_DERIVED, only for mixture and allsolids
<ugrad_f_<<species>>[l=:,:]> - FACE_DERIVED
<ugrad_<<species>>[l=:,:]> - FACE_DERIVED
<gamma_f_<<species>>[l=:,:]> - FACE_DERIVED
<gamma_<<species>>[l=:,:]> - CELL_LOCAL
<gamma_magnitude_f_<<species>>> - FACE_DERIVED
<gamma_magnitude_<<species>>> - CELL_LOCAL
<gamma_total_magnitude_f_<<species>>> - FACE_DERIVED
<gamma_total_magnitude_<<species>>> - CELL_LOCAL
<gamma_spherical_f_<<species>>> - FACE_DERIVED
<gamma_spherical_<<species>>> - CELL_LOCAL

Now option to remove isotropic part of strain rate tensor, meaning that gamma is deviatoric, determined by <<deviatoric_gamma>>
END_MARKDOWN

# given that all of the stress closure models tend to assume this on the microscopic scale, should be best to present to them a deviatoric gamma on the macroscopic scale
REPLACEMENTS D "<<deviatoric_gamma>>" W "1"

# if this is for the 'mixture' or 'allsolids' species, then appropriate velocities have to be defined first
IF {{ return (string_test('<<species>>','mixture')) }}
  {{
    my $return_string = '';
    $return_string .= "CELL_DERIVED <u_mixture[l=<<i>>]> '0.d0' ON <allcells>\n";
    for my $species (string_eval('<<multifluid_species_list>>','list')) {
      $return_string .= "VARIABLE <u_mixture[l=<<i>>]> '<u_mixture[l=<<i>>]>+<phi_pos_$species>*<u_$species"."[l=<<i>>]>'\n";
    }
    return $return_string;
  }}
ELSE_IF {{ return (string_test('<<species>>','allsolids')) }}
  {{
    my $return_string = '';
    $return_string .= "CELL_DERIVED <u_allsolids[l=<<i>>]> '0.d0' ON <allcells>\n";
    for my $species (string_eval('<<multifluid_disperse_species_list>>','list')) {
      $return_string .= "VARIABLE <u_allsolids[l=<<i>>]> '<u_allsolids[l=<<i>>]>+<phi_pos_$species>*<u_$species"."[l=<<i>>]>'\n";
    }
    return $return_string;
  }}
END_IF

# velocity gradient
FACE_DERIVED <ugrad_f_<<species>>[l=<<i>>,<<j>>]> "facegrad[l=<<i>>,<<reflect=<<j>>>>](<u_<<species>>[l=<<j>>]>)" ON <allfaces>

# symmetric strain rate
FACE_DERIVED <gamma_f_<<species>>[l=<<i>>,<<j>>]> "(<ugrad_f_<<species>>[l=<<i>>,<<j>>]>+<ugrad_f_<<species>>[l=<<j>>,<<i>>]>)" ON <allfaces>

# need to redo labels so that gamma_f is deviatoric, gamma_total_f is the full one
IF <<deviatoric_gamma>>
# calculate the spherical part of gamma, which is the trace divided by the number of dimensions
# using repeated summing of components into a scalar, which expands as a line for each <<i>> index
  FACE_LOCAL <gamma_spherical_f_<<species>>> "<gamma_spherical_f_<<species>>>+2.d0*<ugrad_f_<<species>>[l=<<i>>,<<i>>]>" ON <allfaces> output
# and normalise by the number of dimensions, which is the number of elements in the default dimensions
  VARIABLE <gamma_spherical_f_<<species>>> "(<gamma_spherical_f_<<species>>>)/{{ return string_eval('<<dimensions>>','count') }}"
# remove the spherical part from gamma to leave a deviatoric tensor
  VARIABLE <gamma_f_<<species>>[l=<<i>>,<<i>>]> "<gamma_f_<<species>>[l=<<i>>,<<i>>]>-<gamma_spherical_f_<<species>>>"

# old code
#   FACE_LOCAL <gamma_spherical_f_<<species>>> "0.d0" ON <allfaces> 
#   {{ 
#     my $return_string = '';
#     for my $ldim (string_eval('<<dimensions>>','list')) {
#       $return_string .= "VARIABLE <gamma_spherical_f_<<species>>> '<gamma_spherical_f_<<species>>>+2.d0*<ugrad_f_<<species>>[l=$ldim,$ldim]>'\n";
#     }
#     return $return_string;
#   }}
END_IF

# TODO: add aximuthal component to gamma here if there is one
# TODO: gamma_total_magnitudes

# cell centred same
CELL_LOCAL <gamma_<<species>>[l=<<i>>,<<j>>]> "<gamma_f_<<species>>[l=<<i>>,<<j>>]>" ON <allcells>

# magnitude of the strain rate, on the faces (checked consistency with BSL, p241, where gamma is the sum of the velocity gradient + transpose)
IF <<azimuthal>>
  FACE_DERIVED <gamma_magnitude_f_<<species>>> "sqrt(facemax(0.5d0*ddot(<gamma_f_<<species>>[l=:,:]>,<gamma_f_<<species>>[l=:,:]>)+2.d0*faceave(<u_<<species>>[l=<<radialdim>>]>/<cellx[l=<<radialdim>>]>)**2- facegrad[l=<<radialdim>>,reflect=<<radialdim>>](<u_<<species>>[l=<<azimuthaldim>>]>**2/<cellx[l=<<radialdim>>]>),<tinyish>))" ON <allfaces> output
  CELL_LOCAL <gamma_magnitude_<<species>>> "cellave(<gamma_magnitude_f_<<species>>>)" ON <allcells>
ELSE_IF <<cylindrical>>
  FACE_DERIVED <gamma_magnitude_f_<<species>>> "sqrt(facemax(0.5d0*ddot(<gamma_f_<<species>>[l=:,:]>,<gamma_f_<<species>>[l=:,:]>)+2.d0*faceave(<u_<<species>>[l=<<radialdim>>]>/<cellx[l=<<radialdim>>]>)**2,<tinyish>))" ON <allfaces> output
  IF 1
# the cylindrical version includes another component based on the radial dimension, which is calculated directly from cell centred variables
    CELL_LOCAL <gamma_magnitude_<<species>>> "sqrt(cellmax(0.5d0*cellave(ddot(<gamma_f_<<species>>[l=:,:]>,<gamma_f_<<species>>[l=:,:]>)+2.d0*(<u_<<species>>[l=<<radialdim>>]>/<cellx[l=<<radialdim>>]>)**2),<tinyish>))" ON <allcells>
  ELSE
    CELL_LOCAL <gamma_magnitude_<<species>>> "cellave(<gamma_magnitude_f_<<species>>>)" ON <allcells>
  END_IF
# TODO: gamma_total_magnitudes
ELSE
# FACE_DERIVED <gamma_magnitude_f_<<species>>> "sqrt(facemax(0.5d0*ddot(<gamma_f_<<species>>[l=:,:]>,<gamma_f_<<species>>[l=:,:]>),<tinyish>))" ON <allfaces> output
# or use inbuilt function which >0 always, and is entirely equivalent to the above for a tensor
  FACE_DERIVED <gamma_magnitude_f_<<species>>> "mag(<gamma_f_<<species>>[l=:,:]>)" ON <allfaces> output
  CELL_LOCAL <gamma_magnitude_<<species>>> "cellave(<gamma_magnitude_f_<<species>>>)" ON <allcells>
  IF <<deviatoric_gamma>>
# if everything is based on deviatoric gamma, also calculate strain rate magnitude that includes the spherical component, known as the gamma_total_magnitude
# <gamma_magnitude_f_...> is already >0 via cutoff in mag function
# the perl evaluates as the number of dimensions, and is consistent with that used in the calculation of the spherical part of gamma
    FACE_LOCAL <gamma_total_magnitude_f_<<species>>> "sqrt(<gamma_magnitude_f_<<species>>>^2+0.5d0*{{ return string_eval('<<dimensions>>','count') }}*<gamma_spherical_f_<<species>>>^2)" ON <allfaces> output
    CELL_LOCAL <gamma_total_magnitude_<<species>>> "cellave(<gamma_total_magnitude_f_<<species>>>)" ON <allcells>
  END_IF
END_IF


IF 1
# trial overwriting interpolated cell centred strain rates with those calculated form celldivgrad instead

# in case we are dealing with mixture or allsolids, make sure that u_f_vect is defined
  FACE_LOCAL <u_f_vect_<<species>>[l=<<i>>]> "faceave[<<reflect=<<i>>>>](<u_<<species>>[l=<<i>>]>)" ON <allfaces> output

# velocity gradient
  CELL_DERIVED <ugrad_<<species>>[l=<<i>>,<<j>>]> "celldivgrad[l=<<i>>](<u_f_vect_<<species>>[l=<<j>>]>)" ON <allcells> output

# symmetric strain rate
  CELL_LOCAL <gamma_total_<<species>>[l=<<i>>,<<j>>]> "(<ugrad_<<species>>[l=<<i>>,<<j>>]>+<ugrad_<<species>>[l=<<j>>,<<i>>]>)" ON <allcells> output

# calculate spherical component
  CELL_LOCAL <gamma_spherical_<<species>>> "<gamma_spherical_<<species>>>+<gamma_total_<<species>>[l=<<i>>,<<i>>]>" ON <allcells> output
# and normalise by the number of dimensions, which is the number of elements in the default dimensions
  VARIABLE <gamma_spherical_<<species>>> "(<gamma_spherical_<<species>>>)/{{ return string_eval('<<dimensions>>','count') }}"
# mixture does not have u_f_vect defined
# CELL_LOCAL <gamma_2divu_<<species>>> "2.d0*celldiv(<u_f_{raw}_<<species>>>)/{{ return string_eval('<<dimensions>>','count') }}" ON <allcells> output
  CELL_LOCAL <gamma_2divu_<<species>>> "2.d0*celldiv(dot(<u_f_vect_<<species>>[l=:]>,<facenorm[l=:]>))/{{ return string_eval('<<dimensions>>','count') }}" ON <allcells> output

# calculate magnitude of total strain rate
  CELL_DERIVED <gamma_total_magnitude_<<species>>> "mag(<gamma_total_<<species>>[l=:,:]>)" ON <allcells> output

# deviatoric strain rate and magnitude
  CELL_DERIVED <gamma_<<species>>[l=<<i>>,<<j>>]> "<gamma_total_<<species>>[l=<<i>>,<<j>>]>-kronecker(<<i>>,<<j>>)*<gamma_spherical_<<species>>>" ON <allcells> output
  CELL_DERIVED <gamma_magnitude_<<species>>> "mag(<gamma_<<species>>[l=:,:]>)" ON <allcells> output

END_IF
