# here we calculate the expand normals by averaging the angle of the normal, rather than its components

INCLUDE "normals_unit"

# on the <vof_phigrad_mask>, calculate the angle on the interface, <vof_theta>
# 2d only averaging
CELL_DERIVED <vof_theta> "cellif(<vof_phigrad_mask>,atan2(<vof_phigrad_unit[l=2]>,<vof_phigrad_unit[l=1]>),0.d0)" ON <all cells> output
#CELL_DERIVED <vof_theta> "cellif(<vof_phigrad_mask>,<pi>/4.d0,0.d0)" ON <all cells> output # test on reflection
#CELL_DERIVED <vof_theta> "atan2(<cellx[l=2]>,<cellx[l=1]>)-<pi>" ON <all cells> output

# now to expand theta using convolution

# the size of this expansion is really dependent on the size of the kernel used to calculate <vof_kappa_f>, although, as long as this minimum size is satisfied, could also be additionally increased to decrease erroneous current magnitude (although I favour working on <vof_phi_delta> instead)
GENERAL_REPLACEMENTS R "<<maxseparation>>" W "3,faceseparation"
#GENERAL_REPLACEMENTS R "<<maxseparation>>" W "5,faceseparation"
#GENERAL_REPLACEMENTS R "<<maxseparation>>" W "4"

# weight using phigrad mask and mag
#INCLUDE "convolve_variable_dynamic" R "<vof_variable_default>" W "0.d0" R "<vof_variable_convolve_constant>" W "<vof_phigrad_expand_constant>" R "<vof_variable>" W "<vof_theta_relative>" R "<vof_variable_convolve>" W "<vof_theta_relative_expand>"  R "<vof_variable_mask>" W "<vof_phigrad_mask>" R "<vof_variable_convolve" W "<vof_phigrad_expand" R "<vof_variable" W "<vof_phigrad"
#CELL_LOCAL <vof_phigrad_expand_weight> "<vof_phigrad_mag>"

# weight using delta mask and mag
INCLUDE "convolve_variable_dynamic" R "<vof_variable_default>" W "0.d0" R "<vof_variable_convolve_constant>" W "<vof_phigrad_expand_constant>" R "<vof_variable>" W "<vof_theta_relative>" R "<vof_variable_convolve>" W "<vof_theta_relative_expand>"  R "<vof_variable_mask>" W "<vof_delta_mask>" R "<vof_variable_convolve" W "<vof_phigrad_expand" R "<vof_variable" W "<vof_phigrad"
CELL_LOCAL <vof_phigrad_expand_weight> "<vof_delta_mag>"

# weight using delta and phigrad product mag and mask
#INCLUDE "convolve_variable_dynamic" R "<vof_variable_default>" W "0.d0" R "<vof_variable_convolve_constant>" W "<vof_phigrad_expand_constant>" R "<vof_variable>" W "<vof_theta_relative>" R "<vof_variable_convolve>" W "<vof_theta_relative_expand>"  R "<vof_variable_mask>" W "(<vof_delta_mask>*<vof_phigrad_mask>)" R "<vof_variable_convolve" W "<vof_phigrad_expand" R "<vof_variable" W "<vof_phigrad"
#CELL_LOCAL <vof_phigrad_expand_weight> "<vof_delta_mag>*<vof_phigrad_mag>"
#CELL_LOCAL <vof_phigrad_expand_weight> "sqrt(<vof_delta_mag>*<vof_phigrad_mag>)"

NONE_CONSTANT <vof_phigrad_expand_constant> 2.0d0

# calculate theta in separation cell relative to previous theta in central cell, accounting for reflections
CELL_LOCAL <vof_theta_relative> "cellboundangle(atan2(<celltoseparationicellreflect[l=2]>*sin(<vof_theta>),<celltoseparationicellreflect[l=1]>*cos(<vof_theta>))-cellfromcellave[separationcentre](<vof_theta_base>))"
# calculate expanded theta by averaging difference from central cell previous theta
CELL_DERIVED <vof_theta_expand> "cellif(<vof_phigrad_expand_mask>,cellboundangle(<vof_theta_relative_expand>+<vof_theta_base>),0.d0)" ON <all cells>

CELL_TRANSIENT <vof_theta_expand[r=1]> "atan2(<cellx[l=2]>,<cellx[l=1]>)-<pi>" "<vof_theta_expand>" ON <all cells>

# have to find a base angle around which to do the averaging for each cell
# if there was no angle here previously, find angle from surrounding cells (cheapish)
CELL_TRANSIENT <vof_theta_base> "<vof_theta_base_ave>" "cellif(<vof_phigrad_expand_mask[r=1]>,<vof_theta_expand[r=1]>,<vof_theta_base_ave>)" ON <all cells>
CELL_LOCAL <vof_theta_base_ave_n[l=1]> "cellsum[reflect=1](cos(<vof_theta_expand[r=1]>)*<vof_phigrad_expand_mask[r=1]>,region=<cellicells>)/cellmax(cellsum(<vof_phigrad_expand_mask[r=1]>,region=<cellicells>),1.d0)"
CELL_LOCAL <vof_theta_base_ave_n[l=2]> "cellsum[reflect=2](sin(<vof_theta_expand[r=1]>)*<vof_phigrad_expand_mask[r=1]>,region=<cellicells>)/cellmax(cellsum(<vof_phigrad_expand_mask[r=1]>,region=<cellicells>),1.d0)"
CELL_LOCAL <vof_theta_base_ave> "atan2(<vof_theta_base_ave_n[l=2]>,<vof_theta_base_ave_n[l=1]>)"

# finally define some unit vectors from these
<<dim1comment>>CELL_DERIVED <vof_phigrad_expand_unit[l=1]> "cellif(<vof_phigrad_expand_mask>,cos(<vof_theta_expand>),0.d0)" ON <all cells> output
<<dim2comment>>CELL_DERIVED <vof_phigrad_expand_unit[l=2]> "cellif(<vof_phigrad_expand_mask>,sin(<vof_theta_expand>),0.d0)" ON <all cells>

