# interpolate the cell centred velocity to the faces and find the velocity (flux) normal to the face (<u_f>), using a rhie-chow spirited interpolation technique on the domain faces

# check default strings are set
INCLUDE "default_string_replacements"

# start by calculating the difference between the local face centred (dynamic) pressure gradient and average of cell centred (dynamic) pressure gradients in the face direction
# `dynamic' pressure here means the pressure that is able to cause fluid flow, ie, possibly accounting for hydrostatic pressure variations (for example)
INCLUDE "p_error"

<<dim1comment>>FACE_LOCAL <u_f_vect[l=1]> "faceave[<<reflect=1>>](<u[l=1]>)"
<<dim2comment>>FACE_LOCAL <u_f_vect[l=2]> "faceave[<<reflect=2>>](<u[l=2]>)"
<<dim3comment>>FACE_LOCAL <u_f_vect[l=3]> "faceave[<<reflect=3>>](<u[l=3]>)"
FACE_DERIVED <u_f_{raw}> "dot(<u_f_vect[l=:]>,<facenorm[l=:]>)" ON <allfaces> # volume (velocity) transport

# this file now does both steady-state and transient using transient comments string replacements, which are set in constants.arb

# save old correction velocity for transient calculations
<<transientnavierstokescomment>>FACE_TRANSIENT <u_f_{correction}[r=1]> "0.d0" "<u_f_{correction}>" ON <domainfaces>

# assemble <u_f_{correction}>, taking advantage of variable reuse so that only one expression is formed for <u_f_{correction}> (to maximise code efficiency and maxima expression simplifications)

# first assemble demoninator of expression:
# temp
# trying to see whether uniform rhie-chow terms give better response
REPLACEMENTS D '<<celldxaverhiechow>>' W 0
IF <<celldxaverhiechow>>
  REPLACEMENTS R "<facedx>" W "<celldxave>"
END_IF

# all equation variants here have viscous contribution, so add this first
# the rf stands for reciprocal and face centred
# same piece of code as in total_stress to deal with <mu_f> replacement
REPLACEMENTS R "<<mu_f>>" W "<mu_f>" # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
IF {{ return ( !(string_examine('<mu_f>')) && string_eval('<<uniformviscosity>>') ) }}  # this evaluates as true (1) if replacement string '<mu_f>' isn't defined, AND <<uniformviscosity>> is on (1)
  REPLACEMENTS S "<<mu_f>>" W "<mu>" # if we are here then we apply the uniform viscosity substitution
END_IF
FACE_LOCAL <u_rf_{vis}> "<<mu_f>>/<facedx>^2" ON <allfaces> # incase pextrapolationrhiechow is on, define these locals on allfaces (makes no difference to efficiency as they are locals anyway)
FACE_DERIVED <u_f_{correction}> "<u_rf_{vis}>" ON <domainfaces>

# advective contribution can be either simple or more complex (set by <<ufadvectioncomplexcomment>>)
# the default behaviour is to use the simple advective contribution
GENERAL_REPLACEMENTS D <<ufadvectioncomplexcomment>> W "#"
# include the following line in your input file prior to loading this template file to access the more complex contribution
#GENERAL_REPLACEMENTS R <<ufadvectioncomplexcomment>> W ""

REPLACEMENTS R "<<rho_f>>" W "<rho_f>" # first define this local replacement string in the same scope of the definition statements below (ie, outside scope of if block)
IF {{ return ( !(string_examine('<rho_f>')) && string_eval('<<uniformdensity>>') ) }}  # this evaluates as true (1) if replacement string '<rho_f>' isn't defined, AND <<uniformviscosity>> is on (1)
  REPLACEMENTS S "<<rho_f>>" W "<rho>" # if we are here then we apply the uniform density substitution
END_IF

# advection term
IF {{ return (string_test('<<navierstokescomment>>','')) }}
  REPLACEMENTS D "<ufadvectionmag>" W "1" # use this option to base the adv component on the total velocity magnitude, rather than the component over each face
  IF <ufadvectionmag>
    FACE_LOCAL <u_f_{raw}_magnitude> "sqrt(dot(<u_f_vect[l=:]>,<u_f_vect[l=:]>))" ON <allfaces>
    FACE_LOCAL <u_rf_{adv}> "2.d0*<<rho_f>>*<u_f_{raw}_magnitude>/<facedx>" ON <allfaces>
  ELSE_IF {{ return (string_test('<<ufadvectioncomplexcomment>>','')) }}
# or more complex variant, which does not assume generally small correction velocities (and under steady-state conditions is equivalent to what was used pre v0.55) but is more expensive to compute, for what seems like little practical gain.  There is some evidence that the more complex variant can allow steady-state sims to converge more as Re increases, but very very marginal.
    FACE_LOCAL <eps_p> "facemax(abs(<p_error>),<tinyish>)" ON <allfaces>
    FACE_LOCAL <u_rf_{adv}> "<eps_p>/(-abs(<u_f_{raw}>)+sqrt(<u_f_{raw}>^2+<eps_p>*<facedx>/<<rho_f>>))" ON <allfaces>
  ELSE
# next add simple advective contribution (which really assumes that locally |<u_f_{raw}>| >> |<u_f_{correction}>|
    FACE_LOCAL <u_rf_{adv}> "2.d0*<<rho_f>>*abs(<u_f_{raw}>)/<facedx>" ON <allfaces>
  END_IF
  FACE_DERIVED <u_f_{correction}> "<u_f_{correction}>+<u_rf_{adv}>"
END_IF

# for transient, add transient component to demoninator, take reciprocal, and add top transient and pressure contributions
<<transientnavierstokescomment>>FACE_LOCAL <u_rf_{transient}> "<<rho_f>>/<dt>" ON <allfaces>
<<transientnavierstokescomment>>FACE_DERIVED <u_f_{correction}> "(-<C_{Rhie-Chow}>*<p_error>+<u_rf_{transient}>*<u_f_{correction}[r=1]>)/(<u_f_{correction}>+<u_rf_{transient}>)"
# for steady-state just take reciprocal and add pressure contribution
<<steadystatenavierstokescomment>>FACE_DERIVED <u_f_{correction}> "-<C_{Rhie-Chow}>*<p_error>/(<u_f_{correction}>)"

# final face velocity
FACE_DERIVED <u_f> "<u_f_{raw}>+faceif(facedelta(<domainfaces>),<u_f_{correction}>,0.d0)" ON <allfaces> # volume (velocity) transport

# this section just re-works the implicit timestepping equation to allow a newtstepmax to be applied to <dt_target>
# save a derived copy of <dt_target> after <u_f> has been calculated so that we can apply newtstepmax to it
# if <<implicittimestepcomment>> hasn't already been set then set it here (to off) - for on will have already required dynamic timestepping to be on
GENERAL_REPLACEMENTS DEFAULT "<<implicittimestepcomment>>" W "#" DEFAULT "<<explicittimestepcomment>>" W ""
<<transientnavierstokescomment>><<implicittimestepcomment>>NONE_DERIVED <dt_target_derived> "<dt_target>" newtstepmax=10
<<transientnavierstokescomment>><<implicittimestepcomment>>NONE_EQUATION <dt implicit equation> "<dt>-<dt_target_derived>"
