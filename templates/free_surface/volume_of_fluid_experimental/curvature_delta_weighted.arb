# within this file we calculate the curvature
# as cell centred curvature is calculated from face centred curvature, which is itself averaged from the cell centred curvature, makes sense to NOT smooth these normals (normals.arb) prior to calling this file

# roughly a return of the old method 8
#<<dim1comment>>FACE_LOCAL <vof_phigrad_f[l=1]> "facegrad[l=1](<vof_phi_normal>)" ON <all faces>
#<<dim2comment>>FACE_LOCAL <vof_phigrad_f[l=2]> "facegrad[l=2](<vof_phi_normal>)" ON <all faces>
#<<dim3comment>>FACE_LOCAL <vof_phigrad_f[l=3]> "facegrad[l=3](<vof_phi_normal>)" ON <all faces>
# note, not component directions here!
FACE_LOCAL <vof_phigrad_f[l=1]> "facegrad[l=4](<vof_phi_normal>)" ON <all faces>
FACE_LOCAL <vof_phigrad_f[l=2]> "facegrad[l=5](<vof_phi_normal>)" ON <all faces>
FACE_LOCAL <vof_phigrad_f[l=3]> "facegrad[l=6](<vof_phi_normal>)" ON <all faces>
FACE_LOCAL <vof_phigrad_f_mag> "sqrt(dot(<vof_phigrad_f[l=:]>,<vof_phigrad_f[l=:]>))" ON <all faces>
FACE_DERIVED <vof_phigrad_f_scalar> "faceif(cellmax(<vof_delta_mask>,region=<adjacentfaceicells>),facegrad(<vof_phi_normal>)/facemax(<vof_phigrad_f_mag>,<vof_phigrad_tol>),0.d0)" ON <all faces> nooutput

# also define these for cylindrical coordinates
INCLUDE "normals_cellgrad"
INCLUDE "normals_unit"
#<<dim1comment>>CELL_LOCAL <vof_phigrad_unit[l=1]> "cellgrad[l=1](<vof_phi_normal>)" ON <all cells>
#<<dim2comment>>CELL_LOCAL <vof_phigrad_unit[l=2]> "cellgrad[l=2](<vof_phi_normal>)" ON <all cells>
#<<dim3comment>>CELL_LOCAL <vof_phigrad_unit[l=3]> "cellgrad[l=3](<vof_phi_normal>)" ON <all cells>

# doing cartesian and cylindrical curvatures separately
# cartesian
<<cartesiancomment>>CELL_DERIVED <vof_kappa_c> "cellif(<vof_delta_mask>,-celldiv(<vof_phigrad_f_scalar>),0.d0)" ON <all cells> output
# cylindrical
<<cylindricalcomment>>CELL_LOCAL <vof_kappa_cart_c> "-celldiv(<vof_phigrad_f_scalar>)" ON <all cells>
<<cylindricalcomment>>CELL_LOCAL <vof_kappa_cyl_c> "-<vof_phigrad_unit[l=<<radialdim>>]>/<<radius_c>>" ON <all cells> # won't work on centreline, so instead use twice carteisan curvature there
<<cylindricalcomment>>CELL_DERIVED <vof_kappa_c> "cellif(<vof_delta_mask>,cellif(<<radius_c>>-1.d-10,<vof_kappa_cart_c>+<vof_kappa_cyl_c>,2.d0*<vof_kappa_cart_c>),0.d0)" ON <all cells> output

# doing cartesian and cylindrical curvatures using single divergence
#<<cylindricalcomment>>CELL_DERIVED <vof_kappa_c2> "-celldiv(<<radius_f>>*<vof_phigrad_f_scalar>/faceave[lastcell](<<radius_c>>))" ON <all cells> nooutput,elementdata
#<<cartesiancomment>>CELL_DERIVED <vof_kappa_c2> "-celldiv(<vof_n_f_scalar>)" ON <all cells> nooutput,elementdata

# previous to v0.5 just used straight interpolation of kappa_c2 to kappa_f
#FACE_DERIVED <vof_kappa_f> "faceave[adjacentcells](<vof_kappa_c2>)" ON <all faces> output
#FACE_DERIVED <vof_kappa_f> "faceave(<vof_kappa_c2>)" ON <all faces> output

# we now weight the face centred curvature using the delta function magnitude that will be used to apply the surface force
# this promotes interface stability, especially for unstructured problems
# where the delta function is effectively zero, the curvature isn't calculated
FACE_DERIVED <vof_kappa_f> "faceif(<vof_delta_mask_f>,faceave(<vof_kappa_c>*<vof_delta_mag>)/facemax(faceave(<vof_delta_mag>),<vof_phigrad_tol>),0.d0)" ON <all faces> output

